#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]


use ffi;

pub const MODULE_MAGIC_COOKIE: ::libc::c_ulong = 0x41503234u64; /* "AP24" */
pub const MODULE_MAGIC_NUMBER_MAJOR: ::libc::c_int = 20120211;
pub const MODULE_MAGIC_NUMBER_MINOR: ::libc::c_int = 36;

/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self {
            storage,
            align: [],
        }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                val |= 1 << i;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            self.set_bit(i + bit_offset, val_bit_is_set);
        }
    }
}

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T> (::std::marker::PhantomData<T>);

impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self { __IncompleteArrayField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] { ::std::slice::from_raw_parts(self.as_ptr(), len) }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] { ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len) }
}

impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> { fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result { fmt.write_str("__IncompleteArrayField") } }

impl<T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}

impl<T> ::std::marker::Copy for __IncompleteArrayField<T> {}

pub const APEXIT_CHILDFATAL: u32 = 15;
pub const APEXIT_CHILDINIT: u32 = 3;
pub const APEXIT_CHILDSICK: u32 = 7;
pub const APEXIT_INIT: u32 = 2;
pub const APEXIT_OK: u32 = 0;
pub const APRMAXHOSTLEN: u32 = 256;
pub const APR_ALLOCATOR_MAX_FREE_UNLIMITED: u32 = 0;
pub const APR_ANONYMOUS: u32 = 70019;
pub const APR_ANYADDR: &'static [u8; 8usize] = b"0.0.0.0\0";
pub const APR_APPEND: u32 = 8;
pub const APR_ASCII_BLANK: u8 = 32u8;
pub const APR_ASCII_CR: u8 = 13u8;
pub const APR_ASCII_LF: u8 = 10u8;
pub const APR_ASCII_TAB: u8 = 9u8;
pub const APR_BADARG: u32 = 70013;
pub const APR_BADCH: u32 = 70012;
pub const APR_BINARY: u32 = 32;
pub const APR_BUCKET_BUFF_SIZE: u32 = 8000;
pub const APR_BUFFERED: u32 = 128;
pub const APR_CHARSET_EBCDIC: u32 = 0;
pub const APR_CHILD_BLOCK: u32 = 4;
pub const APR_CHILD_DONE: u32 = 70005;
pub const APR_CHILD_NOTDONE: u32 = 70006;
pub const APR_CREATE: u32 = 4;
pub const APR_CTIME_LEN: u32 = 25;
pub const APR_CUR: u32 = 1;
pub const APR_DELONCLOSE: u32 = 256;
pub const APR_DETACH: u32 = 70003;
pub const APR_DSOPATH: &'static [u8; 16usize] = b"LD_LIBRARY_PATH\0";
pub const APR_EABOVEROOT: u32 = 20023;
pub const APR_EABSOLUTE: u32 = 20020;
pub const APR_EACCES: u32 = 13;
pub const APR_EAFNOSUPPORT: u32 = 97;
pub const APR_EAGAIN: u32 = 11;
pub const APR_EBADDATE: u32 = 20004;
pub const APR_EBADF: u32 = 9;
pub const APR_EBADIP: u32 = 20016;
pub const APR_EBADMASK: u32 = 20017;
pub const APR_EBADPATH: u32 = 20024;
pub const APR_EBUSY: u32 = 70025;
pub const APR_ECONNABORTED: u32 = 103;
pub const APR_ECONNREFUSED: u32 = 111;
pub const APR_ECONNRESET: u32 = 104;
pub const APR_EDSOOPEN: u32 = 20019;
pub const APR_EEXIST: u32 = 17;
pub const APR_EFTYPE: u32 = 620023;
pub const APR_EGENERAL: u32 = 20014;
pub const APR_EHOSTUNREACH: u32 = 113;
pub const APR_EINCOMPLETE: u32 = 20022;
pub const APR_EINIT: u32 = 70022;
pub const APR_EINPROGRESS: u32 = 115;
pub const APR_EINTR: u32 = 4;
pub const APR_EINVAL: u32 = 22;
pub const APR_EINVALSOCK: u32 = 20005;
pub const APR_EMFILE: u32 = 24;
pub const APR_EMISMATCH: u32 = 70024;
pub const APR_ENAMETOOLONG: u32 = 36;
pub const APR_END: u32 = 2;
pub const APR_ENETUNREACH: u32 = 101;
pub const APR_ENFILE: u32 = 23;
pub const APR_ENODIR: u32 = 20008;
pub const APR_ENOENT: u32 = 2;
pub const APR_ENOLOCK: u32 = 20009;
pub const APR_ENOMEM: u32 = 12;
pub const APR_ENOPOLL: u32 = 20010;
pub const APR_ENOPOOL: u32 = 20002;
pub const APR_ENOPROC: u32 = 20006;
pub const APR_ENOSHMAVAIL: u32 = 20015;
pub const APR_ENOSOCKET: u32 = 20011;
pub const APR_ENOSPC: u32 = 28;
pub const APR_ENOSTAT: u32 = 20001;
pub const APR_ENOTDIR: u32 = 20;
pub const APR_ENOTEMPTY: u32 = 39;
pub const APR_ENOTENOUGHENTROPY: u32 = 20028;
pub const APR_ENOTHDKEY: u32 = 20013;
pub const APR_ENOTHREAD: u32 = 20012;
pub const APR_ENOTIME: u32 = 20007;
pub const APR_ENOTIMPL: u32 = 70023;
pub const APR_ENOTSOCK: u32 = 88;
pub const APR_EOF: u32 = 70014;
pub const APR_EOL_STR: &'static [u8; 2usize] = b"\n\0";
pub const APR_EPATHWILD: u32 = 20025;
pub const APR_EPIPE: u32 = 32;
pub const APR_EPROC_UNKNOWN: u32 = 20027;
pub const APR_ERELATIVE: u32 = 20021;
pub const APR_ESPIPE: u32 = 29;
pub const APR_ESYMNOTFOUND: u32 = 20026;
pub const APR_ETIMEDOUT: u32 = 110;
pub const APR_EXCL: u32 = 64;
pub const APR_EXDEV: u32 = 18;
pub const APR_FILEBASED: u32 = 70020;
pub const APR_FILEPATH_ENCODING_LOCALE: u32 = 1;
pub const APR_FILEPATH_ENCODING_UNKNOWN: u32 = 0;
pub const APR_FILEPATH_ENCODING_UTF8: u32 = 2;
pub const APR_FILEPATH_NATIVE: u32 = 16;
pub const APR_FILEPATH_NOTABOVEROOT: u32 = 1;
pub const APR_FILEPATH_NOTABSOLUTE: u32 = 8;
pub const APR_FILEPATH_NOTRELATIVE: u32 = 4;
pub const APR_FILEPATH_SECUREROOT: u32 = 3;
pub const APR_FILEPATH_SECUREROOTTEST: u32 = 2;
pub const APR_FILEPATH_TRUENAME: u32 = 32;
pub const APR_FILES_AS_SOCKETS: u32 = 1;
pub const APR_FILE_ATTR_EXECUTABLE: u32 = 2;
pub const APR_FILE_ATTR_HIDDEN: u32 = 4;
pub const APR_FILE_ATTR_READONLY: u32 = 1;
pub const APR_FILE_NOCLEANUP: u32 = 2048;
pub const APR_FILE_SOURCE_PERMS: u32 = 4096;
pub const APR_FINFO_ATIME: u32 = 64;
pub const APR_FINFO_CSIZE: u32 = 512;
pub const APR_FINFO_CTIME: u32 = 32;
pub const APR_FINFO_DEV: u32 = 4096;
pub const APR_FINFO_DIRENT: u32 = 33554432;
pub const APR_FINFO_GPROT: u32 = 2097152;
pub const APR_FINFO_GROUP: u32 = 131072;
pub const APR_FINFO_ICASE: u32 = 16777216;
pub const APR_FINFO_IDENT: u32 = 12288;
pub const APR_FINFO_INODE: u32 = 8192;
pub const APR_FINFO_LINK: u32 = 1;
pub const APR_FINFO_MIN: u32 = 33136;
pub const APR_FINFO_MTIME: u32 = 16;
pub const APR_FINFO_NAME: u32 = 33554432;
pub const APR_FINFO_NLINK: u32 = 16384;
pub const APR_FINFO_NORM: u32 = 7582064;
pub const APR_FINFO_OWNER: u32 = 196608;
pub const APR_FINFO_PROT: u32 = 7340032;
pub const APR_FINFO_SIZE: u32 = 256;
pub const APR_FINFO_TYPE: u32 = 32768;
pub const APR_FINFO_UPROT: u32 = 1048576;
pub const APR_FINFO_USER: u32 = 65536;
pub const APR_FINFO_WPROT: u32 = 4194304;
pub const APR_FLOCK_EXCLUSIVE: u32 = 2;
pub const APR_FLOCK_NONBLOCK: u32 = 16;
pub const APR_FLOCK_SHARED: u32 = 1;
pub const APR_FLOCK_TYPEMASK: u32 = 15;
pub const APR_FOPEN_APPEND: u32 = 8;
pub const APR_FOPEN_BINARY: u32 = 32;
pub const APR_FOPEN_BUFFERED: u32 = 128;
pub const APR_FOPEN_CREATE: u32 = 4;
pub const APR_FOPEN_DELONCLOSE: u32 = 256;
pub const APR_FOPEN_EXCL: u32 = 64;
pub const APR_FOPEN_LARGEFILE: u32 = 16384;
pub const APR_FOPEN_NOCLEANUP: u32 = 2048;
pub const APR_FOPEN_NONBLOCK: u32 = 262144;
pub const APR_FOPEN_READ: u32 = 1;
pub const APR_FOPEN_SENDFILE_ENABLED: u32 = 4096;
pub const APR_FOPEN_SHARELOCK: u32 = 1024;
pub const APR_FOPEN_SPARSE: u32 = 32768;
pub const APR_FOPEN_TRUNCATE: u32 = 16;
pub const APR_FOPEN_WRITE: u32 = 2;
pub const APR_FOPEN_XTHREAD: u32 = 512;
pub const APR_FPROT_FILE_SOURCE_PERMS: u32 = 4096;
pub const APR_FPROT_GEXECUTE: u32 = 16;
pub const APR_FPROT_GREAD: u32 = 64;
pub const APR_FPROT_GSETID: u32 = 16384;
pub const APR_FPROT_GWRITE: u32 = 32;
pub const APR_FPROT_OS_DEFAULT: u32 = 4095;
pub const APR_FPROT_UEXECUTE: u32 = 256;
pub const APR_FPROT_UREAD: u32 = 1024;
pub const APR_FPROT_USETID: u32 = 32768;
pub const APR_FPROT_UWRITE: u32 = 512;
pub const APR_FPROT_WEXECUTE: u32 = 1;
pub const APR_FPROT_WREAD: u32 = 4;
pub const APR_FPROT_WSTICKY: u32 = 8192;
pub const APR_FPROT_WWRITE: u32 = 2;
pub const APR_FULL_BLOCK: u32 = 1;
pub const APR_FULL_NONBLOCK: u32 = 2;
pub const APR_GEXECUTE: u32 = 16;
pub const APR_GREAD: u32 = 64;
pub const APR_GSETID: u32 = 16384;
pub const APR_GWRITE: u32 = 32;
pub const APR_HOOK_FIRST: u32 = 0;
pub const APR_HOOK_LAST: u32 = 20;
pub const APR_HOOK_MIDDLE: u32 = 10;
pub const APR_HOOK_REALLY_FIRST: i32 = -10;
pub const APR_HOOK_REALLY_LAST: u32 = 30;
pub const APR_INCHILD: u32 = 70001;
pub const APR_INCOMPLETE: u32 = 70008;
pub const APR_INCOMPLETE_READ: u32 = 4096;
pub const APR_INCOMPLETE_WRITE: u32 = 8192;
pub const APR_INET6: u32 = 10;
pub const APR_INET: u32 = 2;
pub const APR_INPARENT: u32 = 70002;
pub const APR_INT16_MAX: u32 = 32767;
pub const APR_INT16_MIN: i32 = -32768;
pub const APR_INT32_MAX: u32 = 2147483647;
pub const APR_INT32_MIN: i32 = -2147483648;
pub const APR_INT64_T_FMT: &'static [u8; 3usize] = b"ld\0";
pub const APR_IPV4_ADDR_OK: u32 = 1;
pub const APR_IPV6_ADDR_OK: u32 = 2;
pub const APR_IPV6_V6ONLY: u32 = 16384;
pub const APR_IS_BIGENDIAN: u32 = 0;
pub const APR_KEYBASED: u32 = 70021;
pub const APR_LARGEFILE: u32 = 16384;
pub const APR_LIMIT_CPU: u32 = 0;
pub const APR_LIMIT_MEM: u32 = 1;
pub const APR_LIMIT_NOFILE: u32 = 3;
pub const APR_LIMIT_NPROC: u32 = 2;
pub const APR_MAX_IOVEC_SIZE: u32 = 1024;
pub const APR_MAX_SECS_TO_LINGER: u32 = 30;
pub const APR_MMAP_LIMIT: u32 = 4194304;
pub const APR_MMAP_READ: u32 = 1;
pub const APR_MMAP_THRESHOLD: u32 = 1;
pub const APR_MMAP_WRITE: u32 = 2;
pub const APR_NOTDETACH: u32 = 70004;
pub const APR_NOTFOUND: u32 = 70015;
pub const APR_NO_FILE: u32 = 8;
pub const APR_NO_PIPE: u32 = 0;
pub const APR_OC_REASON_DEATH: u32 = 0;
pub const APR_OC_REASON_LOST: u32 = 4;
pub const APR_OC_REASON_RESTART: u32 = 2;
pub const APR_OC_REASON_RUNNING: u32 = 5;
pub const APR_OC_REASON_UNREGISTER: u32 = 3;
pub const APR_OC_REASON_UNWRITABLE: u32 = 1;
pub const APR_OFF_T_FMT: &'static [u8; 3usize] = b"ld\0";
pub const APR_OS_DEFAULT: u32 = 4095;
pub const APR_OS_ERRSPACE_SIZE: u32 = 50000;
pub const APR_OS_START_CANONERR: u32 = 620000;
pub const APR_OS_START_EAIERR: u32 = 670000;
pub const APR_OS_START_ERROR: u32 = 20000;
pub const APR_OS_START_STATUS: u32 = 70000;
pub const APR_OS_START_SYSERR: u32 = 720000;
pub const APR_OS_START_USEERR: u32 = 120000;
pub const APR_OS_START_USERERR: u32 = 120000;
pub const APR_OVERLAP_TABLES_MERGE: u32 = 1;
pub const APR_OVERLAP_TABLES_SET: u32 = 0;
pub const APR_O_NONBLOCK_INHERITED: u32 = 0;
pub const APR_PARENT_BLOCK: u32 = 3;
pub const APR_PATH_MAX: u32 = 4096;
pub const APR_PID_T_FMT: &'static [u8; 2usize] = b"d\0";
pub const APR_POLLERR: u32 = 16;
pub const APR_POLLHUP: u32 = 32;
pub const APR_POLLIN: u32 = 1;
pub const APR_POLLNVAL: u32 = 64;
pub const APR_POLLOUT: u32 = 4;
pub const APR_POLLPRI: u32 = 2;
pub const APR_POLLSET_NOCOPY: u32 = 2;
pub const APR_POLLSET_NODEFAULT: u32 = 16;
pub const APR_POLLSET_THREADSAFE: u32 = 1;
pub const APR_POLLSET_WAKEABLE: u32 = 4;
pub const APR_POOL_DEBUG: u32 = 0;
pub const APR_PROCATTR_USER_SET_REQUIRES_PASSWORD: u32 = 0;
pub const APR_PROCESS_LOCK_IS_GLOBAL: u32 = 0;
pub const APR_PROC_DETACH_DAEMONIZE: u32 = 1;
pub const APR_PROC_DETACH_FOREGROUND: u32 = 0;
pub const APR_PROC_MUTEX_IS_GLOBAL: u32 = 0;
pub const APR_PROTO_SCTP: u32 = 132;
pub const APR_PROTO_TCP: u32 = 6;
pub const APR_PROTO_UDP: u32 = 17;
pub const APR_READ: u32 = 1;
pub const APR_READ_BLOCK: u32 = 3;
pub const APR_RESET_NODELAY: u32 = 2048;
pub const APR_RFC822_DATE_LEN: u32 = 30;
pub const APR_SENDFILE_DISCONNECT_SOCKET: u32 = 1;
pub const APR_SENDFILE_ENABLED: u32 = 4096;
pub const APR_SET: u32 = 0;
pub const APR_SHARELOCK: u32 = 1024;
pub const APR_SIZEOF_VOIDP: u32 = 8;
pub const APR_SIZE_T_FMT: &'static [u8; 3usize] = b"lu\0";
pub const APR_SO_BROADCAST: u32 = 65536;
pub const APR_SO_DEBUG: u32 = 4;
pub const APR_SO_DISCONNECTED: u32 = 256;
pub const APR_SO_KEEPALIVE: u32 = 2;
pub const APR_SO_LINGER: u32 = 1;
pub const APR_SO_NONBLOCK: u32 = 8;
pub const APR_SO_RCVBUF: u32 = 128;
pub const APR_SO_REUSEADDR: u32 = 16;
pub const APR_SO_SNDBUF: u32 = 64;
pub const APR_SSIZE_T_FMT: &'static [u8; 3usize] = b"ld\0";
pub const APR_SUCCESS: u32 = 0;
pub const APR_TCP_DEFER_ACCEPT: u32 = 32768;
pub const APR_TCP_NODELAY: u32 = 512;
pub const APR_TCP_NODELAY_INHERITED: u32 = 1;
pub const APR_TCP_NOPUSH: u32 = 1024;
pub const APR_THREAD_MUTEX_DEFAULT: u32 = 0;
pub const APR_THREAD_MUTEX_NESTED: u32 = 1;
pub const APR_THREAD_MUTEX_UNNESTED: u32 = 2;
pub const APR_TIMEUP: u32 = 70007;
pub const APR_TIME_T_FMT: &'static [u8; 3usize] = b"ld\0";
pub const APR_TRUNCATE: u32 = 16;
pub const APR_UEXECUTE: u32 = 256;
pub const APR_UINT16_MAX: u32 = 65535;
pub const APR_UINT32_MAX: u32 = 4294967295;
pub const APR_UINT64_T_FMT: &'static [u8; 3usize] = b"lu\0";
pub const APR_UINT64_T_HEX_FMT: &'static [u8; 3usize] = b"lx\0";
pub const APR_UNSPEC: u32 = 0;
pub const APR_UREAD: u32 = 1024;
pub const APR_URI_ACAP_DEFAULT_PORT: u32 = 674;
pub const APR_URI_FTP_DEFAULT_PORT: u32 = 21;
pub const APR_URI_GOPHER_DEFAULT_PORT: u32 = 70;
pub const APR_URI_HTTPS_DEFAULT_PORT: u32 = 443;
pub const APR_URI_HTTP_DEFAULT_PORT: u32 = 80;
pub const APR_URI_IMAP_DEFAULT_PORT: u32 = 143;
pub const APR_URI_LDAP_DEFAULT_PORT: u32 = 389;
pub const APR_URI_NFS_DEFAULT_PORT: u32 = 2049;
pub const APR_URI_NNTP_DEFAULT_PORT: u32 = 119;
pub const APR_URI_POP_DEFAULT_PORT: u32 = 110;
pub const APR_URI_PROSPERO_DEFAULT_PORT: u32 = 191;
pub const APR_URI_RTSP_DEFAULT_PORT: u32 = 554;
pub const APR_URI_SIP_DEFAULT_PORT: u32 = 5060;
pub const APR_URI_SNEWS_DEFAULT_PORT: u32 = 563;
pub const APR_URI_SSH_DEFAULT_PORT: u32 = 22;
pub const APR_URI_TELNET_DEFAULT_PORT: u32 = 23;
pub const APR_URI_TIP_DEFAULT_PORT: u32 = 3372;
pub const APR_URI_UNP_OMITPASSWORD: u32 = 4;
pub const APR_URI_UNP_OMITPATHINFO: u32 = 16;
pub const APR_URI_UNP_OMITQUERY: u32 = 32;
pub const APR_URI_UNP_OMITSITEPART: u32 = 1;
pub const APR_URI_UNP_OMITUSER: u32 = 2;
pub const APR_URI_UNP_OMITUSERINFO: u32 = 6;
pub const APR_URI_UNP_REVEALPASSWORD: u32 = 8;
pub const APR_URI_WAIS_DEFAULT_PORT: u32 = 210;
pub const APR_USETID: u32 = 32768;
pub const APR_USE_FCNTL_SERIALIZE: u32 = 0;
pub const APR_USE_FLOCK_SERIALIZE: u32 = 0;
pub const APR_USE_POSIXSEM_SERIALIZE: u32 = 0;
pub const APR_USE_PROC_PTHREAD_SERIALIZE: u32 = 0;
pub const APR_USE_PTHREAD_SERIALIZE: u32 = 1;
pub const APR_USE_SHMEM_BEOS: u32 = 0;
pub const APR_USE_SHMEM_MMAP_ANON: u32 = 1;
pub const APR_USE_SHMEM_MMAP_SHM: u32 = 0;
pub const APR_USE_SHMEM_MMAP_TMP: u32 = 0;
pub const APR_USE_SHMEM_MMAP_ZERO: u32 = 0;
pub const APR_USE_SHMEM_SHMGET: u32 = 1;
pub const APR_USE_SHMEM_SHMGET_ANON: u32 = 0;
pub const APR_USE_SYSVSEM_SERIALIZE: u32 = 1;
pub const APR_UTIL_ERRSPACE_SIZE: u32 = 20000;
pub const APR_UTIL_START_STATUS: u32 = 100000;
pub const APR_UWRITE: u32 = 512;
pub const APR_WEXECUTE: u32 = 1;
pub const APR_WREAD: u32 = 4;
pub const APR_WRITE: u32 = 2;
pub const APR_WRITE_BLOCK: u32 = 4;
pub const APR_WSTICKY: u32 = 8192;
pub const APR_WWRITE: u32 = 2;
pub const APR_XTHREAD: u32 = 512;
pub const AP_DECLINED: u32 = 122000;
pub const AP_DEFAULT_INDEX: &'static [u8; 11usize] = b"index.html\0";
pub const AP_ENABLE_V4_MAPPED: u32 = 1;
pub const AP_FILTER_ERROR: i32 = -102;
pub const AP_IOBUFSIZE: u32 = 8192;
pub const AP_MAX_REG_MATCH: u32 = 10;
pub const AP_MAX_SENDFILE: u32 = 16777216;
pub const AP_NEED_SET_MUTEX_PERMS: u32 = 1;
pub const AP_NOBODY_READ: i32 = -101;
pub const AP_NOBODY_WROTE: i32 = -100;
pub const AP_NONBLOCK_WHEN_MULTI_LISTEN: u32 = 1;
pub const AP_NORESTART: u32 = 120001;
pub const AP_REG_DOTALL: u32 = 64;
pub const AP_REG_EXTENDED: u32 = 0;
pub const AP_REG_ICASE: u32 = 1;
pub const AP_REG_MULTI: u32 = 16;
pub const AP_REG_NEWLINE: u32 = 2;
pub const AP_REG_NOMEM: u32 = 32;
pub const AP_REG_NOSUB: u32 = 0;
pub const AP_REG_NOTBOL: u32 = 4;
pub const AP_REG_NOTEOL: u32 = 8;
pub const AP_REQ_ACCEPT_PATH_INFO: u32 = 0;
pub const AP_REQ_DEFAULT_PATH_INFO: u32 = 2;
pub const AP_REQ_REJECT_PATH_INFO: u32 = 1;
pub const AP_SERVER_PROTOCOL: &'static [u8; 9usize] = b"HTTP/1.1\0";
pub const AP_START_USERERR: u32 = 122000;
pub const AP_TYPES_CONFIG_FILE: &'static [u8; 16usize] = b"conf/mime.types\0";
pub const AP_USERERR_LEN: u32 = 1000;
pub const AP_USING_AUTOCONF: u32 = 1;
pub const BUFSIZ: u32 = 8192;
pub const CGI_MAGIC_TYPE: &'static [u8; 24usize] = b"application/x-httpd-cgi\0";
pub const CR: u32 = 13;
pub const CRLF: &'static [u8; 3usize] = b"\r\n\0";
pub const CRLF_ASCII: &'static [u8; 3usize] = b"\r\n\0";
pub const DECLINED: i32 = -1;
pub const DECLINE_CMD: &'static [u8; 3usize] = b"\x07\x08\0";
pub const HOST_NAME_MAX: u32 = 64;
pub const HTTP_ACCEPTED: u32 = 202;
pub const HTTP_ALREADY_REPORTED: u32 = 208;
pub const HTTP_BAD_GATEWAY: u32 = 502;
pub const HTTP_BAD_REQUEST: u32 = 400;
pub const HTTP_CONFLICT: u32 = 409;
pub const HTTP_CONTINUE: u32 = 100;
pub const HTTP_CREATED: u32 = 201;
pub const HTTP_EXPECTATION_FAILED: u32 = 417;
pub const HTTP_FAILED_DEPENDENCY: u32 = 424;
pub const HTTP_FORBIDDEN: u32 = 403;
pub const HTTP_GATEWAY_TIME_OUT: u32 = 504;
pub const HTTP_GONE: u32 = 410;
pub const HTTP_IM_USED: u32 = 226;
pub const HTTP_INSUFFICIENT_STORAGE: u32 = 507;
pub const HTTP_INTERNAL_SERVER_ERROR: u32 = 500;
pub const HTTP_LENGTH_REQUIRED: u32 = 411;
pub const HTTP_LOCKED: u32 = 423;
pub const HTTP_LOOP_DETECTED: u32 = 508;
pub const HTTP_METHOD_NOT_ALLOWED: u32 = 405;
pub const HTTP_MOVED_PERMANENTLY: u32 = 301;
pub const HTTP_MOVED_TEMPORARILY: u32 = 302;
pub const HTTP_MULTIPLE_CHOICES: u32 = 300;
pub const HTTP_MULTI_STATUS: u32 = 207;
pub const HTTP_NETWORK_AUTHENTICATION_REQUIRED: u32 = 511;
pub const HTTP_NON_AUTHORITATIVE: u32 = 203;
pub const HTTP_NOT_ACCEPTABLE: u32 = 406;
pub const HTTP_NOT_EXTENDED: u32 = 510;
pub const HTTP_NOT_FOUND: u32 = 404;
pub const HTTP_NOT_IMPLEMENTED: u32 = 501;
pub const HTTP_NOT_MODIFIED: u32 = 304;
pub const HTTP_NO_CONTENT: u32 = 204;
pub const HTTP_OK: u32 = 200;
pub const HTTP_PARTIAL_CONTENT: u32 = 206;
pub const HTTP_PAYMENT_REQUIRED: u32 = 402;
pub const HTTP_PERMANENT_REDIRECT: u32 = 308;
pub const HTTP_PRECONDITION_FAILED: u32 = 412;
pub const HTTP_PRECONDITION_REQUIRED: u32 = 428;
pub const HTTP_PROCESSING: u32 = 102;
pub const HTTP_PROXY_AUTHENTICATION_REQUIRED: u32 = 407;
pub const HTTP_RANGE_NOT_SATISFIABLE: u32 = 416;
pub const HTTP_REQUEST_ENTITY_TOO_LARGE: u32 = 413;
pub const HTTP_REQUEST_HEADER_FIELDS_TOO_LARGE: u32 = 431;
pub const HTTP_REQUEST_TIME_OUT: u32 = 408;
pub const HTTP_REQUEST_URI_TOO_LARGE: u32 = 414;
pub const HTTP_RESET_CONTENT: u32 = 205;
pub const HTTP_SEE_OTHER: u32 = 303;
pub const HTTP_SERVICE_UNAVAILABLE: u32 = 503;
pub const HTTP_SWITCHING_PROTOCOLS: u32 = 101;
pub const HTTP_TEMPORARY_REDIRECT: u32 = 307;
pub const HTTP_TOO_MANY_REQUESTS: u32 = 429;
pub const HTTP_UNAUTHORIZED: u32 = 401;
pub const HTTP_UNPROCESSABLE_ENTITY: u32 = 422;
pub const HTTP_UNSUPPORTED_MEDIA_TYPE: u32 = 415;
pub const HTTP_UPGRADE_REQUIRED: u32 = 426;
pub const HTTP_USE_PROXY: u32 = 305;
pub const HTTP_VARIANT_ALSO_VARIES: u32 = 506;
pub const HTTP_VERSION_NOT_SUPPORTED: u32 = 505;
pub const HUGE_STRING_LEN: u32 = 8192;
pub const OK: u32 = 0;


pub type apr_byte_t = ::libc::c_uchar;
pub type apr_int16_t = ::libc::c_short;
pub type apr_uint16_t = ::libc::c_ushort;
pub type apr_int32_t = ::libc::c_int;
pub type apr_uint32_t = ::libc::c_uint;
pub type apr_int64_t = ::libc::c_long;
pub type apr_uint64_t = ::libc::c_ulong;
pub type apr_size_t = usize;
pub type apr_ssize_t = isize;
pub type apr_off_t = ::libc::off_t;
pub type apr_socklen_t = ::libc::socklen_t;
pub type apr_ino_t = ::libc::ino_t;
pub type apr_uintptr_t = apr_uint64_t;
/// Type for specifying an error or status code.
pub type apr_status_t = ::libc::c_int;
/// signal numbers typedef
pub type apr_signum_t = ::libc::c_int;


#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_pool_t { _unused: [u8; 0] }

/// A function that is called when allocation fails.
pub type apr_abortfunc_t = ::std::option::Option<unsafe extern "C" fn(retcode: ::libc::c_int) -> ::libc::c_int>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_allocator_t { _unused: [u8; 0] }

/// basic memory node structure
/// @note The next, ref and first_avail fields are available for use by the
/// caller of apr_allocator_alloc(), the remaining fields are read-only.
/// The next field has to be used with caution and sensibly set when the
/// memnode is passed back to apr_allocator_free().  See apr_allocator_free()
/// for details.
/// The ref and first_avail fields will be properly restored by
/// apr_allocator_free().
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_memnode_t {
    /// < next memnode
    pub next: *mut apr_memnode_t,
    /// < reference to self
    pub ref_: *mut *mut apr_memnode_t,
    /// < size
    pub index: apr_uint32_t,
    /// < how much free
    pub free_index: apr_uint32_t,
    /// < pointer to first free memory
    pub first_avail: *mut ::libc::c_char,
    /// < pointer to end of free memory
    pub endp: *mut ::libc::c_char,
}

#[test]
fn bindgen_test_layout_apr_memnode_t() {
    assert_eq!(::std::mem::size_of::<apr_memnode_t>(), 40usize, concat!( "Size of: " , stringify ! ( apr_memnode_t ) ));
    assert_eq!(::std::mem::align_of::<apr_memnode_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_memnode_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_memnode_t>())).next as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_memnode_t ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_memnode_t>())).ref_ as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_memnode_t ) , "::" , stringify ! ( ref_ ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_memnode_t>())).index as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_memnode_t ) , "::" , stringify ! ( index ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_memnode_t>())).free_index as *const _ as usize }, 20usize, concat!( "Offset of field: " , stringify ! ( apr_memnode_t ) , "::" , stringify ! ( free_index ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_memnode_t>())).first_avail as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_memnode_t ) , "::" , stringify ! ( first_avail ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_memnode_t>())).endp as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( apr_memnode_t ) , "::" , stringify ! ( endp ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_thread_mutex_t { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_table_t { _unused: [u8; 0] }

/// An opaque array type
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_array_header_t {
    /// The pool the array is allocated out of
    pub pool: *mut apr_pool_t,
    /// The amount of memory allocated for each element of the array
    pub elt_size: ::libc::c_int,
    /// The number of active elements in the array
    pub nelts: ::libc::c_int,
    /// The number of elements allocated in the array
    pub nalloc: ::libc::c_int,
    /// The elements in the array
    pub elts: *mut ::libc::c_char,
}

#[test]
fn bindgen_test_layout_apr_array_header_t() {
    assert_eq!(::std::mem::size_of::<apr_array_header_t>(), 32usize, concat!( "Size of: " , stringify ! ( apr_array_header_t ) ));
    assert_eq!(::std::mem::align_of::<apr_array_header_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_array_header_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_array_header_t>())).pool as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_array_header_t ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_array_header_t>())).elt_size as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_array_header_t ) , "::" , stringify ! ( elt_size ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_array_header_t>())).nelts as *const _ as usize }, 12usize, concat!( "Offset of field: " , stringify ! ( apr_array_header_t ) , "::" , stringify ! ( nelts ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_array_header_t>())).nalloc as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_array_header_t ) , "::" , stringify ! ( nalloc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_array_header_t>())).elts as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_array_header_t ) , "::" , stringify ! ( elts ) ));
}

/// The type for each entry in a string-content table
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_table_entry_t {
    /// The key for the current table entry
    pub key: *mut ::libc::c_char,
    /// The value for the current table entry
    pub val: *mut ::libc::c_char,
    /// A checksum for the key, for use by the apr_table internals
    pub key_checksum: apr_uint32_t,
}

#[test]
fn bindgen_test_layout_apr_table_entry_t() {
    assert_eq!(::std::mem::size_of::<apr_table_entry_t>(), 24usize, concat!( "Size of: " , stringify ! ( apr_table_entry_t ) ));
    assert_eq!(::std::mem::align_of::<apr_table_entry_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_table_entry_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_table_entry_t>())).key as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_table_entry_t ) , "::" , stringify ! ( key ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_table_entry_t>())).val as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_table_entry_t ) , "::" , stringify ! ( val ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_table_entry_t>())).key_checksum as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_table_entry_t ) , "::" , stringify ! ( key_checksum ) ));
}

/// Declaration prototype for the iterator callback function of apr_table_do()
/// and apr_table_vdo().
/// @param rec The data passed as the first argument to apr_table_[v]do()
/// @param key The key from this iteration of the table
/// @param value The value from this iteration of the table
/// @remark Iteration continues while this callback function returns non-zero.
/// To export the callback function for apr_table_[v]do() it must be declared
/// in the _NONSTD convention.
pub type apr_table_do_callback_fn_t = ::std::option::Option<unsafe extern "C" fn(rec: *mut ::libc::c_void, key: *const ::libc::c_char, value: *const ::libc::c_char) -> ::libc::c_int>;

extern "C" {
    #[link_name = "\u{1}apr_hook_global_pool"]
    pub static mut apr_hook_global_pool: *mut apr_pool_t;
}

extern "C" {
    #[link_name = "\u{1}apr_hook_debug_enabled"]
    pub static mut apr_hook_debug_enabled: ::libc::c_int;
}

extern "C" {
    #[link_name = "\u{1}apr_hook_debug_current"]
    pub static mut apr_hook_debug_current: *const ::libc::c_char;
}

extern "C" {
    #[link_name = "\u{1}apr_month_snames"]
    pub static mut apr_month_snames: [[::libc::c_char; 4usize]; 12usize];
}

extern "C" {
    #[link_name = "\u{1}apr_day_snames"]
    pub static mut apr_day_snames: [[::libc::c_char; 4usize]; 7usize];
}

/// number of microseconds since 00:00:00 january 1, 1970 UTC
pub type apr_time_t = apr_int64_t;
/// intervals for I/O timeouts, in microseconds
pub type apr_interval_time_t = apr_int64_t;
/// short interval for I/O timeouts, in microseconds
pub type apr_short_interval_time_t = apr_int32_t;

/// a structure similar to ANSI struct tm with the following differences:
/// - tm_usec isn't an ANSI field
/// - tm_gmtoff isn't an ANSI field (it's a bsdism)
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_time_exp_t {
    /// microseconds past tm_sec
    pub tm_usec: apr_int32_t,
    /// (0-61) seconds past tm_min
    pub tm_sec: apr_int32_t,
    /// (0-59) minutes past tm_hour
    pub tm_min: apr_int32_t,
    /// (0-23) hours past midnight
    pub tm_hour: apr_int32_t,
    /// (1-31) day of the month
    pub tm_mday: apr_int32_t,
    /// (0-11) month of the year
    pub tm_mon: apr_int32_t,
    /// year since 1900
    pub tm_year: apr_int32_t,
    /// (0-6) days since sunday
    pub tm_wday: apr_int32_t,
    /// (0-365) days since jan 1
    pub tm_yday: apr_int32_t,
    /// daylight saving time
    pub tm_isdst: apr_int32_t,
    /// seconds east of UTC
    pub tm_gmtoff: apr_int32_t,
}

#[test]
fn bindgen_test_layout_apr_time_exp_t() {
    assert_eq!(::std::mem::size_of::<apr_time_exp_t>(), 44usize, concat!( "Size of: " , stringify ! ( apr_time_exp_t ) ));
    assert_eq!(::std::mem::align_of::<apr_time_exp_t>(), 4usize, concat!( "Alignment of " , stringify ! ( apr_time_exp_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_usec as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_usec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_sec as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_sec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_min as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_min ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_hour as *const _ as usize }, 12usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_hour ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_mday as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_mday ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_mon as *const _ as usize }, 20usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_mon ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_year as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_year ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_wday as *const _ as usize }, 28usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_wday ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_yday as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_yday ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_isdst as *const _ as usize }, 36usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_isdst ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_gmtoff as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_gmtoff ) ));
}

pub type apr_uid_t = ::libc::uid_t;
pub type apr_gid_t = ::libc::gid_t;

/// < no file type determined
pub const apr_filetype_e_APR_NOFILE: apr_filetype_e = 0;
/// < a regular file
pub const apr_filetype_e_APR_REG: apr_filetype_e = 1;
/// < a directory
pub const apr_filetype_e_APR_DIR: apr_filetype_e = 2;
/// < a character device
pub const apr_filetype_e_APR_CHR: apr_filetype_e = 3;
/// < a block device
pub const apr_filetype_e_APR_BLK: apr_filetype_e = 4;
/// < a FIFO / pipe
pub const apr_filetype_e_APR_PIPE: apr_filetype_e = 5;
/// < a symbolic link
pub const apr_filetype_e_APR_LNK: apr_filetype_e = 6;
/// < a [unix domain] socket
pub const apr_filetype_e_APR_SOCK: apr_filetype_e = 7;
/// < a file of some other unknown type
pub const apr_filetype_e_APR_UNKFILE: apr_filetype_e = 127;

/// apr_filetype_e values for the filetype member of the
/// apr_file_info_t structure
/// @warning: Not all of the filetypes below can be determined.
/// For example, a given platform might not correctly report
/// a socket descriptor as APR_SOCK if that type isn't
/// well-identified on that platform.  In such cases where
/// a filetype exists but cannot be described by the recognized
/// flags below, the filetype will be APR_UNKFILE.  If the
/// filetype member is not determined, the type will be APR_NOFILE.
pub type apr_filetype_e = u32;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_dir_t { _unused: [u8; 0] }

/// Structure for determining file permissions.
pub type apr_fileperms_t = apr_int32_t;
/// Structure for determining the device the file is on.
pub type apr_dev_t = ::libc::dev_t;

/// The file information structure.  This is analogous to the POSIX
/// stat structure.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_finfo_t {
    /// Allocates memory and closes lingering handles in the specified pool
    pub pool: *mut apr_pool_t,
    /// The bitmask describing valid fields of this apr_finfo_t structure
    /// including all available 'wanted' fields and potentially more
    pub valid: apr_int32_t,
    /// The access permissions of the file.  Mimics Unix access rights.
    pub protection: apr_fileperms_t,
    /// The type of file.  One of APR_REG, APR_DIR, APR_CHR, APR_BLK, APR_PIPE,
    /// APR_LNK or APR_SOCK.  If the type is undetermined, the value is APR_NOFILE.
    /// If the type cannot be determined, the value is APR_UNKFILE.
    pub filetype: apr_filetype_e,
    /// The user id that owns the file
    pub user: apr_uid_t,
    /// The group id that owns the file
    pub group: apr_gid_t,
    /// The inode of the file.
    pub inode: apr_ino_t,
    /// The id of the device the file is on.
    pub device: apr_dev_t,
    /// The number of hard links to the file.
    pub nlink: apr_int32_t,
    /// The size of the file
    pub size: apr_off_t,
    /// The storage size consumed by the file
    pub csize: apr_off_t,
    /// The time the file was last accessed
    pub atime: apr_time_t,
    /// The time the file was last modified
    pub mtime: apr_time_t,
    /// The time the file was created, or the inode was last changed
    pub ctime: apr_time_t,
    /// The pathname of the file (possibly unrooted)
    pub fname: *const ::libc::c_char,
    /// The file's name (no path) in filesystem case
    pub name: *const ::libc::c_char,
    /// The file's handle, if accessed (can be submitted to apr_duphandle)
    pub filehand: *mut apr_file_t,
}

#[test]
fn bindgen_test_layout_apr_finfo_t() {
    assert_eq!(::std::mem::size_of::<apr_finfo_t>(), 120usize, concat!( "Size of: " , stringify ! ( apr_finfo_t ) ));
    assert_eq!(::std::mem::align_of::<apr_finfo_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_finfo_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).pool as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).valid as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( valid ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).protection as *const _ as usize }, 12usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( protection ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).filetype as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( filetype ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).user as *const _ as usize }, 20usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( user ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).group as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( group ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).inode as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( inode ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).device as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( device ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).nlink as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( nlink ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).size as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( size ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).csize as *const _ as usize }, 64usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( csize ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).atime as *const _ as usize }, 72usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( atime ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).mtime as *const _ as usize }, 80usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( mtime ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).ctime as *const _ as usize }, 88usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( ctime ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).fname as *const _ as usize }, 96usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( fname ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).name as *const _ as usize }, 104usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( name ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).filehand as *const _ as usize }, 112usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( filehand ) ));
}


/// File attributes
pub type apr_fileattrs_t = apr_uint32_t;
/// Type to pass as whence argument to apr_file_seek.
pub type apr_seek_where_t = ::libc::c_int;

/// < no longer allow read request
pub const apr_shutdown_how_e_APR_SHUTDOWN_READ: apr_shutdown_how_e = 0;
/// < no longer allow write requests
pub const apr_shutdown_how_e_APR_SHUTDOWN_WRITE: apr_shutdown_how_e = 1;
/// < no longer allow read or write requests
pub const apr_shutdown_how_e_APR_SHUTDOWN_READWRITE: apr_shutdown_how_e = 2;

/// Define what type of socket shutdown should occur.
pub type apr_shutdown_how_e = u32;

/// < Socket information for local end of connection
pub const apr_interface_e_APR_LOCAL: apr_interface_e = 0;
/// < Socket information for remote end of connection
pub const apr_interface_e_APR_REMOTE: apr_interface_e = 1;

/// Enum used to denote either the local and remote endpoint of a
/// connection.
pub type apr_interface_e = u32;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_socket_t { _unused: [u8; 0] }

/// A structure to represent in_addr
pub type apr_in_addr_t = ::libc::in_addr;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_ipsubnet_t { _unused: [u8; 0] }

/// @remark use apr_uint16_t just in case some system has a short that isn't 16 bits...
pub type apr_port_t = apr_uint16_t;

/// APRs socket address type, used to ensure protocol independence
#[repr(C)]
#[derive(Copy, Clone)]
pub struct apr_sockaddr_t {
    /// The pool to use...
    pub pool: *mut apr_pool_t,
    /// The hostname
    pub hostname: *mut ::libc::c_char,
    /// Either a string of the port number or the service name for the port
    pub servname: *mut ::libc::c_char,
    /// The numeric port
    pub port: apr_port_t,
    /// The family
    pub family: apr_int32_t,
    /// How big is the sockaddr we're using?
    pub salen: apr_socklen_t,
    /// How big is the ip address structure we're using?
    pub ipaddr_len: ::libc::c_int,
    /// How big should the address buffer be?  16 for v4 or 46 for v6
    /// used in inet_ntop...
    pub addr_str_len: ::libc::c_int,
    /// This points to the IP address structure within the appropriate
    /// sockaddr structure.
    pub ipaddr_ptr: *mut ::libc::c_void,
    /// If multiple addresses were found by apr_sockaddr_info_get(), this
    /// points to a representation of the next address.
    pub next: *mut apr_sockaddr_t,
    pub sa: apr_sockaddr_sa_t,
}

/// Union of either IPv4 or IPv6 sockaddr.
#[repr(C)]
#[derive(Copy, Clone)]
pub union apr_sockaddr_sa_t {
    /// IPv4 sockaddr structure
    pub sin: ::libc::sockaddr_in,
    /// IPv6 sockaddr structure
    pub sin6: ::libc::sockaddr_in6,
    /// Placeholder to ensure that the size of this union is not
    /// dependent on whether APR_HAVE_IPV6 is defined.
    pub sas: ::libc::sockaddr_storage,
    _bindgen_union_align: [u64; 16usize],
}

#[test]
fn bindgen_test_layout_apr_sockaddr_sa_t() {
    assert_eq!(::std::mem::size_of::<apr_sockaddr_sa_t>(), 128usize, concat!( "Size of: " , stringify ! ( apr_sockaddr_t__bindgen_ty_1 ) ));
    assert_eq!(::std::mem::align_of::<apr_sockaddr_sa_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_sockaddr_t__bindgen_ty_1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_sa_t>())).sin as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t__bindgen_ty_1 ) , "::" , stringify ! ( sin ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_sa_t>())).sin6 as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t__bindgen_ty_1 ) , "::" , stringify ! ( sin6 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_sa_t>())).sas as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t__bindgen_ty_1 ) , "::" , stringify ! ( sas ) ));
}

#[test]
fn bindgen_test_layout_apr_sockaddr_t() {
    assert_eq!(::std::mem::size_of::<apr_sockaddr_t>(), 192usize, concat!( "Size of: " , stringify ! ( apr_sockaddr_t ) ));
    assert_eq!(::std::mem::align_of::<apr_sockaddr_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_sockaddr_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).pool as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).hostname as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( hostname ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).servname as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( servname ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).port as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( port ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).family as *const _ as usize }, 28usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( family ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).salen as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( salen ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).ipaddr_len as *const _ as usize }, 36usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( ipaddr_len ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).addr_str_len as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( addr_str_len ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).ipaddr_ptr as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( ipaddr_ptr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).next as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).sa as *const _ as usize }, 64usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( sa ) ));
}

/// A structure to encapsulate headers and trailers for apr_socket_sendfile
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_hdtr_t {
    /// An iovec to store the headers sent before the file.
    pub headers: *mut ::libc::iovec,
    /// number of headers in the iovec
    pub numheaders: ::libc::c_int,
    /// An iovec to store the trailers sent after the file.
    pub trailers: *mut ::libc::iovec,
    /// number of trailers in the iovec
    pub numtrailers: ::libc::c_int,
}

#[test]
fn bindgen_test_layout_apr_hdtr_t() {
    assert_eq!(::std::mem::size_of::<apr_hdtr_t>(), 32usize, concat!( "Size of: " , stringify ! ( apr_hdtr_t ) ));
    assert_eq!(::std::mem::align_of::<apr_hdtr_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_hdtr_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_hdtr_t>())).headers as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_hdtr_t ) , "::" , stringify ! ( headers ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_hdtr_t>())).numheaders as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_hdtr_t ) , "::" , stringify ! ( numheaders ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_hdtr_t>())).trailers as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_hdtr_t ) , "::" , stringify ! ( trailers ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_hdtr_t>())).numtrailers as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_hdtr_t ) , "::" , stringify ! ( numtrailers ) ));
}

/// @remark
/// As far as I can tell the only really sane way to store an MMAP is as a
/// void * and a length.  BeOS requires this area_id, but that's just a little
/// something extra.  I am exposing this type, because it doesn't make much
/// sense to keep it private, and opening it up makes some stuff easier in
/// Apache.
/// /
/// /** The MMAP structure
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_mmap_t {
    /// The pool the mmap structure was allocated out of.
    pub cntxt: *mut apr_pool_t,
    /// The start of the memory mapped area
    pub mm: *mut ::libc::c_void,
    /// The amount of data in the mmap
    pub size: apr_size_t,
    /// ring of apr_mmap_t's that reference the same
    /// mmap'ed region; acts in place of a reference count
    pub link: apr_mmap_t__bindgen_ty_1,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_mmap_t__bindgen_ty_1 { pub next: *mut apr_mmap_t, pub prev: *mut apr_mmap_t }

#[test]
fn bindgen_test_layout_apr_mmap_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<apr_mmap_t__bindgen_ty_1>(), 16usize, concat!( "Size of: " , stringify ! ( apr_mmap_t__bindgen_ty_1 ) ));
    assert_eq!(::std::mem::align_of::<apr_mmap_t__bindgen_ty_1>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_mmap_t__bindgen_ty_1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_mmap_t__bindgen_ty_1>())).next as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_mmap_t__bindgen_ty_1 ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_mmap_t__bindgen_ty_1>())).prev as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_mmap_t__bindgen_ty_1 ) , "::" , stringify ! ( prev ) ));
}

#[test]
fn bindgen_test_layout_apr_mmap_t() {
    assert_eq!(::std::mem::size_of::<apr_mmap_t>(), 40usize, concat!( "Size of: " , stringify ! ( apr_mmap_t ) ));
    assert_eq!(::std::mem::align_of::<apr_mmap_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_mmap_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_mmap_t>())).cntxt as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_mmap_t ) , "::" , stringify ! ( cntxt ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_mmap_t>())).mm as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_mmap_t ) , "::" , stringify ! ( mm ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_mmap_t>())).size as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_mmap_t ) , "::" , stringify ! ( size ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_mmap_t>())).link as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_mmap_t ) , "::" , stringify ! ( link ) ));
}

/// < block until data becomes available
pub const apr_read_type_e_APR_BLOCK_READ: apr_read_type_e = 0;
/// < return immediately if no data is available
pub const apr_read_type_e_APR_NONBLOCK_READ: apr_read_type_e = 1;

/// Determines how a bucket or brigade should be read
pub type apr_read_type_e = u32;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_alloc_t { _unused: [u8; 0] }

/// Basic bucket type
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_type_t {
    /// The name of the bucket type
    pub name: *const ::libc::c_char,
    /// The number of functions this bucket understands.  Can not be less than
    /// five.
    pub num_func: ::libc::c_int,
    pub is_metadata: apr_bucket_type_t__bindgen_ty_1,
    /// Free the private data and any resources used by the bucket (if they
    /// aren't shared with another bucket).  This function is required to be
    /// implemented for all bucket types, though it might be a no-op on some
    /// of them (namely ones that never allocate any private data structures).
    /// @param data The private data pointer from the bucket to be destroyed
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::libc::c_void)>,
    /// Read the data from the bucket. This is required to be implemented
    /// for all bucket types.
    /// @param b The bucket to read from
    /// @param str A place to store the data read.  Allocation should only be
    /// done if absolutely necessary.
    /// @param len The amount of data read.
    /// @param block Should this read function block if there is more data that
    /// cannot be read immediately.
    pub read: ::std::option::Option<unsafe extern "C" fn(b: *mut apr_bucket, str: *mut *const ::libc::c_char, len: *mut apr_size_t, block: apr_read_type_e) -> apr_status_t>,
    /// Make it possible to set aside the data for at least as long as the
    /// given pool. Buckets containing data that could potentially die before
    /// this pool (e.g. the data resides on the stack, in a child pool of
    /// the given pool, or in a disjoint pool) must somehow copy, shift, or
    /// transform the data to have the proper lifetime.
    /// @param e The bucket to convert
    /// @remark Some bucket types contain data that will always outlive the
    /// bucket itself. For example no data (EOS and FLUSH), or the data
    /// resides in global, constant memory (IMMORTAL), or the data is on
    /// the heap (HEAP). For these buckets, apr_bucket_setaside_noop can
    /// be used.
    pub setaside: ::std::option::Option<unsafe extern "C" fn(e: *mut apr_bucket, pool: *mut apr_pool_t) -> apr_status_t>,
    /// Split one bucket in two at the specified position by duplicating
    /// the bucket structure (not the data) and modifying any necessary
    /// start/end/offset information.  If it's not possible to do this
    /// for the bucket type (perhaps the length of the data is indeterminate,
    /// as with pipe and socket buckets), then APR_ENOTIMPL is returned.
    /// @param e The bucket to split
    /// @param point The offset of the first byte in the new bucket
    pub split: ::std::option::Option<unsafe extern "C" fn(e: *mut apr_bucket, point: apr_size_t) -> apr_status_t>,
    /// Copy the bucket structure (not the data), assuming that this is
    /// possible for the bucket type. If it's not, APR_ENOTIMPL is returned.
    /// @param e The bucket to copy
    /// @param c Returns a pointer to the new bucket
    pub copy: ::std::option::Option<unsafe extern "C" fn(e: *mut apr_bucket, c: *mut *mut apr_bucket) -> apr_status_t>,
}

/// This bucket type represents actual data to send to the client.
pub const apr_bucket_type_t_APR_BUCKET_DATA: apr_bucket_type_t__bindgen_ty_1 = 0;
/// This bucket type represents metadata.
pub const apr_bucket_type_t_APR_BUCKET_METADATA: apr_bucket_type_t__bindgen_ty_1 = 1;

/// Whether the bucket contains metadata (ie, information that
/// describes the regular contents of the brigade).  The metadata
/// is not returned by apr_bucket_read() and is not indicated by
/// the ->length of the apr_bucket itself.  In other words, an
/// empty bucket is safe to arbitrarily remove if and only if it
/// contains no metadata.  In this sense, "data" is just raw bytes
/// that are the "content" of the brigade and "metadata" describes
/// that data but is not a proper part of it.
pub type apr_bucket_type_t__bindgen_ty_1 = u32;

#[test]
fn bindgen_test_layout_apr_bucket_type_t() {
    assert_eq!(::std::mem::size_of::<apr_bucket_type_t>(), 56usize, concat!( "Size of: " , stringify ! ( apr_bucket_type_t ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_type_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket_type_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_type_t>())).name as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_type_t ) , "::" , stringify ! ( name ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_type_t>())).num_func as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_type_t ) , "::" , stringify ! ( num_func ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_type_t>())).is_metadata as *const _ as usize }, 12usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_type_t ) , "::" , stringify ! ( is_metadata ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_type_t>())).destroy as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_type_t ) , "::" , stringify ! ( destroy ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_type_t>())).read as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_type_t ) , "::" , stringify ! ( read ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_type_t>())).setaside as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_type_t ) , "::" , stringify ! ( setaside ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_type_t>())).split as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_type_t ) , "::" , stringify ! ( split ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_type_t>())).copy as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_type_t ) , "::" , stringify ! ( copy ) ));
}

/// apr_bucket structures are allocated on the malloc() heap and
/// their lifetime is controlled by the parent apr_bucket_brigade
/// structure. Buckets can move from one brigade to another e.g. by
/// calling APR_BRIGADE_CONCAT(). In general the data in a bucket has
/// the same lifetime as the bucket and is freed when the bucket is
/// destroyed; if the data is shared by more than one bucket (e.g.
/// after a split) the data is freed when the last bucket goes away.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket {
    /// Links to the rest of the brigade
    pub link: apr_bucket__bindgen_ty_1,
    /// The type of bucket.
    pub type_: *const apr_bucket_type_t,
    /// The length of the data in the bucket.  This could have been implemented
    /// with a function, but this is an optimization, because the most
    /// common thing to do will be to get the length.  If the length is unknown,
    /// the value of this field will be (apr_size_t)(-1).
    pub length: apr_size_t,
    /// The start of the data in the bucket relative to the private base
    /// pointer.  The vast majority of bucket types allow a fixed block of
    /// data to be referenced by multiple buckets, each bucket pointing to
    /// a different segment of the data.  That segment starts at base+start
    /// and ends at base+start+length.
    /// If the length == (apr_size_t)(-1), then start == -1.
    pub start: apr_off_t,
    /// type-dependent data hangs off this pointer
    pub data: *mut ::libc::c_void,
    /// Pointer to function used to free the bucket. This function should
    /// always be defined and it should be consistent with the memory
    /// function used to allocate the bucket. For example, if malloc() is
    /// used to allocate the bucket, this pointer should point to free().
    /// @param e Pointer to the bucket being freed
    pub free: ::std::option::Option<unsafe extern "C" fn(e: *mut ::libc::c_void)>,
    /// The freelist from which this bucket was allocated
    pub list: *mut apr_bucket_alloc_t,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket__bindgen_ty_1 { pub next: *mut apr_bucket, pub prev: *mut apr_bucket }

#[test]
fn bindgen_test_layout_apr_bucket__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<apr_bucket__bindgen_ty_1>(), 16usize, concat!( "Size of: " , stringify ! ( apr_bucket__bindgen_ty_1 ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket__bindgen_ty_1>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket__bindgen_ty_1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket__bindgen_ty_1>())).next as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket__bindgen_ty_1 ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket__bindgen_ty_1>())).prev as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_bucket__bindgen_ty_1 ) , "::" , stringify ! ( prev ) ));
}

#[test]
fn bindgen_test_layout_apr_bucket() {
    assert_eq!(::std::mem::size_of::<apr_bucket>(), 64usize, concat!( "Size of: " , stringify ! ( apr_bucket ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket>())).link as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket ) , "::" , stringify ! ( link ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket>())).type_ as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_bucket ) , "::" , stringify ! ( type_ ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket>())).length as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_bucket ) , "::" , stringify ! ( length ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket>())).start as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( apr_bucket ) , "::" , stringify ! ( start ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket>())).data as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( apr_bucket ) , "::" , stringify ! ( data ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket>())).free as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( apr_bucket ) , "::" , stringify ! ( free ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket>())).list as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( apr_bucket ) , "::" , stringify ! ( list ) ));
}

/// A list of buckets
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_brigade {
    /// The pool to associate the brigade with.  The data is not allocated out
    /// of the pool, but a cleanup is registered with this pool.  If the
    /// brigade is destroyed by some mechanism other than pool destruction,
    /// the destroying function is responsible for killing the cleanup.
    pub p: *mut apr_pool_t,
    pub list: apr_bucket_brigade_apr_bucket_list,
    /// The freelist from which this bucket was allocated
    pub bucket_alloc: *mut apr_bucket_alloc_t,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_brigade_apr_bucket_list { pub next: *mut apr_bucket, pub prev: *mut apr_bucket }

#[test]
fn bindgen_test_layout_apr_bucket_brigade_apr_bucket_list() {
    assert_eq!(::std::mem::size_of::<apr_bucket_brigade_apr_bucket_list>(), 16usize, concat!( "Size of: " , stringify ! ( apr_bucket_brigade_apr_bucket_list ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_brigade_apr_bucket_list>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket_brigade_apr_bucket_list ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_brigade_apr_bucket_list>())).next as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_brigade_apr_bucket_list ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_brigade_apr_bucket_list>())).prev as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_brigade_apr_bucket_list ) , "::" , stringify ! ( prev ) ));
}

#[test]
fn bindgen_test_layout_apr_bucket_brigade() {
    assert_eq!(::std::mem::size_of::<apr_bucket_brigade>(), 32usize, concat!( "Size of: " , stringify ! ( apr_bucket_brigade ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_brigade>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket_brigade ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_brigade>())).p as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_brigade ) , "::" , stringify ! ( p ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_brigade>())).list as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_brigade ) , "::" , stringify ! ( list ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_brigade>())).bucket_alloc as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_brigade ) , "::" , stringify ! ( bucket_alloc ) ));
}

/// Function called when a brigade should be flushed
pub type apr_brigade_flush = ::std::option::Option<unsafe extern "C" fn(bb: *mut apr_bucket_brigade, ctx: *mut ::libc::c_void) -> apr_status_t>;

/// The structure used to manage the shared resource must start with an
/// apr_bucket_refcount which is updated by the general-purpose refcount
/// code. A pointer to the bucket-type-dependent private data structure
/// can be cast to a pointer to an apr_bucket_refcount and vice versa.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_refcount {
    /// The number of references to this bucket
    pub refcount: ::libc::c_int,
}

#[test]
fn bindgen_test_layout_apr_bucket_refcount() {
    assert_eq!(::std::mem::size_of::<apr_bucket_refcount>(), 4usize, concat!( "Size of: " , stringify ! ( apr_bucket_refcount ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_refcount>(), 4usize, concat!( "Alignment of " , stringify ! ( apr_bucket_refcount ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_refcount>())).refcount as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_refcount ) , "::" , stringify ! ( refcount ) ));
}

/// A bucket referring to data allocated off the heap.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_heap {
    /// Number of buckets using this memory
    pub refcount: apr_bucket_refcount,
    /// The start of the data actually allocated.  This should never be
    /// modified, it is only used to free the bucket.
    pub base: *mut ::libc::c_char,
    /// how much memory was allocated
    pub alloc_len: apr_size_t,
    /// function to use to delete the data
    pub free_func: ::std::option::Option<unsafe extern "C" fn(data: *mut ::libc::c_void)>,
}

#[test]
fn bindgen_test_layout_apr_bucket_heap() {
    assert_eq!(::std::mem::size_of::<apr_bucket_heap>(), 32usize, concat!( "Size of: " , stringify ! ( apr_bucket_heap ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_heap>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket_heap ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_heap>())).refcount as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_heap ) , "::" , stringify ! ( refcount ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_heap>())).base as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_heap ) , "::" , stringify ! ( base ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_heap>())).alloc_len as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_heap ) , "::" , stringify ! ( alloc_len ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_heap>())).free_func as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_heap ) , "::" , stringify ! ( free_func ) ));
}

/// A bucket referring to data allocated from a pool
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_pool {
    /// The pool bucket must be able to be easily morphed to a heap
    /// bucket if the pool gets cleaned up before all references are
    /// destroyed.  This apr_bucket_heap structure is populated automatically
    /// when the pool gets cleaned up, and subsequent calls to pool_read()
    /// will result in the apr_bucket in question being morphed into a
    /// regular heap bucket.  (To avoid having to do many extra refcount
    /// manipulations and b->data manipulations, the apr_bucket_pool
    /// struct actually *contains* the apr_bucket_heap struct that it
    /// will become as its first element; the two share their
    /// apr_bucket_refcount members.)
    pub heap: apr_bucket_heap,
    /// The block of data actually allocated from the pool.
    /// Segments of this block are referenced by adjusting
    /// the start and length of the apr_bucket accordingly.
    /// This will be NULL after the pool gets cleaned up.
    pub base: *const ::libc::c_char,
    /// The pool the data was allocated from.  When the pool
    /// is cleaned up, this gets set to NULL as an indicator
    /// to pool_read() that the data is now on the heap and
    /// so it should morph the bucket into a regular heap
    /// bucket before continuing.
    pub pool: *mut apr_pool_t,
    /// The freelist this structure was allocated from, which is
    /// needed in the cleanup phase in order to allocate space on the heap
    pub list: *mut apr_bucket_alloc_t,
}

#[test]
fn bindgen_test_layout_apr_bucket_pool() {
    assert_eq!(::std::mem::size_of::<apr_bucket_pool>(), 56usize, concat!( "Size of: " , stringify ! ( apr_bucket_pool ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_pool>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket_pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_pool>())).heap as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_pool ) , "::" , stringify ! ( heap ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_pool>())).base as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_pool ) , "::" , stringify ! ( base ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_pool>())).pool as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_pool ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_pool>())).list as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_pool ) , "::" , stringify ! ( list ) ));
}

/// A bucket referring to an mmap()ed file
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_mmap {
    /// Number of buckets using this memory
    pub refcount: apr_bucket_refcount,
    /// The mmap this sub_bucket refers to
    pub mmap: *mut apr_mmap_t,
}

#[test]
fn bindgen_test_layout_apr_bucket_mmap() {
    assert_eq!(::std::mem::size_of::<apr_bucket_mmap>(), 16usize, concat!( "Size of: " , stringify ! ( apr_bucket_mmap ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_mmap>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket_mmap ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_mmap>())).refcount as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_mmap ) , "::" , stringify ! ( refcount ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_mmap>())).mmap as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_mmap ) , "::" , stringify ! ( mmap ) ));
}

/// A bucket referring to an file
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_file {
    /// Number of buckets using this memory
    pub refcount: apr_bucket_refcount,
    /// The file this bucket refers to
    pub fd: *mut apr_file_t,
    /// The pool into which any needed structures should
    /// be created while reading from this file bucket
    pub readpool: *mut apr_pool_t,
    /// Whether this bucket should be memory-mapped if
    /// a caller tries to read from it
    pub can_mmap: ::libc::c_int,
}

#[test]
fn bindgen_test_layout_apr_bucket_file() {
    assert_eq!(::std::mem::size_of::<apr_bucket_file>(), 32usize, concat!( "Size of: " , stringify ! ( apr_bucket_file ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_file>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket_file ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_file>())).refcount as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_file ) , "::" , stringify ! ( refcount ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_file>())).fd as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_file ) , "::" , stringify ! ( fd ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_file>())).readpool as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_file ) , "::" , stringify ! ( readpool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_file>())).can_mmap as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_file ) , "::" , stringify ! ( can_mmap ) ));
}

/// A union of all bucket structures so we know what
/// the max size is.
#[repr(C)]
#[derive(Copy, Clone)]
pub union apr_bucket_structs {
    /// < Bucket
    pub b: apr_bucket,
    /// < Heap
    pub heap: apr_bucket_heap,
    /// < Pool
    pub pool: apr_bucket_pool,
    /// < MMap
    pub mmap: apr_bucket_mmap,
    /// < File
    pub file: apr_bucket_file,
    _bindgen_union_align: [u64; 8usize],
}

#[test]
fn bindgen_test_layout_apr_bucket_structs() {
    assert_eq!(::std::mem::size_of::<apr_bucket_structs>(), 64usize, concat!( "Size of: " , stringify ! ( apr_bucket_structs ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_structs>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket_structs ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_structs>())).b as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_structs ) , "::" , stringify ! ( b ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_structs>())).heap as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_structs ) , "::" , stringify ! ( heap ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_structs>())).pool as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_structs ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_structs>())).mmap as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_structs ) , "::" , stringify ! ( mmap ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_structs>())).file as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_structs ) , "::" , stringify ! ( file ) ));
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_flush"]
    pub static mut apr_bucket_type_flush: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_eos"]
    pub static mut apr_bucket_type_eos: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_file"]
    pub static mut apr_bucket_type_file: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_heap"]
    pub static mut apr_bucket_type_heap: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_mmap"]
    pub static mut apr_bucket_type_mmap: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_pool"]
    pub static mut apr_bucket_type_pool: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_pipe"]
    pub static mut apr_bucket_type_pipe: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_immortal"]
    pub static mut apr_bucket_type_immortal: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_transient"]
    pub static mut apr_bucket_type_transient: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_socket"]
    pub static mut apr_bucket_type_socket: apr_bucket_type_t;
}

/// < Platform default poll method
pub const apr_pollset_method_e_APR_POLLSET_DEFAULT: apr_pollset_method_e = 0;
/// < Poll uses select method
pub const apr_pollset_method_e_APR_POLLSET_SELECT: apr_pollset_method_e = 1;
/// < Poll uses kqueue method
pub const apr_pollset_method_e_APR_POLLSET_KQUEUE: apr_pollset_method_e = 2;
/// < Poll uses Solaris event port method
pub const apr_pollset_method_e_APR_POLLSET_PORT: apr_pollset_method_e = 3;
/// < Poll uses epoll method
pub const apr_pollset_method_e_APR_POLLSET_EPOLL: apr_pollset_method_e = 4;
/// < Poll uses poll method
pub const apr_pollset_method_e_APR_POLLSET_POLL: apr_pollset_method_e = 5;
/// < Poll uses z/OS asio method
pub const apr_pollset_method_e_APR_POLLSET_AIO_MSGQ: apr_pollset_method_e = 6;

/// Pollset Methods
pub type apr_pollset_method_e = u32;

/// < nothing here
pub const apr_datatype_e_APR_NO_DESC: apr_datatype_e = 0;
/// < descriptor refers to a socket
pub const apr_datatype_e_APR_POLL_SOCKET: apr_datatype_e = 1;
/// < descriptor refers to a file
pub const apr_datatype_e_APR_POLL_FILE: apr_datatype_e = 2;
/// < @deprecated descriptor is the last one in the list
pub const apr_datatype_e_APR_POLL_LASTDESC: apr_datatype_e = 3;

/// Used in apr_pollfd_t to determine what the apr_descriptor is
pub type apr_datatype_e = u32;

/// Union of either an APR file or socket.
#[repr(C)]
#[derive(Copy, Clone)]
pub union apr_descriptor {
    /// < file
    pub f: *mut apr_file_t,
    /// < socket
    pub s: *mut apr_socket_t,
    _bindgen_union_align: u64,
}

#[test]
fn bindgen_test_layout_apr_descriptor() {
    assert_eq!(::std::mem::size_of::<apr_descriptor>(), 8usize, concat!( "Size of: " , stringify ! ( apr_descriptor ) ));
    assert_eq!(::std::mem::align_of::<apr_descriptor>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_descriptor ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_descriptor>())).f as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_descriptor ) , "::" , stringify ! ( f ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_descriptor>())).s as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_descriptor ) , "::" , stringify ! ( s ) ));
}

/// Poll descriptor set.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct apr_pollfd_t {
    /// < associated pool
    pub p: *mut apr_pool_t,
    /// < descriptor type
    pub desc_type: apr_datatype_e,
    /// < requested events
    pub reqevents: apr_int16_t,
    /// < returned events
    pub rtnevents: apr_int16_t,
    /// < @see apr_descriptor
    pub desc: apr_descriptor,
    /// < allows app to associate context
    pub client_data: *mut ::libc::c_void,
}

#[test]
fn bindgen_test_layout_apr_pollfd_t() {
    assert_eq!(::std::mem::size_of::<apr_pollfd_t>(), 32usize, concat!( "Size of: " , stringify ! ( apr_pollfd_t ) ));
    assert_eq!(::std::mem::align_of::<apr_pollfd_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_pollfd_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_pollfd_t>())).p as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_pollfd_t ) , "::" , stringify ! ( p ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_pollfd_t>())).desc_type as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_pollfd_t ) , "::" , stringify ! ( desc_type ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_pollfd_t>())).reqevents as *const _ as usize }, 12usize, concat!( "Offset of field: " , stringify ! ( apr_pollfd_t ) , "::" , stringify ! ( reqevents ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_pollfd_t>())).rtnevents as *const _ as usize }, 14usize, concat!( "Offset of field: " , stringify ! ( apr_pollfd_t ) , "::" , stringify ! ( rtnevents ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_pollfd_t>())).desc as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_pollfd_t ) , "::" , stringify ! ( desc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_pollfd_t>())).client_data as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_pollfd_t ) , "::" , stringify ! ( client_data ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_pollset_t { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_pollcb_t { _unused: [u8; 0] }

/// Function prototype for pollcb handlers
/// @param baton Opaque baton passed into apr_pollcb_poll()
/// @param descriptor Contains the notification for an active descriptor,
/// the rtnevents member contains what events were triggered
/// for this descriptor.
pub type apr_pollcb_cb_t = ::std::option::Option<unsafe extern "C" fn(baton: *mut ::libc::c_void, descriptor: *mut apr_pollfd_t) -> apr_status_t>;

/// < use the shell to invoke the program
pub const apr_cmdtype_e_APR_SHELLCMD: apr_cmdtype_e = 0;
/// < invoke the program directly, no copied env
pub const apr_cmdtype_e_APR_PROGRAM: apr_cmdtype_e = 1;
/// < invoke the program, replicating our environment
pub const apr_cmdtype_e_APR_PROGRAM_ENV: apr_cmdtype_e = 2;
/// < find program on PATH, use our environment
pub const apr_cmdtype_e_APR_PROGRAM_PATH: apr_cmdtype_e = 3;
/// < use the shell to invoke the program,
/// replicating our environment
pub const apr_cmdtype_e_APR_SHELLCMD_ENV: apr_cmdtype_e = 4;

/// @defgroup apr_thread_proc Threads and Process Functions
/// @ingroup APR
/// @{
pub type apr_cmdtype_e = u32;

/// < wait for the specified process to finish
pub const apr_wait_how_e_APR_WAIT: apr_wait_how_e = 0;
/// < do not wait -- just see if it has finished
pub const apr_wait_how_e_APR_NOWAIT: apr_wait_how_e = 1;

pub type apr_wait_how_e = u32;

/// < process exited normally
pub const apr_exit_why_e_APR_PROC_EXIT: apr_exit_why_e = 1;
/// < process exited due to a signal
pub const apr_exit_why_e_APR_PROC_SIGNAL: apr_exit_why_e = 2;
/// < process exited and dumped a core file
pub const apr_exit_why_e_APR_PROC_SIGNAL_CORE: apr_exit_why_e = 4;

pub type apr_exit_why_e = u32;

/// The APR process type
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_proc_t {
    /// The process ID
    pub pid: ::libc::pid_t,
    /// Parent's side of pipe to child's stdin
    pub in_: *mut apr_file_t,
    /// Parent's side of pipe to child's stdout
    pub out: *mut apr_file_t,
    /// Parent's side of pipe to child's stdouterr
    pub err: *mut apr_file_t,
}

#[test]
fn bindgen_test_layout_apr_proc_t() {
    assert_eq!(::std::mem::size_of::<apr_proc_t>(), 32usize, concat!( "Size of: " , stringify ! ( apr_proc_t ) ));
    assert_eq!(::std::mem::align_of::<apr_proc_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_proc_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_proc_t>())).pid as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_proc_t ) , "::" , stringify ! ( pid ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_proc_t>())).in_ as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_proc_t ) , "::" , stringify ! ( in_ ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_proc_t>())).out as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_proc_t ) , "::" , stringify ! ( out ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_proc_t>())).err as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_proc_t ) , "::" , stringify ! ( err ) ));
}

/// The prototype for APR child errfn functions.  (See the description
/// of apr_procattr_child_errfn_set() for more information.)
/// It is passed the following parameters:
/// @param pool Pool associated with the apr_proc_t.  If your child
/// error function needs user data, associate it with this
/// pool.
/// @param err APR error code describing the error
/// @param description Text description of type of processing which failed
pub type apr_child_errfn_t = ::std::option::Option<unsafe extern "C" fn(proc_: *mut apr_pool_t, err: apr_status_t, description: *const ::libc::c_char)>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_thread_t { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_threadattr_t { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_procattr_t { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_thread_once_t { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_threadkey_t { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_other_child_rec_t { _unused: [u8; 0] }

/// The prototype for any APR thread worker functions.
pub type apr_thread_start_t = ::std::option::Option<unsafe extern "C" fn(arg1: *mut apr_thread_t, arg2: *mut ::libc::c_void) -> *mut ::libc::c_void>;

/// < process is never killed (i.e., never sent
/// any signals), but it will be reaped if it exits
/// before the pool is cleaned up
pub const apr_kill_conditions_e_APR_KILL_NEVER: apr_kill_conditions_e = 0;
/// < process is sent SIGKILL on apr_pool_t cleanup
pub const apr_kill_conditions_e_APR_KILL_ALWAYS: apr_kill_conditions_e = 1;
/// < SIGTERM, wait 3 seconds, SIGKILL
pub const apr_kill_conditions_e_APR_KILL_AFTER_TIMEOUT: apr_kill_conditions_e = 2;
/// < wait forever for the process to complete
pub const apr_kill_conditions_e_APR_JUST_WAIT: apr_kill_conditions_e = 3;
/// < send SIGTERM and then wait
pub const apr_kill_conditions_e_APR_KILL_ONLY_ONCE: apr_kill_conditions_e = 4;

pub type apr_kill_conditions_e = u32;

pub const AP_REG_ASSERT: u32 = 1;
/// internal error ?
pub const AP_REG_ESPACE: u32 = 2;
/// failed to get memory
pub const AP_REG_INVARG: u32 = 3;
/// invalid argument
pub const AP_REG_NOMATCH: u32 = 4;


#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_regex_t { pub re_pcre: *mut ::libc::c_void, pub re_nsub: ::libc::c_int, pub re_erroffset: apr_size_t }

#[test]
fn bindgen_test_layout_ap_regex_t() {
    assert_eq!(::std::mem::size_of::<ap_regex_t>(), 24usize, concat!( "Size of: " , stringify ! ( ap_regex_t ) ));
    assert_eq!(::std::mem::align_of::<ap_regex_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_regex_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_regex_t>())).re_pcre as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_regex_t ) , "::" , stringify ! ( re_pcre ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_regex_t>())).re_nsub as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_regex_t ) , "::" , stringify ! ( re_nsub ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_regex_t>())).re_erroffset as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_regex_t ) , "::" , stringify ! ( re_erroffset ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_regmatch_t { pub rm_so: ::libc::c_int, pub rm_eo: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_regmatch_t() {
    assert_eq!(::std::mem::size_of::<ap_regmatch_t>(), 8usize, concat!( "Size of: " , stringify ! ( ap_regmatch_t ) ));
    assert_eq!(::std::mem::align_of::<ap_regmatch_t>(), 4usize, concat!( "Alignment of " , stringify ! ( ap_regmatch_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_regmatch_t>())).rm_so as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_regmatch_t ) , "::" , stringify ! ( rm_so ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_regmatch_t>())).rm_eo as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( ap_regmatch_t ) , "::" , stringify ! ( rm_eo ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_rxplus_t { pub rx: ap_regex_t, pub flags: apr_uint32_t, pub subs: *const ::libc::c_char, pub match_: *const ::libc::c_char, pub nmatch: apr_size_t, pub pmatch: *mut ap_regmatch_t }

#[test]
fn bindgen_test_layout_ap_rxplus_t() {
    assert_eq!(::std::mem::size_of::<ap_rxplus_t>(), 64usize, concat!( "Size of: " , stringify ! ( ap_rxplus_t ) ));
    assert_eq!(::std::mem::align_of::<ap_rxplus_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_rxplus_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_rxplus_t>())).rx as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_rxplus_t ) , "::" , stringify ! ( rx ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_rxplus_t>())).flags as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_rxplus_t ) , "::" , stringify ! ( flags ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_rxplus_t>())).subs as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_rxplus_t ) , "::" , stringify ! ( subs ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_rxplus_t>())).match_ as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( ap_rxplus_t ) , "::" , stringify ! ( match_ ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_rxplus_t>())).nmatch as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( ap_rxplus_t ) , "::" , stringify ! ( nmatch ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_rxplus_t>())).pmatch as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( ap_rxplus_t ) , "::" , stringify ! ( pmatch ) ));
}

/// @brief The numeric version information is broken out into fields within this
/// structure.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_version_t {
    /// < major number
    pub major: ::libc::c_int,
    /// < minor number
    pub minor: ::libc::c_int,
    /// < patch number
    pub patch: ::libc::c_int,
    /// < additional string like "-dev"
    pub add_string: *const ::libc::c_char,
}

#[test]
fn bindgen_test_layout_ap_version_t() {
    assert_eq!(::std::mem::size_of::<ap_version_t>(), 24usize, concat!( "Size of: " , stringify ! ( ap_version_t ) ));
    assert_eq!(::std::mem::align_of::<ap_version_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_version_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_version_t>())).major as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_version_t ) , "::" , stringify ! ( major ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_version_t>())).minor as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( ap_version_t ) , "::" , stringify ! ( minor ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_version_t>())).patch as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_version_t ) , "::" , stringify ! ( patch ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_version_t>())).add_string as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_version_t ) , "::" , stringify ! ( add_string ) ));
}

/// @struct ap_method_list_t
/// @brief  Structure for handling HTTP methods.
///
/// Methods known to the server are accessed via a bitmask shortcut;
/// extension methods are handled by an array.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_method_list_t {
    /// The bitmask used for known methods
    pub method_mask: apr_int64_t,
    /// the array used for extension methods
    pub method_list: *mut apr_array_header_t,
}

#[test]
fn bindgen_test_layout_ap_method_list_t() {
    assert_eq!(::std::mem::size_of::<ap_method_list_t>(), 16usize, concat!( "Size of: " , stringify ! ( ap_method_list_t ) ));
    assert_eq!(::std::mem::align_of::<ap_method_list_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_method_list_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_method_list_t>())).method_mask as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_method_list_t ) , "::" , stringify ! ( method_mask ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_method_list_t>())).method_list as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_method_list_t ) , "::" , stringify ! ( method_list ) ));
}

/// @brief This represents the result of calling htaccess; these are cached for
/// each request.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct htaccess_result {
    /// the directory to which this applies
    pub dir: *const ::libc::c_char,
    /// the overrides allowed for the .htaccess file
    pub override_: ::libc::c_int,
    /// the override options allowed for the .htaccess file
    pub override_opts: ::libc::c_int,
    /// Table of allowed directives for override
    pub override_list: *mut apr_table_t,
    /// the configuration directives
    pub htaccess: *mut ap_conf_vector_t,
    /// the next one, or NULL if no more; N.B. never change this
    pub next: *const htaccess_result,
}

#[test]
fn bindgen_test_layout_htaccess_result() {
    assert_eq!(::std::mem::size_of::<htaccess_result>(), 40usize, concat!( "Size of: " , stringify ! ( htaccess_result ) ));
    assert_eq!(::std::mem::align_of::<htaccess_result>(), 8usize, concat!( "Alignment of " , stringify ! ( htaccess_result ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<htaccess_result>())).dir as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( htaccess_result ) , "::" , stringify ! ( dir ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<htaccess_result>())).override_ as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( htaccess_result ) , "::" , stringify ! ( override_ ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<htaccess_result>())).override_opts as *const _ as usize }, 12usize, concat!( "Offset of field: " , stringify ! ( htaccess_result ) , "::" , stringify ! ( override_opts ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<htaccess_result>())).override_list as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( htaccess_result ) , "::" , stringify ! ( override_list ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<htaccess_result>())).htaccess as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( htaccess_result ) , "::" , stringify ! ( htaccess ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<htaccess_result>())).next as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( htaccess_result ) , "::" , stringify ! ( next ) ));
}

/// A structure to encompass all of the fields in a uri
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_uri_t {
    /// scheme ("http"/"ftp"/...)
    pub scheme: *mut ::libc::c_char,
    /// combined [user[:password]\@]host[:port]
    pub hostinfo: *mut ::libc::c_char,
    /// user name, as in http://user:passwd\@host:port/
    pub user: *mut ::libc::c_char,
    /// password, as in http://user:passwd\@host:port/
    pub password: *mut ::libc::c_char,
    /// hostname from URI (or from Host: header)
    pub hostname: *mut ::libc::c_char,
    /// port string (integer representation is in "port")
    pub port_str: *mut ::libc::c_char,
    /// the request path (or NULL if only scheme://host was given)
    pub path: *mut ::libc::c_char,
    /// Everything after a '?' in the path, if present
    pub query: *mut ::libc::c_char,
    /// Trailing "#fragment" string, if present
    pub fragment: *mut ::libc::c_char,
    /// structure returned from gethostbyname()
    pub hostent: *mut hostent,
    /// The port number, numeric, valid only if port_str != NULL
    pub port: apr_port_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 5usize],
}

#[test]
fn bindgen_test_layout_apr_uri_t() {
    assert_eq!(::std::mem::size_of::<apr_uri_t>(), 88usize, concat!( "Size of: " , stringify ! ( apr_uri_t ) ));
    assert_eq!(::std::mem::align_of::<apr_uri_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_uri_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).scheme as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( scheme ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).hostinfo as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( hostinfo ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).user as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( user ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).password as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( password ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).hostname as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( hostname ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).port_str as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( port_str ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).path as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( path ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).query as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( query ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).fragment as *const _ as usize }, 64usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( fragment ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).hostent as *const _ as usize }, 72usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( hostent ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).port as *const _ as usize }, 80usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( port ) ));
}

impl apr_uri_t {
    #[inline]
    pub fn is_initialized(&self) -> ::libc::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) } }
    #[inline]
    pub fn set_is_initialized(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dns_looked_up(&self) -> ::libc::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) } }
    #[inline]
    pub fn set_dns_looked_up(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dns_resolved(&self) -> ::libc::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) } }
    #[inline]
    pub fn set_dns_resolved(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(is_initialized: ::libc::c_uint, dns_looked_up: ::libc::c_uint, dns_resolved: ::libc::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_initialized: u32 = unsafe { ::std::mem::transmute(is_initialized) };
            is_initialized as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dns_looked_up: u32 = unsafe { ::std::mem::transmute(dns_looked_up) };
            dns_looked_up as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dns_resolved: u32 = unsafe { ::std::mem::transmute(dns_resolved) };
            dns_resolved as u64
        });
        __bindgen_bitfield_unit
    }
}

/// @brief A structure that represents one process
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct process_rec {
    /// Global pool. Cleared upon normal exit
    pub pool: *mut apr_pool_t,
    /// Configuration pool. Cleared upon restart
    pub pconf: *mut apr_pool_t,
    /// The program name used to execute the program
    pub short_name: *const ::libc::c_char,
    /// The command line arguments
    pub argv: *const *const ::libc::c_char,
    /// Number of command line arguments passed to the program
    pub argc: ::libc::c_int,
}

#[test]
fn bindgen_test_layout_process_rec() {
    assert_eq!(::std::mem::size_of::<process_rec>(), 40usize, concat!( "Size of: " , stringify ! ( process_rec ) ));
    assert_eq!(::std::mem::align_of::<process_rec>(), 8usize, concat!( "Alignment of " , stringify ! ( process_rec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<process_rec>())).pool as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( process_rec ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<process_rec>())).pconf as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( process_rec ) , "::" , stringify ! ( pconf ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<process_rec>())).short_name as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( process_rec ) , "::" , stringify ! ( short_name ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<process_rec>())).argv as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( process_rec ) , "::" , stringify ! ( argv ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<process_rec>())).argc as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( process_rec ) , "::" , stringify ! ( argc ) ));
}

/// @brief A structure that represents the current request
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct request_rec {
    /// The pool associated with the request
    pub pool: *mut ffi::apr_pool_t,
    /// The connection to the client
    pub connection: *mut ffi::conn_rec,
    /// The virtual host for this request
    pub server: *mut ffi::server_rec,
    /// Pointer to the redirected request if this is an external redirect
    pub next: *mut ffi::request_rec,
    /// Pointer to the previous request if this is an internal redirect
    pub prev: *mut ffi::request_rec,
    /// Pointer to the main request if this is a sub-request
    /// (see http_request.h)
    pub main: *mut request_rec,
    /// First line of request
    pub the_request: *mut ::libc::c_char,
    /// HTTP/0.9, "simple" request (e.g. GET /foo\n w/no headers)
    pub assbackwards: ::libc::c_int,
    /// A proxy request (calculated during post_read_request/translate_name)
    /// possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,
    /// PROXYREQ_RESPONSE
    pub proxyreq: ::libc::c_int,
    /// HEAD request, as opposed to GET
    pub header_only: ::libc::c_int,
    /// Protocol version number of protocol; 1.1 = 1001
    pub proto_num: ::libc::c_int,
    /// Protocol string, as given to us, or HTTP/0.9
    pub protocol: *mut ::libc::c_char,
    /// Host, as set by full URI or Host:
    pub hostname: *const ::libc::c_char,
    /// Time when the request started
    pub request_time: apr_time_t,
    /// Status line, if set by script
    pub status_line: *const ::libc::c_char,
    /// Status line
    pub status: ::libc::c_int,
    /// M_GET, M_POST, etc.
    pub method_number: ::libc::c_int,
    /// Request method (eg. GET, HEAD, POST, etc.)
    pub method: *const ::libc::c_char,
    /// 'allowed' is a bitvector of the allowed methods.
    ///
    /// A handler must ensure that the request method is one that
    /// it is capable of handling.  Generally modules should DECLINE
    /// any request methods they do not handle.  Prior to aborting the
    /// handler like this the handler should set r->allowed to the list
    /// of methods that it is willing to handle.  This bitvector is used
    /// to construct the "Allow:" header required for OPTIONS requests,
    /// and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.
    ///
    /// Since the default_handler deals with OPTIONS, all modules can
    /// usually decline to deal with OPTIONS.  TRACE is always allowed,
    /// modules don't need to set it explicitly.
    ///
    /// Since the default_handler will always handle a GET, a
    /// module which does *not* implement GET should probably return
    /// HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET
    /// handler can't be installed by mod_actions.
    pub allowed: apr_int64_t,
    /// Array of extension methods
    pub allowed_xmethods: *mut ffi::apr_array_header_t,
    /// List of allowed methods
    pub allowed_methods: *mut ap_method_list_t,
    /// byte count in stream is for body
    pub sent_bodyct: apr_off_t,
    /// body byte count, for easy access
    pub bytes_sent: apr_off_t,
    /// Last modified time of the requested resource
    pub mtime: apr_time_t,
    /// The Range: header
    pub range: *const ::libc::c_char,
    /// The "real" content length
    pub clength: apr_off_t,
    /// sending chunked transfer-coding
    pub chunked: ::libc::c_int,
    /// Method for reading the request body
    /// (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,
    /// REQUEST_CHUNKED_DECHUNK, etc...)
    pub read_body: ::libc::c_int,
    /// reading chunked transfer-coding
    pub read_chunked: ::libc::c_int,
    /// is client waiting for a 100 response?
    pub expecting_100: ::libc::c_uint,
    /// The optional kept body of the request.
    pub kept_body: *mut ffi::apr_bucket_brigade,
    /// For ap_body_to_table(): parsed body
    pub body_table: *mut ffi::apr_table_t,
    /// Remaining bytes left to read from the request body
    pub remaining: apr_off_t,
    /// Number of bytes that have been read  from the request body
    pub read_length: apr_off_t,
    /// MIME header environment from the request
    pub headers_in: *mut ffi::apr_table_t,
    /// MIME header environment for the response
    pub headers_out: *mut ffi::apr_table_t,
    /// MIME header environment for the response, printed even on errors and
    /// persist across internal redirects
    pub err_headers_out: *mut ffi::apr_table_t,
    /// Array of environment variables to be used for sub processes
    pub subprocess_env: *mut ffi::apr_table_t,
    /// Notes from one module to another
    pub notes: *mut ffi::apr_table_t,
    /// The content-type for the current request
    pub content_type: *const ::libc::c_char,
    /// The handler string that we use to call a handler function
    pub handler: *const ::libc::c_char,
    /// How to encode the data
    pub content_encoding: *const ::libc::c_char,
    /// Array of strings representing the content languages
    pub content_languages: *mut ffi::apr_array_header_t,
    /// variant list validator (if negotiated)
    pub vlist_validator: *mut ::libc::c_char,
    /// If an authentication check was made, this gets set to the user name.
    pub user: *mut ::libc::c_char,
    /// If an authentication check was made, this gets set to the auth type.
    pub ap_auth_type: *mut ::libc::c_char,
    /// The URI without any parsing performed
    pub unparsed_uri: *mut ::libc::c_char,
    /// The path portion of the URI, or "/" if no path provided
    pub uri: *mut ::libc::c_char,
    /// The filename on disk corresponding to this response
    pub filename: *mut ::libc::c_char,
    /// The true filename, we canonicalize r->filename if these don't match
    pub canonical_filename: *mut ::libc::c_char,
    /// The PATH_INFO extracted from this request
    pub path_info: *mut ::libc::c_char,
    /// The QUERY_ARGS extracted from this request
    pub args: *mut ::libc::c_char,
    /// Flag for the handler to accept or reject path_info on
    /// the current request.  All modules should respect the
    /// AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO
    /// values, while AP_REQ_DEFAULT_PATH_INFO indicates they
    /// may follow existing conventions.  This is set to the
    /// user's preference upon HOOK_VERY_FIRST of the fixups.
    pub used_path_info: ::libc::c_int,
    /// A flag to determine if the eos bucket has been sent yet
    pub eos_sent: ::libc::c_int,
    /// Options set in config files, etc.
    pub per_dir_config: *mut ffi::ap_conf_vector_t,
    /// Notes on *this* request
    pub request_config: *mut ffi::ap_conf_vector_t,
    /// Optional request log level configuration. Will usually point
    /// to a server or per_dir config, i.e. must be copied before
    /// modifying
    pub log: *const ap_logconf,
    /// Id to identify request in access and error log. Set when the first
    /// error log entry for this request is generated.
    pub log_id: *const ::libc::c_char,
    /// A linked list of the .htaccess configuration directives
    /// accessed by this request.
    /// N.B. always add to the head of the list, _never_ to the end.
    /// that way, a sub request's list can (temporarily) point to a parent's list
    pub htaccess: *const htaccess_result,
    /// A list of output filters to be used for this request
    pub output_filters: *mut ap_filter_t,
    /// A list of input filters to be used for this request
    pub input_filters: *mut ffi::ap_filter_t,
    /// A list of protocol level output filters to be used for this
    /// request
    pub proto_output_filters: *mut ffi::ap_filter_t,
    /// A list of protocol level input filters to be used for this
    /// request
    pub proto_input_filters: *mut ffi::ap_filter_t,
    /// This response can not be cached
    pub no_cache: ::libc::c_int,
    /// There is no local copy of this response
    pub no_local_copy: ::libc::c_int,
    /// Mutex protect callbacks registered with ap_mpm_register_timed_callback
    /// from being run before the original handler finishes running
    pub invoke_mtx: *mut apr_thread_mutex_t,
    /// A struct containing the components of URI
    pub parsed_uri: apr_uri_t,
    /// finfo.protection (st_mode) set to zero if no such file
    pub finfo: apr_finfo_t,
    /// remote address information from conn_rec, can be overridden if
    /// necessary by a module.
    /// This is the address that originated the request.
    pub useragent_addr: *mut ffi::apr_sockaddr_t,
    pub useragent_ip: *mut ::libc::c_char,
}

#[test]
fn bindgen_test_layout_request_rec() {
    assert_eq!(::std::mem::size_of::<request_rec>(), 696usize, concat!( "Size of: " , stringify ! ( request_rec ) ));
    assert_eq!(::std::mem::align_of::<request_rec>(), 8usize, concat!( "Alignment of " , stringify ! ( request_rec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).pool as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).connection as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( connection ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).server as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( server ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).next as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).prev as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( prev ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).main as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( main ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).the_request as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( the_request ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).assbackwards as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( assbackwards ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).proxyreq as *const _ as usize }, 60usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( proxyreq ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).header_only as *const _ as usize }, 64usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( header_only ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).proto_num as *const _ as usize }, 68usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( proto_num ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).protocol as *const _ as usize }, 72usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( protocol ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).hostname as *const _ as usize }, 80usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( hostname ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).request_time as *const _ as usize }, 88usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( request_time ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).status_line as *const _ as usize }, 96usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( status_line ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).status as *const _ as usize }, 104usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( status ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).method_number as *const _ as usize }, 108usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( method_number ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).method as *const _ as usize }, 112usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( method ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).allowed as *const _ as usize }, 120usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( allowed ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).allowed_xmethods as *const _ as usize }, 128usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( allowed_xmethods ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).allowed_methods as *const _ as usize }, 136usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( allowed_methods ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).sent_bodyct as *const _ as usize }, 144usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( sent_bodyct ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).bytes_sent as *const _ as usize }, 152usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( bytes_sent ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).mtime as *const _ as usize }, 160usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( mtime ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).range as *const _ as usize }, 168usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( range ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).clength as *const _ as usize }, 176usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( clength ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).chunked as *const _ as usize }, 184usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( chunked ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).read_body as *const _ as usize }, 188usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( read_body ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).read_chunked as *const _ as usize }, 192usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( read_chunked ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).expecting_100 as *const _ as usize }, 196usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( expecting_100 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).kept_body as *const _ as usize }, 200usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( kept_body ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).body_table as *const _ as usize }, 208usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( body_table ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).remaining as *const _ as usize }, 216usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( remaining ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).read_length as *const _ as usize }, 224usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( read_length ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).headers_in as *const _ as usize }, 232usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( headers_in ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).headers_out as *const _ as usize }, 240usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( headers_out ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).err_headers_out as *const _ as usize }, 248usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( err_headers_out ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).subprocess_env as *const _ as usize }, 256usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( subprocess_env ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).notes as *const _ as usize }, 264usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( notes ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).content_type as *const _ as usize }, 272usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( content_type ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).handler as *const _ as usize }, 280usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( handler ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).content_encoding as *const _ as usize }, 288usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( content_encoding ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).content_languages as *const _ as usize }, 296usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( content_languages ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).vlist_validator as *const _ as usize }, 304usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( vlist_validator ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).user as *const _ as usize }, 312usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( user ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).ap_auth_type as *const _ as usize }, 320usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( ap_auth_type ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).unparsed_uri as *const _ as usize }, 328usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( unparsed_uri ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).uri as *const _ as usize }, 336usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( uri ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).filename as *const _ as usize }, 344usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( filename ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).canonical_filename as *const _ as usize }, 352usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( canonical_filename ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).path_info as *const _ as usize }, 360usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( path_info ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).args as *const _ as usize }, 368usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( args ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).used_path_info as *const _ as usize }, 376usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( used_path_info ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).eos_sent as *const _ as usize }, 380usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( eos_sent ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).per_dir_config as *const _ as usize }, 384usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( per_dir_config ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).request_config as *const _ as usize }, 392usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( request_config ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).log as *const _ as usize }, 400usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( log ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).log_id as *const _ as usize }, 408usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( log_id ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).htaccess as *const _ as usize }, 416usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( htaccess ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).output_filters as *const _ as usize }, 424usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( output_filters ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).input_filters as *const _ as usize }, 432usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( input_filters ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).proto_output_filters as *const _ as usize }, 440usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( proto_output_filters ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).proto_input_filters as *const _ as usize }, 448usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( proto_input_filters ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).no_cache as *const _ as usize }, 456usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( no_cache ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).no_local_copy as *const _ as usize }, 460usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( no_local_copy ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).invoke_mtx as *const _ as usize }, 464usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( invoke_mtx ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).parsed_uri as *const _ as usize }, 472usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( parsed_uri ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).finfo as *const _ as usize }, 560usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( finfo ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).useragent_addr as *const _ as usize }, 680usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( useragent_addr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).useragent_ip as *const _ as usize }, 688usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( useragent_ip ) ));
}

pub const ap_conn_keepalive_e_AP_CONN_UNKNOWN: ap_conn_keepalive_e = 0;
pub const ap_conn_keepalive_e_AP_CONN_CLOSE: ap_conn_keepalive_e = 1;
pub const ap_conn_keepalive_e_AP_CONN_KEEPALIVE: ap_conn_keepalive_e = 2;

/// @brief Enumeration of connection keepalive options
pub type ap_conn_keepalive_e = u32;

/// @brief Structure to store things which are per connection
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conn_rec {
    /// Pool associated with this connection
    pub pool: *mut ffi::apr_pool_t,
    /// Physical vhost this conn came in on
    pub base_server: *mut ffi::server_rec,
    /// used by http_vhost.c
    pub vhost_lookup_data: *mut ::libc::c_void,
    /// local address
    pub local_addr: *mut ffi::apr_sockaddr_t,
    /// remote address; this is the end-point of the next hop, for the address
    /// of the request creator, see useragent_addr in request_rec
    pub client_addr: *mut apr_sockaddr_t,
    /// Client's IP address; this is the end-point of the next hop, for the
    /// IP of the request creator, see useragent_ip in request_rec
    pub client_ip: *mut ::libc::c_char,
    /// Client's DNS name, if known.  NULL if DNS hasn't been checked,
    /// "" if it has and no address was found.  N.B. Only access this though
    /// get_remote_host()
    pub remote_host: *mut ::libc::c_char,
    /// Only ever set if doing rfc1413 lookups.  N.B. Only access this through
    /// get_remote_logname()
    pub remote_logname: *mut ::libc::c_char,
    /// server IP address
    pub local_ip: *mut ::libc::c_char,
    /// used for ap_get_server_name when UseCanonicalName is set to DNS
    /// (ignores setting of HostnameLookups)
    pub local_host: *mut ::libc::c_char,
    /// ID of this connection; unique at any point in time
    pub id: ::libc::c_long,
    /// Config vector containing pointers to connections per-server
    /// config structures.
    pub conn_config: *mut ffi::ap_conf_vector_t,
    /// Notes on *this* connection: send note from one module to
    /// another. must remain valid for all requests on this conn
    pub notes: *mut ffi::apr_table_t,
    /// A list of input filters to be used for this connection
    pub input_filters: *mut ffi::ap_filter_t,
    /// A list of output filters to be used for this connection
    pub output_filters: *mut ffi::ap_filter_t,
    /// handle to scoreboard information for this connection
    pub sbh: *mut ::libc::c_void,
    /// The bucket allocator to use for all bucket/brigade creations
    pub bucket_alloc: *mut ffi::apr_bucket_alloc_t,
    /// The current state of this connection; may be NULL if not used by MPM
    pub cs: *mut conn_state_t,
    /// Is there data pending in the input filters?
    pub data_in_input_filters: ::libc::c_int,
    /// Is there data pending in the output filters?
    pub data_in_output_filters: ::libc::c_int,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    /// Are we still talking?
    pub aborted: ::libc::c_uint,
    /// Are we going to keep the connection alive for another request?
    /// @see ap_conn_keepalive_e
    pub keepalive: ap_conn_keepalive_e,
    /// How many times have we used it?
    pub keepalives: ::libc::c_int,
    /// Optional connection log level configuration. May point to a server or
    /// per_dir config, i.e. must be copied before modifying
    pub log: *const ap_logconf,
    /// Id to identify this connection in error log. Set when the first
    /// error log entry for this connection is generated.
    pub log_id: *const ::libc::c_char,
    pub current_thread: *mut ffi::apr_thread_t,
}

#[test]
fn bindgen_test_layout_conn_rec() {
    assert_eq!(::std::mem::size_of::<conn_rec>(), 192usize, concat!( "Size of: " , stringify ! ( conn_rec ) ));
    assert_eq!(::std::mem::align_of::<conn_rec>(), 8usize, concat!( "Alignment of " , stringify ! ( conn_rec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).pool as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).base_server as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( base_server ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).vhost_lookup_data as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( vhost_lookup_data ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).local_addr as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( local_addr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).client_addr as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( client_addr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).client_ip as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( client_ip ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).remote_host as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( remote_host ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).remote_logname as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( remote_logname ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).local_ip as *const _ as usize }, 64usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( local_ip ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).local_host as *const _ as usize }, 72usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( local_host ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).id as *const _ as usize }, 80usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( id ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).conn_config as *const _ as usize }, 88usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( conn_config ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).notes as *const _ as usize }, 96usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( notes ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).input_filters as *const _ as usize }, 104usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( input_filters ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).output_filters as *const _ as usize }, 112usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( output_filters ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).sbh as *const _ as usize }, 120usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( sbh ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).bucket_alloc as *const _ as usize }, 128usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( bucket_alloc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).cs as *const _ as usize }, 136usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( cs ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).data_in_input_filters as *const _ as usize }, 144usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( data_in_input_filters ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).data_in_output_filters as *const _ as usize }, 148usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( data_in_output_filters ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).aborted as *const _ as usize }, 156usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( aborted ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).keepalive as *const _ as usize }, 160usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( keepalive ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).keepalives as *const _ as usize }, 164usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( keepalives ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).log as *const _ as usize }, 168usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( log ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).log_id as *const _ as usize }, 176usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( log_id ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).current_thread as *const _ as usize }, 184usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( current_thread ) ));
}

impl conn_rec {
    #[inline]
    pub fn clogging_input_filters(&self) -> ::libc::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) } }
    #[inline]
    pub fn set_clogging_input_filters(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn double_reverse(&self) -> ::libc::c_int { unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) } }
    #[inline]
    pub fn set_double_reverse(&mut self, val: ::libc::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(clogging_input_filters: ::libc::c_uint, double_reverse: ::libc::c_int) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let clogging_input_filters: u32 = unsafe { ::std::mem::transmute(clogging_input_filters) };
            clogging_input_filters as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let double_reverse: u32 = unsafe { ::std::mem::transmute(double_reverse) };
            double_reverse as u64
        });
        __bindgen_bitfield_unit
    }
}

pub const conn_state_e_CONN_STATE_CHECK_REQUEST_LINE_READABLE: conn_state_e = 0;
pub const conn_state_e_CONN_STATE_READ_REQUEST_LINE: conn_state_e = 1;
pub const conn_state_e_CONN_STATE_HANDLER: conn_state_e = 2;
pub const conn_state_e_CONN_STATE_WRITE_COMPLETION: conn_state_e = 3;
pub const conn_state_e_CONN_STATE_SUSPENDED: conn_state_e = 4;
pub const conn_state_e_CONN_STATE_LINGER: conn_state_e = 5;
pub const conn_state_e_CONN_STATE_LINGER_NORMAL: conn_state_e = 6;
pub const conn_state_e_CONN_STATE_LINGER_SHORT: conn_state_e = 7;

/// Enumeration of connection states
/// The two states CONN_STATE_LINGER_NORMAL and CONN_STATE_LINGER_SHORT may
/// only be set by the MPM. Use CONN_STATE_LINGER outside of the MPM.
pub type conn_state_e = u32;

pub const conn_sense_e_CONN_SENSE_DEFAULT: conn_sense_e = 0;
pub const conn_sense_e_CONN_SENSE_WANT_READ: conn_sense_e = 1;
pub const conn_sense_e_CONN_SENSE_WANT_WRITE: conn_sense_e = 2;

pub type conn_sense_e = u32;

/// @brief A structure to contain connection state information
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conn_state_t {
    /// Current state of the connection
    pub state: conn_state_e,
    /// Whether to read instead of write, or write instead of read
    pub sense: conn_sense_e,
}

#[test]
fn bindgen_test_layout_conn_state_t() {
    assert_eq!(::std::mem::size_of::<conn_state_t>(), 8usize, concat!( "Size of: " , stringify ! ( conn_state_t ) ));
    assert_eq!(::std::mem::align_of::<conn_state_t>(), 4usize, concat!( "Alignment of " , stringify ! ( conn_state_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_state_t>())).state as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( conn_state_t ) , "::" , stringify ! ( state ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_state_t>())).sense as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( conn_state_t ) , "::" , stringify ! ( sense ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct server_addr_rec {
    /// The next server in the list
    pub next: *mut server_addr_rec,
    /// The name given in "<VirtualHost>"
    pub virthost: *mut ::libc::c_char,
    /// The bound address, for this server
    pub host_addr: *mut apr_sockaddr_t,
    /// The bound port, for this server
    pub host_port: apr_port_t,
}

#[test]
fn bindgen_test_layout_server_addr_rec() {
    assert_eq!(::std::mem::size_of::<server_addr_rec>(), 32usize, concat!( "Size of: " , stringify ! ( server_addr_rec ) ));
    assert_eq!(::std::mem::align_of::<server_addr_rec>(), 8usize, concat!( "Alignment of " , stringify ! ( server_addr_rec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_addr_rec>())).next as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( server_addr_rec ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_addr_rec>())).virthost as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( server_addr_rec ) , "::" , stringify ! ( virthost ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_addr_rec>())).host_addr as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( server_addr_rec ) , "::" , stringify ! ( host_addr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_addr_rec>())).host_port as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( server_addr_rec ) , "::" , stringify ! ( host_port ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_logconf {
    /// The per-module log levels
    pub module_levels: *mut ::libc::c_schar,
    /// The log level for this server
    pub level: ::libc::c_int,
}

#[test]
fn bindgen_test_layout_ap_logconf() {
    assert_eq!(::std::mem::size_of::<ap_logconf>(), 16usize, concat!( "Size of: " , stringify ! ( ap_logconf ) ));
    assert_eq!(::std::mem::align_of::<ap_logconf>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_logconf ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_logconf>())).module_levels as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_logconf ) , "::" , stringify ! ( module_levels ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_logconf>())).level as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_logconf ) , "::" , stringify ! ( level ) ));
}

/// @brief A structure to store information for each virtual server
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct server_rec {
    /// The process this server is running in
    pub process: *mut process_rec,
    /// The next server in the list
    pub next: *mut server_rec,
    /// The name of the error log
    pub error_fname: *mut ::libc::c_char,
    /// A file descriptor that references the error log
    pub error_log: *mut apr_file_t,
    /// The log level configuration
    pub log: ap_logconf,
    /// Config vector containing pointers to modules' per-server config
    /// structures.
    pub module_config: *mut ap_conf_vector_t,
    /// MIME type info, etc., before we start checking per-directory info
    pub lookup_defaults: *mut ap_conf_vector_t,
    /// The name of the server
    pub defn_name: *const ::libc::c_char,
    /// The line of the config file that the server was defined on
    pub defn_line_number: ::libc::c_uint,
    /// true if this is the virtual server
    pub is_virtual: ::libc::c_char,
    /// for redirects, etc.
    pub port: apr_port_t,
    /// The server request scheme for redirect responses
    pub server_scheme: *const ::libc::c_char,
    /// The admin's contact information
    pub server_admin: *mut ::libc::c_char,
    /// The server hostname
    pub server_hostname: *mut ::libc::c_char,
    /// I haven't got a clue
    pub addrs: *mut server_addr_rec,
    /// Timeout, as an apr interval, before we give up
    pub timeout: apr_interval_time_t,
    /// The apr interval we will wait for another request
    pub keep_alive_timeout: apr_interval_time_t,
    /// Maximum requests per connection
    pub keep_alive_max: ::libc::c_int,
    /// Use persistent connections?
    pub keep_alive: ::libc::c_int,
    /// Normal names for ServerAlias servers
    pub names: *mut apr_array_header_t,
    /// Wildcarded names for ServerAlias servers
    pub wild_names: *mut apr_array_header_t,
    /// Pathname for ServerPath
    pub path: *const ::libc::c_char,
    /// Length of path
    pub pathlen: ::libc::c_int,
    /// limit on size of the HTTP request line
    pub limit_req_line: ::libc::c_int,
    /// limit on size of any request header field
    pub limit_req_fieldsize: ::libc::c_int,
    /// limit on number of request header fields
    pub limit_req_fields: ::libc::c_int,
    /// Opaque storage location
    pub context: *mut ::libc::c_void,
}

#[test]
fn bindgen_test_layout_server_rec() {
    assert_eq!(::std::mem::size_of::<server_rec>(), 184usize, concat!( "Size of: " , stringify ! ( server_rec ) ));
    assert_eq!(::std::mem::align_of::<server_rec>(), 8usize, concat!( "Alignment of " , stringify ! ( server_rec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).process as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( process ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).next as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).error_fname as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( error_fname ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).error_log as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( error_log ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).log as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( log ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).module_config as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( module_config ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).lookup_defaults as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( lookup_defaults ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).defn_name as *const _ as usize }, 64usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( defn_name ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).defn_line_number as *const _ as usize }, 72usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( defn_line_number ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).is_virtual as *const _ as usize }, 76usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( is_virtual ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).port as *const _ as usize }, 78usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( port ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).server_scheme as *const _ as usize }, 80usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( server_scheme ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).server_admin as *const _ as usize }, 88usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( server_admin ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).server_hostname as *const _ as usize }, 96usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( server_hostname ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).addrs as *const _ as usize }, 104usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( addrs ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).timeout as *const _ as usize }, 112usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( timeout ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).keep_alive_timeout as *const _ as usize }, 120usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( keep_alive_timeout ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).keep_alive_max as *const _ as usize }, 128usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( keep_alive_max ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).keep_alive as *const _ as usize }, 132usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( keep_alive ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).names as *const _ as usize }, 136usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( names ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).wild_names as *const _ as usize }, 144usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( wild_names ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).path as *const _ as usize }, 152usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( path ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).pathlen as *const _ as usize }, 160usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( pathlen ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).limit_req_line as *const _ as usize }, 164usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( limit_req_line ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).limit_req_fieldsize as *const _ as usize }, 168usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( limit_req_fieldsize ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).limit_req_fields as *const _ as usize }, 172usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( limit_req_fields ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).context as *const _ as usize }, 176usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( context ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_sload_t { pub idle: ::libc::c_int, pub busy: ::libc::c_int, pub bytes_served: apr_off_t, pub access_count: ::libc::c_ulong }

#[test]
fn bindgen_test_layout_ap_sload_t() {
    assert_eq!(::std::mem::size_of::<ap_sload_t>(), 24usize, concat!( "Size of: " , stringify ! ( ap_sload_t ) ));
    assert_eq!(::std::mem::align_of::<ap_sload_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_sload_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_sload_t>())).idle as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_sload_t ) , "::" , stringify ! ( idle ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_sload_t>())).busy as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( ap_sload_t ) , "::" , stringify ! ( busy ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_sload_t>())).bytes_served as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_sload_t ) , "::" , stringify ! ( bytes_served ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_sload_t>())).access_count as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_sload_t ) , "::" , stringify ! ( access_count ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_loadavg_t { pub loadavg: f32, pub loadavg5: f32, pub loadavg15: f32 }

#[test]
fn bindgen_test_layout_ap_loadavg_t() {
    assert_eq!(::std::mem::size_of::<ap_loadavg_t>(), 12usize, concat!( "Size of: " , stringify ! ( ap_loadavg_t ) ));
    assert_eq!(::std::mem::align_of::<ap_loadavg_t>(), 4usize, concat!( "Alignment of " , stringify ! ( ap_loadavg_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_loadavg_t>())).loadavg as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_loadavg_t ) , "::" , stringify ! ( loadavg ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_loadavg_t>())).loadavg5 as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( ap_loadavg_t ) , "::" , stringify ! ( loadavg5 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_loadavg_t>())).loadavg15 as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_loadavg_t ) , "::" , stringify ! ( loadavg15 ) ));
}

/// Structure to store the contents of an HTTP form of the type
/// application/x-www-form-urlencoded.
///
/// Currently it contains the name as a char* of maximum length
/// HUGE_STRING_LEN, and a value in the form of a bucket brigade
/// of arbitrary length.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_form_pair_t { pub name: *const ::libc::c_char, pub value: *mut apr_bucket_brigade }

#[test]
fn bindgen_test_layout_ap_form_pair_t() {
    assert_eq!(::std::mem::size_of::<ap_form_pair_t>(), 16usize, concat!( "Size of: " , stringify ! ( ap_form_pair_t ) ));
    assert_eq!(::std::mem::align_of::<ap_form_pair_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_form_pair_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_form_pair_t>())).name as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_form_pair_t ) , "::" , stringify ! ( name ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_form_pair_t>())).value as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_form_pair_t ) , "::" , stringify ! ( value ) ));
}

/// @brief Structure used to build the config tree.
///
/// The config tree only stores
/// the directives that will be active in the running server.  Directives
/// that contain other directions, such as &lt;Directory ...&gt; cause a sub-level
/// to be created, where the included directives are stored.  The closing
/// directive (&lt;/Directory&gt;) is not stored in the tree.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_directive_t {
    /// The current directive
    pub directive: *const ::libc::c_char,
    /// The arguments for the current directive, stored as a space
    /// separated list
    pub args: *const ::libc::c_char,
    /// The next directive node in the tree
    pub next: *mut ap_directive_t,
    /// The first child node of this directive
    pub first_child: *mut ap_directive_t,
    /// The parent node of this directive
    pub parent: *mut ap_directive_t,
    /// directive's module can store add'l data here
    pub data: *mut ::libc::c_void,
    /// The name of the file this directive was found in
    pub filename: *const ::libc::c_char,
    /// The line number the directive was on
    pub line_num: ::libc::c_int,
    /// A short-cut towards the last directive node in the tree.
    /// The value may not always be up-to-date but it always points to
    /// somewhere in the tree, nearer to the tail.
    /// This value is only set in the first node
    pub last: *mut ap_directive_t,
}

#[test]
fn bindgen_test_layout_ap_directive_t() {
    assert_eq!(::std::mem::size_of::<ap_directive_t>(), 72usize, concat!( "Size of: " , stringify ! ( ap_directive_t ) ));
    assert_eq!(::std::mem::align_of::<ap_directive_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_directive_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_directive_t>())).directive as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_directive_t ) , "::" , stringify ! ( directive ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_directive_t>())).args as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_directive_t ) , "::" , stringify ! ( args ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_directive_t>())).next as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_directive_t ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_directive_t>())).first_child as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_directive_t ) , "::" , stringify ! ( first_child ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_directive_t>())).parent as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_directive_t ) , "::" , stringify ! ( parent ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_directive_t>())).data as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( ap_directive_t ) , "::" , stringify ! ( data ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_directive_t>())).filename as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( ap_directive_t ) , "::" , stringify ! ( filename ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_directive_t>())).line_num as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( ap_directive_t ) , "::" , stringify ! ( line_num ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_directive_t>())).last as *const _ as usize }, 64usize, concat!( "Offset of field: " , stringify ! ( ap_directive_t ) , "::" , stringify ! ( last ) ));
}

extern "C" {
    #[link_name = "\u{1}ap_conftree"]
    pub static mut ap_conftree: *mut ap_directive_t;
}

/// < cmd_func parses command line itself
pub const cmd_how_RAW_ARGS: cmd_how = 0;
/// < one argument only
pub const cmd_how_TAKE1: cmd_how = 1;
/// < two arguments only
pub const cmd_how_TAKE2: cmd_how = 2;
/// < one argument, occuring multiple times
/// (e.g., IndexIgnore)
pub const cmd_how_ITERATE: cmd_how = 3;
/// < two arguments, 2nd occurs multiple times
/// (e.g., AddIcon)
pub const cmd_how_ITERATE2: cmd_how = 4;
/// < One of 'On' or 'Off'
pub const cmd_how_FLAG: cmd_how = 5;
/// < No args at all, e.g. </Directory>
pub const cmd_how_NO_ARGS: cmd_how = 6;
/// < one or two arguments
pub const cmd_how_TAKE12: cmd_how = 7;
/// < three arguments only
pub const cmd_how_TAKE3: cmd_how = 8;
/// < two or three arguments
pub const cmd_how_TAKE23: cmd_how = 9;
/// < one, two or three arguments
pub const cmd_how_TAKE123: cmd_how = 10;
/// < one or three arguments
pub const cmd_how_TAKE13: cmd_how = 11;
/// < an argc and argv are passed
pub const cmd_how_TAKE_ARGV: cmd_how = 12;

/// How the directives arguments should be parsed.
/// @remark Note that for all of these except RAW_ARGS, the config routine is
/// passed a freshly allocated string which can be modified or stored
/// or whatever...
pub type cmd_how = u32;
/// This structure is passed to a command which is being invoked,
/// to carry a large variety of miscellaneous data which is all of
/// use to *somebody*...
pub type cmd_parms = cmd_parms_struct;

/// All the types of functions that can be used in directives
/// @internal
#[repr(C)]
#[derive(Copy, Clone)]
pub union cmd_func {
    /// function to call for a no-args
    pub no_args: ::std::option::Option<unsafe extern "C" fn(parms: *mut cmd_parms, mconfig: *mut ::libc::c_void) -> *const ::libc::c_char>,
    /// function to call for a raw-args
    pub raw_args: ::std::option::Option<unsafe extern "C" fn(parms: *mut cmd_parms, mconfig: *mut ::libc::c_void, args: *const ::libc::c_char) -> *const ::libc::c_char>,
    /// function to call for a argv/argc
    pub take_argv: ::std::option::Option<unsafe extern "C" fn(parms: *mut cmd_parms, mconfig: *mut ::libc::c_void, argc: ::libc::c_int, argv: *const *const ::libc::c_char) -> *const ::libc::c_char>,
    /// function to call for a take1
    pub take1: ::std::option::Option<unsafe extern "C" fn(parms: *mut cmd_parms, mconfig: *mut ::libc::c_void, w: *const ::libc::c_char) -> *const ::libc::c_char>,
    /// function to call for a take2
    pub take2: ::std::option::Option<unsafe extern "C" fn(parms: *mut cmd_parms, mconfig: *mut ::libc::c_void, w: *const ::libc::c_char, w2: *const ::libc::c_char) -> *const ::libc::c_char>,
    /// function to call for a take3
    pub take3: ::std::option::Option<unsafe extern "C" fn(parms: *mut cmd_parms, mconfig: *mut ::libc::c_void, w: *const ::libc::c_char, w2: *const ::libc::c_char, w3: *const ::libc::c_char) -> *const ::libc::c_char>,
    /// function to call for a flag
    pub flag: ::std::option::Option<unsafe extern "C" fn(parms: *mut cmd_parms, mconfig: *mut ::libc::c_void, on: ::libc::c_int) -> *const ::libc::c_char>,
    _bindgen_union_align: u64,
}

#[test]
fn bindgen_test_layout_cmd_func() {
    assert_eq!(::std::mem::size_of::<cmd_func>(), 8usize, concat!( "Size of: " , stringify ! ( cmd_func ) ));
    assert_eq!(::std::mem::align_of::<cmd_func>(), 8usize, concat!( "Alignment of " , stringify ! ( cmd_func ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_func>())).no_args as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( cmd_func ) , "::" , stringify ! ( no_args ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_func>())).raw_args as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( cmd_func ) , "::" , stringify ! ( raw_args ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_func>())).take_argv as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( cmd_func ) , "::" , stringify ! ( take_argv ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_func>())).take1 as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( cmd_func ) , "::" , stringify ! ( take1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_func>())).take2 as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( cmd_func ) , "::" , stringify ! ( take2 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_func>())).take3 as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( cmd_func ) , "::" , stringify ! ( take3 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_func>())).flag as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( cmd_func ) , "::" , stringify ! ( flag ) ));
}

/// The command record structure.  Modules can define a table of these
/// to define the directives it will implement.
pub type command_rec = command_struct;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct command_struct {
    /// Name of this command
    pub name: *const ::libc::c_char,
    /// The function to be called when this directive is parsed
    pub func: cmd_func,
    /// Extra data, for functions which implement multiple commands...
    pub cmd_data: *mut ::libc::c_void,
    /// What overrides need to be allowed to enable this command.
    pub req_override: ::libc::c_int,
    /// What the command expects as arguments
    pub args_how: cmd_how,
    /// 'usage' message, in case of syntax errors
    pub errmsg: *const ::libc::c_char,
}

#[test]
fn bindgen_test_layout_command_struct() {
    assert_eq!(::std::mem::size_of::<command_struct>(), 40usize, concat!( "Size of: " , stringify ! ( command_struct ) ));
    assert_eq!(::std::mem::align_of::<command_struct>(), 8usize, concat!( "Alignment of " , stringify ! ( command_struct ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<command_struct>())).name as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( command_struct ) , "::" , stringify ! ( name ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<command_struct>())).func as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( command_struct ) , "::" , stringify ! ( func ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<command_struct>())).cmd_data as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( command_struct ) , "::" , stringify ! ( cmd_data ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<command_struct>())).req_override as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( command_struct ) , "::" , stringify ! ( req_override ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<command_struct>())).args_how as *const _ as usize }, 28usize, concat!( "Offset of field: " , stringify ! ( command_struct ) , "::" , stringify ! ( args_how ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<command_struct>())).errmsg as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( command_struct ) , "::" , stringify ! ( errmsg ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_configfile_t {
    /// < a getc()-like function
    pub getch: ::std::option::Option<unsafe extern "C" fn(ch: *mut ::libc::c_char, param: *mut ::libc::c_void) -> apr_status_t>,
    pub getstr: ::std::option::Option<unsafe extern "C" fn(buf: *mut ::libc::c_void, bufsiz: apr_size_t, param: *mut ::libc::c_void) -> apr_status_t>,
    /// < a close handler function
    pub close: ::std::option::Option<unsafe extern "C" fn(param: *mut ::libc::c_void) -> apr_status_t>,
    /// < the argument passed to getch/getstr/close
    pub param: *mut ::libc::c_void,
    /// < the filename / description
    pub name: *const ::libc::c_char,
    /// < current line number, starting at 1
    pub line_number: ::libc::c_uint,
}

#[test]
fn bindgen_test_layout_ap_configfile_t() {
    assert_eq!(::std::mem::size_of::<ap_configfile_t>(), 48usize, concat!( "Size of: " , stringify ! ( ap_configfile_t ) ));
    assert_eq!(::std::mem::align_of::<ap_configfile_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_configfile_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_configfile_t>())).getch as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_configfile_t ) , "::" , stringify ! ( getch ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_configfile_t>())).getstr as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_configfile_t ) , "::" , stringify ! ( getstr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_configfile_t>())).close as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_configfile_t ) , "::" , stringify ! ( close ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_configfile_t>())).param as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_configfile_t ) , "::" , stringify ! ( param ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_configfile_t>())).name as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_configfile_t ) , "::" , stringify ! ( name ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_configfile_t>())).line_number as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( ap_configfile_t ) , "::" , stringify ! ( line_number ) ));
}

/// This structure is passed to a command which is being invoked,
/// to carry a large variety of miscellaneous data which is all of
/// use to *somebody*...
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_parms_struct {
    /// Argument to command from cmd_table
    pub info: *mut ::libc::c_void,
    /// Which allow-override bits are set
    pub override_: ::libc::c_int,
    /// Which allow-override-opts bits are set
    pub override_opts: ::libc::c_int,
    /// Table of directives allowed per AllowOverrideList
    pub override_list: *mut apr_table_t,
    /// Which methods are &lt;Limit&gt;ed
    pub limited: apr_int64_t,
    /// methods which are limited
    pub limited_xmethods: *mut apr_array_header_t,
    /// methods which are xlimited
    pub xlimited: *mut ap_method_list_t,
    /// Config file structure.
    pub config_file: *mut ap_configfile_t,
    /// the directive specifying this command
    pub directive: *mut ap_directive_t,
    /// Pool to allocate new storage in
    pub pool: *mut apr_pool_t,
    /// Pool for scratch memory; persists during configuration, but
    /// wiped before the first request is served...
    pub temp_pool: *mut apr_pool_t,
    /// Server_rec being configured for
    pub server: *mut server_rec,
    /// If configuring for a directory, pathname of that directory.
    /// NOPE!  That's what it meant previous to the existence of &lt;Files&gt;,
    /// &lt;Location&gt; and regex matching.  Now the only usefulness that can be
    /// derived from this field is whether a command is being called in a
    /// server context (path == NULL) or being called in a dir context
    /// (path != NULL).
    pub path: *mut ::libc::c_char,
    /// configuration command
    pub cmd: *const command_rec,
    /// per_dir_config vector passed to handle_command
    pub context: *mut ap_conf_vector_t,
    /// directive with syntax error
    pub err_directive: *const ap_directive_t,
}

#[test]
fn bindgen_test_layout_cmd_parms_struct() {
    assert_eq!(::std::mem::size_of::<cmd_parms_struct>(), 120usize, concat!( "Size of: " , stringify ! ( cmd_parms_struct ) ));
    assert_eq!(::std::mem::align_of::<cmd_parms_struct>(), 8usize, concat!( "Alignment of " , stringify ! ( cmd_parms_struct ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).info as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( info ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).override_ as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( override_ ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).override_opts as *const _ as usize }, 12usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( override_opts ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).override_list as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( override_list ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).limited as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( limited ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).limited_xmethods as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( limited_xmethods ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).xlimited as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( xlimited ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).config_file as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( config_file ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).directive as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( directive ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).pool as *const _ as usize }, 64usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).temp_pool as *const _ as usize }, 72usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( temp_pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).server as *const _ as usize }, 80usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( server ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).path as *const _ as usize }, 88usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( path ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).cmd as *const _ as usize }, 96usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( cmd ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).context as *const _ as usize }, 104usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( context ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).err_directive as *const _ as usize }, 112usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( err_directive ) ));
}

/// Module structures.  Just about everything is dispatched through
/// these, directly or indirectly (through the command and handler
/// tables).
pub type module = module_struct;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_struct {
    /// API version, *not* module version; check that module is
    /// compatible with this version of the server.
    pub version: ::libc::c_int,
    /// API minor version. Provides API feature milestones. Not checked
    /// during module init
    pub minor_version: ::libc::c_int,
    /// Index to this modules structures in config vectors.
    pub module_index: ::libc::c_int,
    /// The name of the module's C file
    pub name: *const ::libc::c_char,
    /// The handle for the DSO.  Internal use only
    pub dynamic_load_handle: *mut ::libc::c_void,
    /// A pointer to the next module in the list
    /// @var module_struct *next
    pub next: *mut module_struct,
    /// Magic Cookie to identify a module structure;  It's mainly
    /// important for the DSO facility (see also mod_so).
    pub magic: ::libc::c_ulong,
    /// Function to allow MPMs to re-write command line arguments.  This
    /// hook is only available to MPMs.
    /// @param The process that the server is running in.
    pub rewrite_args: ::std::option::Option<unsafe extern "C" fn(process: *mut process_rec)>,
    /// Function to allow all modules to create per directory configuration
    /// structures.
    /// @param p The pool to use for all allocations.
    /// @param dir The directory currently being processed.
    /// @return The per-directory structure created
    pub create_dir_config: ::std::option::Option<unsafe extern "C" fn(p: *mut apr_pool_t, dir: *mut ::libc::c_char) -> *mut ::libc::c_void>,
    /// Function to allow all modules to merge the per directory configuration
    /// structures for two directories.
    /// @param p The pool to use for all allocations.
    /// @param base_conf The directory structure created for the parent directory.
    /// @param new_conf The directory structure currently being processed.
    /// @return The new per-directory structure created
    pub merge_dir_config: ::std::option::Option<unsafe extern "C" fn(p: *mut apr_pool_t, base_conf: *mut ::libc::c_void, new_conf: *mut ::libc::c_void) -> *mut ::libc::c_void>,
    /// Function to allow all modules to create per server configuration
    /// structures.
    /// @param p The pool to use for all allocations.
    /// @param s The server currently being processed.
    /// @return The per-server structure created
    pub create_server_config: ::std::option::Option<unsafe extern "C" fn(p: *mut apr_pool_t, s: *mut server_rec) -> *mut ::libc::c_void>,
    /// Function to allow all modules to merge the per server configuration
    /// structures for two servers.
    /// @param p The pool to use for all allocations.
    /// @param base_conf The directory structure created for the parent directory.
    /// @param new_conf The directory structure currently being processed.
    /// @return The new per-directory structure created
    pub merge_server_config: ::std::option::Option<unsafe extern "C" fn(p: *mut apr_pool_t, base_conf: *mut ::libc::c_void, new_conf: *mut ::libc::c_void) -> *mut ::libc::c_void>,
    /// A command_rec table that describes all of the directives this module
    /// defines.
    pub cmds: *const command_rec,
    /// A hook to allow modules to hook other points in the request processing.
    /// In this function, modules should call the ap_hook_*() functions to
    /// register an interest in a specific step in processing the current
    /// request.
    /// @param p the pool to use for all allocations
    pub register_hooks: ::std::option::Option<unsafe extern "C" fn(p: *mut apr_pool_t)>,
}

#[test]
fn bindgen_test_layout_module_struct() {
    assert_eq!(::std::mem::size_of::<module_struct>(), 104usize, concat!( "Size of: " , stringify ! ( module_struct ) ));
    assert_eq!(::std::mem::align_of::<module_struct>(), 8usize, concat!( "Alignment of " , stringify ! ( module_struct ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).version as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( version ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).minor_version as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( minor_version ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).module_index as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( module_index ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).name as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( name ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).dynamic_load_handle as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( dynamic_load_handle ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).next as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).magic as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( magic ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).rewrite_args as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( rewrite_args ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).create_dir_config as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( create_dir_config ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).merge_dir_config as *const _ as usize }, 64usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( merge_dir_config ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).create_server_config as *const _ as usize }, 72usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( create_server_config ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).merge_server_config as *const _ as usize }, 80usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( merge_server_config ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).cmds as *const _ as usize }, 88usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( cmds ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).register_hooks as *const _ as usize }, 96usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( register_hooks ) ));
}

/// @brief This structure is used to assign symbol names to module pointers
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_module_symbol_t { pub name: *const ::libc::c_char, pub modp: *mut module }

#[test]
fn bindgen_test_layout_ap_module_symbol_t() {
    assert_eq!(::std::mem::size_of::<ap_module_symbol_t>(), 16usize, concat!( "Size of: " , stringify ! ( ap_module_symbol_t ) ));
    assert_eq!(::std::mem::align_of::<ap_module_symbol_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_module_symbol_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_module_symbol_t>())).name as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_module_symbol_t ) , "::" , stringify ! ( name ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_module_symbol_t>())).modp as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_module_symbol_t ) , "::" , stringify ! ( modp ) ));
}

extern "C" {
    #[link_name = "\u{1}ap_top_module"]
    pub static mut ap_top_module: *mut module;
}

extern "C" {
    #[link_name = "\u{1}ap_prelinked_modules"]
    pub static mut ap_prelinked_modules: [*mut module; 0usize];
}

extern "C" {
    #[link_name = "\u{1}ap_prelinked_module_symbols"]
    pub static mut ap_prelinked_module_symbols: [ap_module_symbol_t; 0usize];
}

extern "C" {
    #[link_name = "\u{1}ap_preloaded_modules"]
    pub static mut ap_preloaded_modules: [*mut module; 0usize];
}

extern "C" {
    #[link_name = "\u{1}ap_loaded_modules"]
    pub static mut ap_loaded_modules: *mut *mut module;
}

pub type ap_HOOK_header_parser_t = ::std::option::Option<unsafe extern "C" fn(r: *mut request_rec) -> ::libc::c_int>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_header_parser_t { pub pFunc: ap_HOOK_header_parser_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_header_parser_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_header_parser_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_header_parser_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_header_parser_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_header_parser_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_header_parser_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_header_parser_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_header_parser_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_header_parser_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_header_parser_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_header_parser_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_header_parser_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_header_parser_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_header_parser_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_header_parser_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_pre_config_t = ::std::option::Option<unsafe extern "C" fn(pconf: *mut apr_pool_t, plog: *mut apr_pool_t, ptemp: *mut apr_pool_t) -> ::libc::c_int>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_pre_config_t { pub pFunc: ap_HOOK_pre_config_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_pre_config_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_pre_config_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_pre_config_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_pre_config_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_pre_config_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_pre_config_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_pre_config_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_pre_config_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_pre_config_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_pre_config_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_pre_config_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_pre_config_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_pre_config_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_pre_config_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_pre_config_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_check_config_t = ::std::option::Option<unsafe extern "C" fn(pconf: *mut apr_pool_t, plog: *mut apr_pool_t, ptemp: *mut apr_pool_t, s: *mut server_rec) -> ::libc::c_int>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_check_config_t { pub pFunc: ap_HOOK_check_config_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_check_config_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_check_config_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_check_config_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_check_config_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_check_config_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_check_config_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_check_config_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_check_config_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_check_config_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_check_config_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_check_config_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_check_config_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_check_config_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_check_config_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_check_config_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_test_config_t = ::std::option::Option<unsafe extern "C" fn(pconf: *mut apr_pool_t, s: *mut server_rec)>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_test_config_t { pub pFunc: ap_HOOK_test_config_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_test_config_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_test_config_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_test_config_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_test_config_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_test_config_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_test_config_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_test_config_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_test_config_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_test_config_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_test_config_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_test_config_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_test_config_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_test_config_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_test_config_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_test_config_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_post_config_t = ::std::option::Option<unsafe extern "C" fn(pconf: *mut apr_pool_t, plog: *mut apr_pool_t, ptemp: *mut apr_pool_t, s: *mut server_rec) -> ::libc::c_int>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_post_config_t { pub pFunc: ap_HOOK_post_config_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_post_config_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_post_config_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_post_config_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_post_config_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_post_config_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_post_config_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_post_config_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_post_config_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_post_config_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_post_config_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_post_config_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_post_config_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_post_config_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_post_config_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_post_config_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_open_logs_t = ::std::option::Option<unsafe extern "C" fn(pconf: *mut apr_pool_t, plog: *mut apr_pool_t, ptemp: *mut apr_pool_t, s: *mut server_rec) -> ::libc::c_int>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_open_logs_t { pub pFunc: ap_HOOK_open_logs_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_open_logs_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_open_logs_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_open_logs_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_open_logs_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_open_logs_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_open_logs_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_open_logs_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_open_logs_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_open_logs_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_open_logs_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_open_logs_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_open_logs_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_open_logs_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_open_logs_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_open_logs_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_child_init_t = ::std::option::Option<unsafe extern "C" fn(pchild: *mut apr_pool_t, s: *mut server_rec)>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_child_init_t { pub pFunc: ap_HOOK_child_init_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_child_init_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_child_init_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_child_init_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_child_init_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_child_init_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_child_init_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_child_init_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_child_init_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_child_init_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_child_init_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_child_init_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_child_init_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_child_init_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_child_init_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_child_init_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_handler_t = ::std::option::Option<unsafe extern "C" fn(r: *mut request_rec) -> ::libc::c_int>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_handler_t { pub pFunc: ap_HOOK_handler_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_handler_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_handler_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_handler_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_handler_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_handler_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_handler_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_handler_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_handler_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_handler_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_handler_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_handler_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_handler_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_handler_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_handler_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_handler_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_quick_handler_t = ::std::option::Option<unsafe extern "C" fn(r: *mut request_rec, lookup_uri: ::libc::c_int) -> ::libc::c_int>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_quick_handler_t { pub pFunc: ap_HOOK_quick_handler_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_quick_handler_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_quick_handler_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_quick_handler_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_quick_handler_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_quick_handler_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_quick_handler_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_quick_handler_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_quick_handler_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_quick_handler_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_quick_handler_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_quick_handler_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_quick_handler_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_quick_handler_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_quick_handler_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_quick_handler_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_optional_fn_retrieve_t = ::std::option::Option<unsafe extern "C" fn()>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_optional_fn_retrieve_t { pub pFunc: ap_HOOK_optional_fn_retrieve_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_optional_fn_retrieve_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_optional_fn_retrieve_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_optional_fn_retrieve_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_optional_fn_retrieve_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_optional_fn_retrieve_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_optional_fn_retrieve_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_optional_fn_retrieve_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_optional_fn_retrieve_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_optional_fn_retrieve_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_optional_fn_retrieve_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_optional_fn_retrieve_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_optional_fn_retrieve_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_optional_fn_retrieve_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_optional_fn_retrieve_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_optional_fn_retrieve_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_open_htaccess_t = ::std::option::Option<unsafe extern "C" fn(r: *mut request_rec, dir_name: *const ::libc::c_char, access_name: *const ::libc::c_char, conffile: *mut *mut ap_configfile_t, full_name: *mut *const ::libc::c_char) -> apr_status_t>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_open_htaccess_t { pub pFunc: ap_HOOK_open_htaccess_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_open_htaccess_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_open_htaccess_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_open_htaccess_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_open_htaccess_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_open_htaccess_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_open_htaccess_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_open_htaccess_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_open_htaccess_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_open_htaccess_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_open_htaccess_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_open_htaccess_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_open_htaccess_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_open_htaccess_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_open_htaccess_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_open_htaccess_t ) , "::" , stringify ! ( nOrder ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data { pub _address: u8 }

pub type __builtin_va_list = [__va_list_tag; 1usize];

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag { pub gp_offset: ::libc::c_uint, pub fp_offset: ::libc::c_uint, pub overflow_arg_area: *mut ::libc::c_void, pub reg_save_area: *mut ::libc::c_void }

#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>(), 24usize, concat!( "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq!(::std::mem::align_of::<__va_list_tag>(), 8usize, concat!( "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( gp_offset ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( fp_offset ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( overflow_arg_area ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( reg_save_area ) ));
}

/// The file's handle, if accessed (can be submitted to apr_duphandle)
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_file_t { pub _address: u8 }

/// the configuration directives
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_conf_vector_t { pub _address: u8 }

/// structure returned from gethostbyname()
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent { pub _address: u8 }


/////////////////////////////
/// The filter should return at most readbytes data.
pub const ap_input_mode_t_AP_MODE_READBYTES: ap_input_mode_t = 0;
/// The filter should return at most one line of CRLF data.
/// (If a potential line is too long or no CRLF is found, the
/// filter may return partial data).
pub const ap_input_mode_t_AP_MODE_GETLINE: ap_input_mode_t = 1;
/// The filter should implicitly eat any CRLF pairs that it sees.
pub const ap_input_mode_t_AP_MODE_EATCRLF: ap_input_mode_t = 2;
/// The filter read should be treated as speculative and any returned
/// data should be stored for later retrieval in another mode.
pub const ap_input_mode_t_AP_MODE_SPECULATIVE: ap_input_mode_t = 3;
/// The filter read should be exhaustive and read until it can not
/// read any more.
/// Use this mode with extreme caution.
pub const ap_input_mode_t_AP_MODE_EXHAUSTIVE: ap_input_mode_t = 4;
/// The filter should initialize the connection if needed,
/// NNTP or FTP over SSL for example.
pub const ap_input_mode_t_AP_MODE_INIT: ap_input_mode_t = 5;

/// @brief input filtering modes
pub type ap_input_mode_t = u32;
/// @name Filter callbacks
///
/// This function type is used for filter callbacks. It will be passed a
/// pointer to "this" filter, and a "bucket brigade" containing the content
/// to be filtered.
///
/// In filter->ctx, the callback will find its context. This context is
/// provided here, so that a filter may be installed multiple times, each
/// receiving its own per-install context pointer.
///
/// Callbacks are associated with a filter definition, which is specified
/// by name. See ap_register_input_filter() and ap_register_output_filter()
/// for setting the association between a name for a filter and its
/// associated callback (and other information).
///
/// If the initialization function argument passed to the registration
/// functions is non-NULL, it will be called iff the filter is in the input
/// or output filter chains and before any data is generated to allow the
/// filter to prepare for processing.
///
/// The bucket brigade always belongs to the caller, but the filter
/// is free to use the buckets within it as it sees fit. Normally,
/// the brigade will be returned empty. Buckets *may not* be retained
/// between successive calls to the filter unless they have been
/// "set aside" with a call apr_bucket_setaside. Typically this will
/// be done with ap_save_brigade(). Buckets removed from the brigade
/// become the responsibility of the filter, which must arrange for
/// them to be deleted, either by doing so directly or by inserting
/// them in a brigade which will subsequently be destroyed.
///
/// For the input and output filters, the return value of a filter should be
/// an APR status value.  For the init function, the return value should
/// be an HTTP error code or OK if it was successful.
///
/// @ingroup filter
/// @{
pub type ap_out_filter_func = ::std::option::Option<unsafe extern "C" fn(f: *mut ap_filter_t, b: *mut apr_bucket_brigade) -> apr_status_t>;
pub type ap_in_filter_func = ::std::option::Option<unsafe extern "C" fn(f: *mut ap_filter_t, b: *mut apr_bucket_brigade, mode: ap_input_mode_t, block: apr_read_type_e, readbytes: apr_off_t) -> apr_status_t>;
pub type ap_init_filter_func = ::std::option::Option<unsafe extern "C" fn(f: *mut ap_filter_t) -> ::libc::c_int>;

#[repr(C)]
#[derive(Copy, Clone)]
pub union ap_filter_func { pub out_func: ap_out_filter_func, pub in_func: ap_in_filter_func, _bindgen_union_align: u64 }

#[test]
fn bindgen_test_layout_ap_filter_func() {
    assert_eq!(::std::mem::size_of::<ap_filter_func>(), 8usize, concat!( "Size of: " , stringify ! ( ap_filter_func ) ));
    assert_eq!(::std::mem::align_of::<ap_filter_func>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_filter_func ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_func>())).out_func as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_filter_func ) , "::" , stringify ! ( out_func ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_func>())).in_func as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_filter_func ) , "::" , stringify ! ( in_func ) ));
}

/// These filters are used to alter the content that is passed through
/// them. Examples are SSI or PHP.
pub const ap_filter_type_AP_FTYPE_RESOURCE: ap_filter_type = 10;
/// These filters are used to alter the content as a whole, but after all
/// AP_FTYPE_RESOURCE filters are executed.  These filters should not
/// change the content-type.  An example is deflate.
pub const ap_filter_type_AP_FTYPE_CONTENT_SET: ap_filter_type = 20;
/// These filters are used to handle the protocol between server and
/// client.  Examples are HTTP and POP.
pub const ap_filter_type_AP_FTYPE_PROTOCOL: ap_filter_type = 30;
/// These filters implement transport encodings (e.g., chunking).
pub const ap_filter_type_AP_FTYPE_TRANSCODE: ap_filter_type = 40;
/// These filters will alter the content, but in ways that are
/// more strongly associated with the connection.  Examples are
/// splitting an HTTP connection into multiple requests and
/// buffering HTTP responses across multiple requests.
///
/// It is important to note that these types of filters are not
/// allowed in a sub-request. A sub-request's output can certainly
/// be filtered by ::AP_FTYPE_RESOURCE filters, but all of the "final
/// processing" is determined by the main request.
pub const ap_filter_type_AP_FTYPE_CONNECTION: ap_filter_type = 50;
/// These filters don't alter the content.  They are responsible for
/// sending/receiving data to/from the client.
pub const ap_filter_type_AP_FTYPE_NETWORK: ap_filter_type = 60;

/// Filters have different types/classifications. These are used to group
/// and sort the filters to properly sequence their operation.
///
/// The types have a particular sort order, which allows us to insert them
/// into the filter chain in a determistic order. Within a particular grouping,
/// the ordering is equivalent to the order of calls to ap_add_*_filter().
pub type ap_filter_type = u32;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_filter_provider_t { _unused: [u8; 0] }

/// @brief This structure is used for recording information about the
/// registered filters. It associates a name with the filter's callback
/// and filter type.
///
/// At the moment, these are simply linked in a chain, so a ->next pointer
/// is available.
///
/// It is used for any filter that can be inserted in the filter chain.
/// This may be either a httpd-2.0 filter or a mod_filter harness.
/// In the latter case it contains dispatch, provider and protocol information.
/// In the former case, the new fields (from dispatch) are ignored.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ap_filter_rec_t {
    /// The registered name for this filter
    pub name: *const ::libc::c_char,
    /// The function to call when this filter is invoked.
    pub filter_func: ap_filter_func,
    /// The function to call directly before the handlers are invoked
    /// for a request.  The init function is called once directly
    /// before running the handlers for a request or subrequest.  The
    /// init function is never called for a connection filter (with
    /// ftype >= AP_FTYPE_CONNECTION).  Any use of this function for
    /// filters for protocols other than HTTP is specified by the
    /// module supported that protocol.
    pub filter_init_func: ap_init_filter_func,
    /// The next filter_rec in the list
    pub next: *mut ap_filter_rec_t,
    /// Providers for this filter
    pub providers: *mut ap_filter_provider_t,
    /// The type of filter, either AP_FTYPE_CONTENT or AP_FTYPE_CONNECTION.
    /// An AP_FTYPE_CONTENT filter modifies the data based on information
    /// found in the content.  An AP_FTYPE_CONNECTION filter modifies the
    /// data based on the type of connection.
    pub ftype: ap_filter_type,
    /// Trace level for this filter
    pub debug: ::libc::c_int,
    /// Protocol flags for this filter
    pub proto_flags: ::libc::c_uint,
}

#[test]
fn bindgen_test_layout_ap_filter_rec_t() {
    assert_eq!(::std::mem::size_of::<ap_filter_rec_t>(), 56usize, concat!( "Size of: " , stringify ! ( ap_filter_rec_t ) ));
    assert_eq!(::std::mem::align_of::<ap_filter_rec_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_filter_rec_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_rec_t>())).name as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_filter_rec_t ) , "::" , stringify ! ( name ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_rec_t>())).filter_func as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_filter_rec_t ) , "::" , stringify ! ( filter_func ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_rec_t>())).filter_init_func as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_filter_rec_t ) , "::" , stringify ! ( filter_init_func ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_rec_t>())).next as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_filter_rec_t ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_rec_t>())).providers as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_filter_rec_t ) , "::" , stringify ! ( providers ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_rec_t>())).ftype as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( ap_filter_rec_t ) , "::" , stringify ! ( ftype ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_rec_t>())).debug as *const _ as usize }, 44usize, concat!( "Offset of field: " , stringify ! ( ap_filter_rec_t ) , "::" , stringify ! ( debug ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_rec_t>())).proto_flags as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( ap_filter_rec_t ) , "::" , stringify ! ( proto_flags ) ));
}

/// @brief The representation of a filter chain.
///
/// Each request has a list
/// of these structures which are called in turn to filter the data.  Sub
/// requests get an exact copy of the main requests filter chain.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_filter_t {
    /// The internal representation of this filter.  This includes
    /// the filter's name, type, and the actual function pointer.
    pub frec: *mut ffi::ap_filter_rec_t,
    /// A place to store any data associated with the current filter
    pub ctx: *mut ::libc::c_void,
    /// The next filter in the chain
    pub next: *mut ::ffi::ap_filter_t,
    /// The request_rec associated with the current filter.  If a sub-request
    /// adds filters, then the sub-request is the request associated with the
    /// filter.
    pub r: *mut ffi::request_rec,
    /// The conn_rec associated with the current filter.  This is analogous
    /// to the request_rec, except that it is used for connection filters.
    pub c: *mut ffi::conn_rec,
}

#[test]
fn bindgen_test_layout_ap_filter_t() {
    assert_eq!(::std::mem::size_of::<ap_filter_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_filter_t ) ));
    assert_eq!(::std::mem::align_of::<ap_filter_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_filter_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_t>())).frec as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_filter_t ) , "::" , stringify ! ( frec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_t>())).ctx as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_filter_t ) , "::" , stringify ! ( ctx ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_t>())).next as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_filter_t ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_t>())).r as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_filter_t ) , "::" , stringify ! ( r ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_t>())).c as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_filter_t ) , "::" , stringify ! ( c ) ));
}
