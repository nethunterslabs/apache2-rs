#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

use ffi;

pub const MODULE_MAGIC_COOKIE: ::libc::c_ulong = 0x41503232u64; /* "AP22" */
pub const MODULE_MAGIC_NUMBER_MAJOR: ::libc::c_int = 20051115;
pub const MODULE_MAGIC_NUMBER_MINOR: ::libc::c_int = 43;

/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self {
            storage,
            align: [],
        }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                val |= 1 << i;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            self.set_bit(i + bit_offset, val_bit_is_set);
        }
    }
}

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T> (::std::marker::PhantomData<T>);

impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self { __IncompleteArrayField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] { ::std::slice::from_raw_parts(self.as_ptr(), len) }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] { ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len) }
}

impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> { fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result { fmt.write_str("__IncompleteArrayField") } }

impl<T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}

impl<T> ::std::marker::Copy for __IncompleteArrayField<T> {}

pub const APR_HAS_INLINE: u32 = 1;
pub const APR_HAVE_ARPA_INET_H: u32 = 1;
pub const APR_HAVE_CONIO_H: u32 = 0;
pub const APR_HAVE_CRYPT_H: u32 = 1;
pub const APR_HAVE_CTYPE_H: u32 = 1;
pub const APR_HAVE_DIRENT_H: u32 = 1;
pub const APR_HAVE_ERRNO_H: u32 = 1;
pub const APR_HAVE_FCNTL_H: u32 = 1;
pub const APR_HAVE_IO_H: u32 = 0;
pub const APR_HAVE_LIMITS_H: u32 = 1;
pub const APR_HAVE_NETDB_H: u32 = 1;
pub const APR_HAVE_NETINET_IN_H: u32 = 1;
pub const APR_HAVE_NETINET_SCTP_H: u32 = 1;
pub const APR_HAVE_NETINET_SCTP_UIO_H: u32 = 0;
pub const APR_HAVE_NETINET_TCP_H: u32 = 1;
pub const APR_HAVE_PROCESS_H: u32 = 0;
pub const APR_HAVE_PTHREAD_H: u32 = 1;
pub const APR_HAVE_SEMAPHORE_H: u32 = 1;
pub const APR_HAVE_SIGNAL_H: u32 = 1;
pub const APR_HAVE_STDARG_H: u32 = 1;
pub const APR_HAVE_STDINT_H: u32 = 1;
pub const APR_HAVE_STDIO_H: u32 = 1;
pub const APR_HAVE_STDLIB_H: u32 = 1;
pub const APR_HAVE_STRING_H: u32 = 1;
pub const APR_HAVE_STRINGS_H: u32 = 1;
pub const APR_HAVE_SYS_IOCTL_H: u32 = 1;
pub const APR_HAVE_SYS_SENDFILE_H: u32 = 1;
pub const APR_HAVE_SYS_SIGNAL_H: u32 = 1;
pub const APR_HAVE_SYS_SOCKET_H: u32 = 1;
pub const APR_HAVE_SYS_SOCKIO_H: u32 = 0;
pub const APR_HAVE_SYS_SYSLIMITS_H: u32 = 0;
pub const APR_HAVE_SYS_TIME_H: u32 = 1;
pub const APR_HAVE_SYS_TYPES_H: u32 = 1;
pub const APR_HAVE_SYS_UIO_H: u32 = 1;
pub const APR_HAVE_SYS_UN_H: u32 = 1;
pub const APR_HAVE_SYS_WAIT_H: u32 = 1;
pub const APR_HAVE_TIME_H: u32 = 1;
pub const APR_HAVE_UNISTD_H: u32 = 1;
pub const APR_HAVE_WINDOWS_H: u32 = 0;
pub const APR_HAVE_WINSOCK2_H: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201505;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 23;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const _SIGSET_H_types: u32 = 1;
pub const __timespec_defined: u32 = 1;
pub const _STRUCT_TIMEVAL: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _SYS_SYSMACROS_H: u32 = 1;
pub const _BITS_PTHREADTYPES_H: u32 = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __have_pthread_attr_t: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const _SYS_SOCKET_H: u32 = 1;
pub const _SYS_UIO_H: u32 = 1;
pub const _BITS_UIO_H: u32 = 1;
pub const UIO_MAXIOV: u32 = 1024;
pub const PF_UNSPEC: u32 = 0;
pub const PF_LOCAL: u32 = 1;
pub const PF_UNIX: u32 = 1;
pub const PF_FILE: u32 = 1;
pub const PF_INET: u32 = 2;
pub const PF_AX25: u32 = 3;
pub const PF_IPX: u32 = 4;
pub const PF_APPLETALK: u32 = 5;
pub const PF_NETROM: u32 = 6;
pub const PF_BRIDGE: u32 = 7;
pub const PF_ATMPVC: u32 = 8;
pub const PF_X25: u32 = 9;
pub const PF_INET6: u32 = 10;
pub const PF_ROSE: u32 = 11;
pub const PF_DECnet: u32 = 12;
pub const PF_NETBEUI: u32 = 13;
pub const PF_SECURITY: u32 = 14;
pub const PF_KEY: u32 = 15;
pub const PF_NETLINK: u32 = 16;
pub const PF_ROUTE: u32 = 16;
pub const PF_PACKET: u32 = 17;
pub const PF_ASH: u32 = 18;
pub const PF_ECONET: u32 = 19;
pub const PF_ATMSVC: u32 = 20;
pub const PF_RDS: u32 = 21;
pub const PF_SNA: u32 = 22;
pub const PF_IRDA: u32 = 23;
pub const PF_PPPOX: u32 = 24;
pub const PF_WANPIPE: u32 = 25;
pub const PF_LLC: u32 = 26;
pub const PF_IB: u32 = 27;
pub const PF_MPLS: u32 = 28;
pub const PF_CAN: u32 = 29;
pub const PF_TIPC: u32 = 30;
pub const PF_BLUETOOTH: u32 = 31;
pub const PF_IUCV: u32 = 32;
pub const PF_RXRPC: u32 = 33;
pub const PF_ISDN: u32 = 34;
pub const PF_PHONET: u32 = 35;
pub const PF_IEEE802154: u32 = 36;
pub const PF_CAIF: u32 = 37;
pub const PF_ALG: u32 = 38;
pub const PF_NFC: u32 = 39;
pub const PF_VSOCK: u32 = 40;
pub const PF_MAX: u32 = 41;
pub const AF_UNSPEC: u32 = 0;
pub const AF_LOCAL: u32 = 1;
pub const AF_UNIX: u32 = 1;
pub const AF_FILE: u32 = 1;
pub const AF_INET: u32 = 2;
pub const AF_AX25: u32 = 3;
pub const AF_IPX: u32 = 4;
pub const AF_APPLETALK: u32 = 5;
pub const AF_NETROM: u32 = 6;
pub const AF_BRIDGE: u32 = 7;
pub const AF_ATMPVC: u32 = 8;
pub const AF_X25: u32 = 9;
pub const AF_INET6: u32 = 10;
pub const AF_ROSE: u32 = 11;
pub const AF_DECnet: u32 = 12;
pub const AF_NETBEUI: u32 = 13;
pub const AF_SECURITY: u32 = 14;
pub const AF_KEY: u32 = 15;
pub const AF_NETLINK: u32 = 16;
pub const AF_ROUTE: u32 = 16;
pub const AF_PACKET: u32 = 17;
pub const AF_ASH: u32 = 18;
pub const AF_ECONET: u32 = 19;
pub const AF_ATMSVC: u32 = 20;
pub const AF_RDS: u32 = 21;
pub const AF_SNA: u32 = 22;
pub const AF_IRDA: u32 = 23;
pub const AF_PPPOX: u32 = 24;
pub const AF_WANPIPE: u32 = 25;
pub const AF_LLC: u32 = 26;
pub const AF_IB: u32 = 27;
pub const AF_MPLS: u32 = 28;
pub const AF_CAN: u32 = 29;
pub const AF_TIPC: u32 = 30;
pub const AF_BLUETOOTH: u32 = 31;
pub const AF_IUCV: u32 = 32;
pub const AF_RXRPC: u32 = 33;
pub const AF_ISDN: u32 = 34;
pub const AF_PHONET: u32 = 35;
pub const AF_IEEE802154: u32 = 36;
pub const AF_CAIF: u32 = 37;
pub const AF_ALG: u32 = 38;
pub const AF_NFC: u32 = 39;
pub const AF_VSOCK: u32 = 40;
pub const AF_MAX: u32 = 41;
pub const SOL_RAW: u32 = 255;
pub const SOL_DECNET: u32 = 261;
pub const SOL_X25: u32 = 262;
pub const SOL_PACKET: u32 = 263;
pub const SOL_ATM: u32 = 264;
pub const SOL_AAL: u32 = 265;
pub const SOL_IRDA: u32 = 266;
pub const SOMAXCONN: u32 = 128;
pub const _BITS_SOCKADDR_H: u32 = 1;
pub const _SS_SIZE: u32 = 128;
pub const FIOSETOWN: u32 = 35073;
pub const SIOCSPGRP: u32 = 35074;
pub const FIOGETOWN: u32 = 35075;
pub const SIOCGPGRP: u32 = 35076;
pub const SIOCATMARK: u32 = 35077;
pub const SIOCGSTAMP: u32 = 35078;
pub const SIOCGSTAMPNS: u32 = 35079;
pub const SOL_SOCKET: u32 = 1;
pub const SO_DEBUG: u32 = 1;
pub const SO_REUSEADDR: u32 = 2;
pub const SO_TYPE: u32 = 3;
pub const SO_ERROR: u32 = 4;
pub const SO_DONTROUTE: u32 = 5;
pub const SO_BROADCAST: u32 = 6;
pub const SO_SNDBUF: u32 = 7;
pub const SO_RCVBUF: u32 = 8;
pub const SO_SNDBUFFORCE: u32 = 32;
pub const SO_RCVBUFFORCE: u32 = 33;
pub const SO_KEEPALIVE: u32 = 9;
pub const SO_OOBINLINE: u32 = 10;
pub const SO_NO_CHECK: u32 = 11;
pub const SO_PRIORITY: u32 = 12;
pub const SO_LINGER: u32 = 13;
pub const SO_BSDCOMPAT: u32 = 14;
pub const SO_REUSEPORT: u32 = 15;
pub const SO_PASSCRED: u32 = 16;
pub const SO_PEERCRED: u32 = 17;
pub const SO_RCVLOWAT: u32 = 18;
pub const SO_SNDLOWAT: u32 = 19;
pub const SO_RCVTIMEO: u32 = 20;
pub const SO_SNDTIMEO: u32 = 21;
pub const SO_SECURITY_AUTHENTICATION: u32 = 22;
pub const SO_SECURITY_ENCRYPTION_TRANSPORT: u32 = 23;
pub const SO_SECURITY_ENCRYPTION_NETWORK: u32 = 24;
pub const SO_BINDTODEVICE: u32 = 25;
pub const SO_ATTACH_FILTER: u32 = 26;
pub const SO_DETACH_FILTER: u32 = 27;
pub const SO_GET_FILTER: u32 = 26;
pub const SO_PEERNAME: u32 = 28;
pub const SO_TIMESTAMP: u32 = 29;
pub const SCM_TIMESTAMP: u32 = 29;
pub const SO_ACCEPTCONN: u32 = 30;
pub const SO_PEERSEC: u32 = 31;
pub const SO_PASSSEC: u32 = 34;
pub const SO_TIMESTAMPNS: u32 = 35;
pub const SCM_TIMESTAMPNS: u32 = 35;
pub const SO_MARK: u32 = 36;
pub const SO_TIMESTAMPING: u32 = 37;
pub const SCM_TIMESTAMPING: u32 = 37;
pub const SO_PROTOCOL: u32 = 38;
pub const SO_DOMAIN: u32 = 39;
pub const SO_RXQ_OVFL: u32 = 40;
pub const SO_WIFI_STATUS: u32 = 41;
pub const SCM_WIFI_STATUS: u32 = 41;
pub const SO_PEEK_OFF: u32 = 42;
pub const SO_NOFCS: u32 = 43;
pub const SO_LOCK_FILTER: u32 = 44;
pub const SO_SELECT_ERR_QUEUE: u32 = 45;
pub const SO_BUSY_POLL: u32 = 46;
pub const SO_MAX_PACING_RATE: u32 = 47;
pub const SO_BPF_EXTENSIONS: u32 = 48;
pub const SO_INCOMING_CPU: u32 = 49;
pub const SO_ATTACH_BPF: u32 = 50;
pub const SO_DETACH_BPF: u32 = 27;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _SYS_WAIT_H: u32 = 1;
pub const _SIGSET_H_fns: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGBUS: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGUSR1: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGUSR2: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGSTKFLT: u32 = 16;
pub const SIGCHLD: u32 = 17;
pub const SIGCONT: u32 = 18;
pub const SIGSTOP: u32 = 19;
pub const SIGTSTP: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGURG: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGIO: u32 = 29;
pub const SIGPWR: u32 = 30;
pub const SIGSYS: u32 = 31;
pub const SIGUNUSED: u32 = 31;
pub const _NSIG: u32 = 65;
pub const __SIGRTMIN: u32 = 32;
pub const __SIGRTMAX: u32 = 64;
pub const __have_sigval_t: u32 = 1;
pub const __have_siginfo_t: u32 = 1;
pub const __SI_MAX_SIZE: u32 = 128;
pub const __have_sigevent_t: u32 = 1;
pub const __SIGEV_MAX_SIZE: u32 = 64;
pub const NSIG: u32 = 65;
pub const SA_NOCLDSTOP: u32 = 1;
pub const SA_NOCLDWAIT: u32 = 2;
pub const SA_SIGINFO: u32 = 4;
pub const SA_ONSTACK: u32 = 134217728;
pub const SA_RESTART: u32 = 268435456;
pub const SA_NODEFER: u32 = 1073741824;
pub const SA_RESETHAND: u32 = 2147483648;
pub const SA_INTERRUPT: u32 = 536870912;
pub const SA_NOMASK: u32 = 1073741824;
pub const SA_ONESHOT: u32 = 2147483648;
pub const SA_STACK: u32 = 134217728;
pub const SIG_BLOCK: u32 = 0;
pub const SIG_UNBLOCK: u32 = 1;
pub const SIG_SETMASK: u32 = 2;
pub const _BITS_SIGCONTEXT_H: u32 = 1;
pub const FP_XSTATE_MAGIC1: u32 = 1179670611;
pub const FP_XSTATE_MAGIC2: u32 = 1179670597;
pub const MINSIGSTKSZ: u32 = 2048;
pub const SIGSTKSZ: u32 = 8192;
pub const _SYS_UCONTEXT_H: u32 = 1;
pub const NGREG: u32 = 23;
pub const _BITS_SIGTHREAD_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const WCOREFLAG: u32 = 128;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const APR_HAVE_SHMEM_MMAP_TMP: u32 = 1;
pub const APR_HAVE_SHMEM_MMAP_SHM: u32 = 1;
pub const APR_HAVE_SHMEM_MMAP_ZERO: u32 = 1;
pub const APR_HAVE_SHMEM_SHMGET_ANON: u32 = 1;
pub const APR_HAVE_SHMEM_SHMGET: u32 = 1;
pub const APR_HAVE_SHMEM_MMAP_ANON: u32 = 1;
pub const APR_HAVE_SHMEM_BEOS: u32 = 0;
pub const APR_USE_SHMEM_MMAP_TMP: u32 = 0;
pub const APR_USE_SHMEM_MMAP_SHM: u32 = 0;
pub const APR_USE_SHMEM_MMAP_ZERO: u32 = 0;
pub const APR_USE_SHMEM_SHMGET_ANON: u32 = 0;
pub const APR_USE_SHMEM_SHMGET: u32 = 1;
pub const APR_USE_SHMEM_MMAP_ANON: u32 = 1;
pub const APR_USE_SHMEM_BEOS: u32 = 0;
pub const APR_USE_FLOCK_SERIALIZE: u32 = 0;
pub const APR_USE_SYSVSEM_SERIALIZE: u32 = 1;
pub const APR_USE_POSIXSEM_SERIALIZE: u32 = 0;
pub const APR_USE_FCNTL_SERIALIZE: u32 = 0;
pub const APR_USE_PROC_PTHREAD_SERIALIZE: u32 = 0;
pub const APR_USE_PTHREAD_SERIALIZE: u32 = 1;
pub const APR_HAS_FLOCK_SERIALIZE: u32 = 1;
pub const APR_HAS_SYSVSEM_SERIALIZE: u32 = 1;
pub const APR_HAS_POSIXSEM_SERIALIZE: u32 = 1;
pub const APR_HAS_FCNTL_SERIALIZE: u32 = 1;
pub const APR_HAS_PROC_PTHREAD_SERIALIZE: u32 = 1;
pub const APR_PROCESS_LOCK_IS_GLOBAL: u32 = 0;
pub const APR_HAVE_CORKABLE_TCP: u32 = 1;
pub const APR_HAVE_GETRLIMIT: u32 = 1;
pub const APR_HAVE_IN_ADDR: u32 = 1;
pub const APR_HAVE_INET_ADDR: u32 = 1;
pub const APR_HAVE_INET_NETWORK: u32 = 1;
pub const APR_HAVE_IPV6: u32 = 1;
pub const APR_HAVE_MEMMOVE: u32 = 1;
pub const APR_HAVE_SETRLIMIT: u32 = 1;
pub const APR_HAVE_SIGACTION: u32 = 1;
pub const APR_HAVE_SIGSUSPEND: u32 = 1;
pub const APR_HAVE_SIGWAIT: u32 = 1;
pub const APR_HAVE_SA_STORAGE: u32 = 1;
pub const APR_HAVE_STRCASECMP: u32 = 1;
pub const APR_HAVE_STRDUP: u32 = 1;
pub const APR_HAVE_STRICMP: u32 = 0;
pub const APR_HAVE_STRNCASECMP: u32 = 1;
pub const APR_HAVE_STRNICMP: u32 = 0;
pub const APR_HAVE_STRSTR: u32 = 1;
pub const APR_HAVE_MEMCHR: u32 = 1;
pub const APR_HAVE_STRUCT_RLIMIT: u32 = 1;
pub const APR_HAVE_UNION_SEMUN: u32 = 0;
pub const APR_HAVE_SCTP: u32 = 1;
pub const APR_HAVE_IOVEC: u32 = 1;
pub const APR_HAS_SHARED_MEMORY: u32 = 1;
pub const APR_HAS_THREADS: u32 = 1;
pub const APR_HAS_SENDFILE: u32 = 1;
pub const APR_HAS_MMAP: u32 = 1;
pub const APR_HAS_FORK: u32 = 1;
pub const APR_HAS_RANDOM: u32 = 1;
pub const APR_HAS_OTHER_CHILD: u32 = 1;
pub const APR_HAS_DSO: u32 = 1;
pub const APR_HAS_SO_ACCEPTFILTER: u32 = 0;
pub const APR_HAS_UNICODE_FS: u32 = 0;
pub const APR_HAS_PROC_INVOKED: u32 = 0;
pub const APR_HAS_USER: u32 = 1;
pub const APR_HAS_LARGE_FILES: u32 = 0;
pub const APR_HAS_XTHREAD_FILES: u32 = 0;
pub const APR_HAS_OS_UUID: u32 = 1;
pub const APR_PROCATTR_USER_SET_REQUIRES_PASSWORD: u32 = 0;
pub const APR_FILES_AS_SOCKETS: u32 = 1;
pub const APR_CHARSET_EBCDIC: u32 = 0;
pub const APR_TCP_NODELAY_INHERITED: u32 = 1;
pub const APR_O_NONBLOCK_INHERITED: u32 = 0;
pub const APR_SIZEOF_VOIDP: u32 = 8;
pub const APR_IS_BIGENDIAN: u32 = 0;
pub const APR_INT16_MIN: i32 = -32768;
pub const APR_INT16_MAX: u32 = 32767;
pub const APR_UINT16_MAX: u32 = 65535;
pub const APR_INT32_MIN: i32 = -2147483648;
pub const APR_INT32_MAX: u32 = 2147483647;
pub const APR_UINT32_MAX: u32 = 4294967295;
pub const APR_SSIZE_T_FMT: &'static [u8; 3usize] = b"ld\0";
pub const APR_SIZE_T_FMT: &'static [u8; 3usize] = b"lu\0";
pub const APR_OFF_T_FMT: &'static [u8; 3usize] = b"ld\0";
pub const APR_PID_T_FMT: &'static [u8; 2usize] = b"d\0";
pub const APR_INT64_T_FMT: &'static [u8; 3usize] = b"ld\0";
pub const APR_UINT64_T_FMT: &'static [u8; 3usize] = b"lu\0";
pub const APR_UINT64_T_HEX_FMT: &'static [u8; 3usize] = b"lx\0";
pub const APR_PROC_MUTEX_IS_GLOBAL: u32 = 0;
pub const APR_EOL_STR: &'static [u8; 2usize] = b"\n\0";
pub const APR_PATH_MAX: u32 = 4096;
pub const APR_DSOPATH: &'static [u8; 16usize] = b"LD_LIBRARY_PATH\0";
pub const APU_HAVE_SDBM: u32 = 1;
pub const APU_HAVE_GDBM: u32 = 0;
pub const APU_HAVE_NDBM: u32 = 0;
pub const APU_HAVE_DB: u32 = 0;
pub const APU_HAVE_PGSQL: u32 = 0;
pub const APU_HAVE_MYSQL: u32 = 0;
pub const APU_HAVE_SQLITE3: u32 = 0;
pub const APU_HAVE_SQLITE2: u32 = 0;
pub const APU_HAVE_ORACLE: u32 = 0;
pub const APU_HAVE_FREETDS: u32 = 0;
pub const APU_HAVE_ODBC: u32 = 0;
pub const APU_HAVE_CRYPTO: u32 = 0;
pub const APU_HAVE_APR_ICONV: u32 = 0;
pub const APU_HAVE_ICONV: u32 = 1;
pub const _ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const APR_OS_START_ERROR: u32 = 20000;
pub const APR_OS_ERRSPACE_SIZE: u32 = 50000;
pub const APR_UTIL_ERRSPACE_SIZE: u32 = 20000;
pub const APR_OS_START_STATUS: u32 = 70000;
pub const APR_UTIL_START_STATUS: u32 = 100000;
pub const APR_OS_START_USERERR: u32 = 120000;
pub const APR_OS_START_USEERR: u32 = 120000;
pub const APR_OS_START_CANONERR: u32 = 620000;
pub const APR_OS_START_EAIERR: u32 = 670000;
pub const APR_OS_START_SYSERR: u32 = 720000;
pub const APR_SUCCESS: u32 = 0;
pub const APR_ENOSTAT: u32 = 20001;
pub const APR_ENOPOOL: u32 = 20002;
pub const APR_EBADDATE: u32 = 20004;
pub const APR_EINVALSOCK: u32 = 20005;
pub const APR_ENOPROC: u32 = 20006;
pub const APR_ENOTIME: u32 = 20007;
pub const APR_ENODIR: u32 = 20008;
pub const APR_ENOLOCK: u32 = 20009;
pub const APR_ENOPOLL: u32 = 20010;
pub const APR_ENOSOCKET: u32 = 20011;
pub const APR_ENOTHREAD: u32 = 20012;
pub const APR_ENOTHDKEY: u32 = 20013;
pub const APR_EGENERAL: u32 = 20014;
pub const APR_ENOSHMAVAIL: u32 = 20015;
pub const APR_EBADIP: u32 = 20016;
pub const APR_EBADMASK: u32 = 20017;
pub const APR_EDSOOPEN: u32 = 20019;
pub const APR_EABSOLUTE: u32 = 20020;
pub const APR_ERELATIVE: u32 = 20021;
pub const APR_EINCOMPLETE: u32 = 20022;
pub const APR_EABOVEROOT: u32 = 20023;
pub const APR_EBADPATH: u32 = 20024;
pub const APR_EPATHWILD: u32 = 20025;
pub const APR_ESYMNOTFOUND: u32 = 20026;
pub const APR_EPROC_UNKNOWN: u32 = 20027;
pub const APR_ENOTENOUGHENTROPY: u32 = 20028;
pub const APR_INCHILD: u32 = 70001;
pub const APR_INPARENT: u32 = 70002;
pub const APR_DETACH: u32 = 70003;
pub const APR_NOTDETACH: u32 = 70004;
pub const APR_CHILD_DONE: u32 = 70005;
pub const APR_CHILD_NOTDONE: u32 = 70006;
pub const APR_TIMEUP: u32 = 70007;
pub const APR_INCOMPLETE: u32 = 70008;
pub const APR_BADCH: u32 = 70012;
pub const APR_BADARG: u32 = 70013;
pub const APR_EOF: u32 = 70014;
pub const APR_NOTFOUND: u32 = 70015;
pub const APR_ANONYMOUS: u32 = 70019;
pub const APR_FILEBASED: u32 = 70020;
pub const APR_KEYBASED: u32 = 70021;
pub const APR_EINIT: u32 = 70022;
pub const APR_ENOTIMPL: u32 = 70023;
pub const APR_EMISMATCH: u32 = 70024;
pub const APR_EBUSY: u32 = 70025;
pub const APR_EACCES: u32 = 13;
pub const APR_EEXIST: u32 = 17;
pub const APR_ENAMETOOLONG: u32 = 36;
pub const APR_ENOENT: u32 = 2;
pub const APR_ENOTDIR: u32 = 20;
pub const APR_ENOSPC: u32 = 28;
pub const APR_ENOMEM: u32 = 12;
pub const APR_EMFILE: u32 = 24;
pub const APR_ENFILE: u32 = 23;
pub const APR_EBADF: u32 = 9;
pub const APR_EINVAL: u32 = 22;
pub const APR_ESPIPE: u32 = 29;
pub const APR_EAGAIN: u32 = 11;
pub const APR_EINTR: u32 = 4;
pub const APR_ENOTSOCK: u32 = 88;
pub const APR_ECONNREFUSED: u32 = 111;
pub const APR_EINPROGRESS: u32 = 115;
pub const APR_ECONNABORTED: u32 = 103;
pub const APR_ECONNRESET: u32 = 104;
pub const APR_ETIMEDOUT: u32 = 110;
pub const APR_EHOSTUNREACH: u32 = 113;
pub const APR_ENETUNREACH: u32 = 101;
pub const APR_EFTYPE: u32 = 620023;
pub const APR_EPIPE: u32 = 32;
pub const APR_EXDEV: u32 = 18;
pub const APR_ENOTEMPTY: u32 = 39;
pub const APR_EAFNOSUPPORT: u32 = 97;
pub const FALSE: u32 = 0;
pub const APR_ASCII_BLANK: u8 = 32u8;
pub const APR_ASCII_CR: u8 = 13u8;
pub const APR_ASCII_LF: u8 = 10u8;
pub const APR_ASCII_TAB: u8 = 9u8;
pub const _STRING_H: u32 = 1;
pub const _XLOCALE_H: u32 = 1;
pub const APR_POOL_DEBUG: u32 = 0;
pub const APR_ALLOCATOR_MAX_FREE_UNLIMITED: u32 = 0;
pub const APR_THREAD_MUTEX_DEFAULT: u32 = 0;
pub const APR_THREAD_MUTEX_NESTED: u32 = 1;
pub const APR_THREAD_MUTEX_UNNESTED: u32 = 2;
pub const __GNUC_VA_LIST: u32 = 1;
pub const APR_OVERLAP_TABLES_SET: u32 = 0;
pub const APR_OVERLAP_TABLES_MERGE: u32 = 1;
pub const APR_HOOK_REALLY_FIRST: i32 = -10;
pub const APR_HOOK_FIRST: u32 = 0;
pub const APR_HOOK_MIDDLE: u32 = 10;
pub const APR_HOOK_LAST: u32 = 20;
pub const APR_HOOK_REALLY_LAST: u32 = 30;
pub const PLATFORM: &'static [u8; 5usize] = b"Unix\0";
pub const AP_NEED_SET_MUTEX_PERMS: u32 = 1;
pub const APACHE_MPM_DIR: &'static [u8; 19usize] = b"server/mpm/prefork\0";
pub const AP_ENABLE_V4_MAPPED: u32 = 1;
pub const AP_NONBLOCK_WHEN_MULTI_LISTEN: u32 = 1;
pub const AP_TYPES_CONFIG_FILE: &'static [u8; 16usize] = b"conf/mime.types\0";
pub const AP_USING_AUTOCONF: u32 = 1;
pub const HAVE_GETGRNAM: u32 = 1;
pub const HAVE_GETPGID: u32 = 1;
pub const HAVE_GETPWNAM: u32 = 1;
pub const HAVE_GMTOFF: u32 = 1;
pub const HAVE_GRP_H: u32 = 1;
pub const HAVE_INITGROUPS: u32 = 1;
pub const HAVE_INTTYPES_H: u32 = 1;
pub const HAVE_KILLPG: u32 = 1;
pub const HAVE_LIMITS_H: u32 = 1;
pub const HAVE_MEMORY_H: u32 = 1;
pub const HAVE_PRCTL: u32 = 1;
pub const HAVE_PWD_H: u32 = 1;
pub const HAVE_SETSID: u32 = 1;
pub const HAVE_STDINT_H: u32 = 1;
pub const HAVE_STDLIB_H: u32 = 1;
pub const HAVE_STRINGS_H: u32 = 1;
pub const HAVE_STRING_H: u32 = 1;
pub const HAVE_SYSLOG: u32 = 1;
pub const HAVE_SYS_IPC_H: u32 = 1;
pub const HAVE_SYS_PRCTL_H: u32 = 1;
pub const HAVE_SYS_RESOURCE_H: u32 = 1;
pub const HAVE_SYS_SEM_H: u32 = 1;
pub const HAVE_SYS_SOCKET_H: u32 = 1;
pub const HAVE_SYS_STAT_H: u32 = 1;
pub const HAVE_SYS_TIMES_H: u32 = 1;
pub const HAVE_SYS_TIME_H: u32 = 1;
pub const HAVE_SYS_TYPES_H: u32 = 1;
pub const HAVE_SYS_WAIT_H: u32 = 1;
pub const HAVE_TIMEGM: u32 = 1;
pub const HAVE_TIMES: u32 = 1;
pub const HAVE_UNISTD_H: u32 = 1;
pub const HTTPD_ROOT: &'static [u8; 25usize] = b"/usr/local/apache-2.2.34\0";
pub const PACKAGE_BUGREPORT: &'static [u8; 1usize] = b"\0";
pub const PACKAGE_NAME: &'static [u8; 1usize] = b"\0";
pub const PACKAGE_STRING: &'static [u8; 1usize] = b"\0";
pub const PACKAGE_TARNAME: &'static [u8; 1usize] = b"\0";
pub const PACKAGE_URL: &'static [u8; 1usize] = b"\0";
pub const PACKAGE_VERSION: &'static [u8; 1usize] = b"\0";
pub const SERVER_CONFIG_FILE: &'static [u8; 16usize] = b"conf/httpd.conf\0";
pub const SINGLE_LISTEN_UNSERIALIZED_ACCEPT: u32 = 1;
pub const STDC_HEADERS: u32 = 1;
pub const _ALL_SOURCE: u32 = 1;
pub const _GNU_SOURCE: u32 = 1;
pub const _POSIX_PTHREAD_SEMANTICS: u32 = 1;
pub const _TANDEM_SOURCE: u32 = 1;
pub const __EXTENSIONS__: u32 = 1;
pub const DEFAULT_PREFIX: &'static [u8; 25usize] = b"/usr/local/apache-2.2.34\0";
pub const DEFAULT_EXP_EXEC_PREFIX: &'static [u8; 25usize] = b"/usr/local/apache-2.2.34\0";
pub const DEFAULT_REL_EXEC_PREFIX: &'static [u8; 1usize] = b"\0";
pub const DEFAULT_EXP_BINDIR: &'static [u8; 29usize] = b"/usr/local/apache-2.2.34/bin\0";
pub const DEFAULT_REL_BINDIR: &'static [u8; 4usize] = b"bin\0";
pub const DEFAULT_EXP_SBINDIR: &'static [u8; 29usize] = b"/usr/local/apache-2.2.34/bin\0";
pub const DEFAULT_REL_SBINDIR: &'static [u8; 4usize] = b"bin\0";
pub const DEFAULT_EXP_LIBEXECDIR: &'static [u8; 33usize] = b"/usr/local/apache-2.2.34/modules\0";
pub const DEFAULT_REL_LIBEXECDIR: &'static [u8; 8usize] = b"modules\0";
pub const DEFAULT_EXP_MANDIR: &'static [u8; 29usize] = b"/usr/local/apache-2.2.34/man\0";
pub const DEFAULT_REL_MANDIR: &'static [u8; 4usize] = b"man\0";
pub const DEFAULT_EXP_SYSCONFDIR: &'static [u8; 30usize] = b"/usr/local/apache-2.2.34/conf\0";
pub const DEFAULT_REL_SYSCONFDIR: &'static [u8; 5usize] = b"conf\0";
pub const DEFAULT_EXP_DATADIR: &'static [u8; 25usize] = b"/usr/local/apache-2.2.34\0";
pub const DEFAULT_REL_DATADIR: &'static [u8; 1usize] = b"\0";
pub const DEFAULT_EXP_INSTALLBUILDDIR: &'static [u8; 31usize] = b"/usr/local/apache-2.2.34/build\0";
pub const DEFAULT_REL_INSTALLBUILDDIR: &'static [u8; 6usize] = b"build\0";
pub const DEFAULT_EXP_ERRORDIR: &'static [u8; 31usize] = b"/usr/local/apache-2.2.34/error\0";
pub const DEFAULT_REL_ERRORDIR: &'static [u8; 6usize] = b"error\0";
pub const DEFAULT_EXP_ICONSDIR: &'static [u8; 31usize] = b"/usr/local/apache-2.2.34/icons\0";
pub const DEFAULT_REL_ICONSDIR: &'static [u8; 6usize] = b"icons\0";
pub const DEFAULT_EXP_HTDOCSDIR: &'static [u8; 32usize] = b"/usr/local/apache-2.2.34/htdocs\0";
pub const DEFAULT_REL_HTDOCSDIR: &'static [u8; 7usize] = b"htdocs\0";
pub const DEFAULT_EXP_MANUALDIR: &'static [u8; 32usize] = b"/usr/local/apache-2.2.34/manual\0";
pub const DEFAULT_REL_MANUALDIR: &'static [u8; 7usize] = b"manual\0";
pub const DEFAULT_EXP_CGIDIR: &'static [u8; 33usize] = b"/usr/local/apache-2.2.34/cgi-bin\0";
pub const DEFAULT_REL_CGIDIR: &'static [u8; 8usize] = b"cgi-bin\0";
pub const DEFAULT_EXP_INCLUDEDIR: &'static [u8; 33usize] = b"/usr/local/apache-2.2.34/include\0";
pub const DEFAULT_REL_INCLUDEDIR: &'static [u8; 8usize] = b"include\0";
pub const DEFAULT_EXP_LOCALSTATEDIR: &'static [u8; 25usize] = b"/usr/local/apache-2.2.34\0";
pub const DEFAULT_REL_LOCALSTATEDIR: &'static [u8; 1usize] = b"\0";
pub const DEFAULT_EXP_RUNTIMEDIR: &'static [u8; 30usize] = b"/usr/local/apache-2.2.34/logs\0";
pub const DEFAULT_REL_RUNTIMEDIR: &'static [u8; 5usize] = b"logs\0";
pub const DEFAULT_EXP_LOGFILEDIR: &'static [u8; 30usize] = b"/usr/local/apache-2.2.34/logs\0";
pub const DEFAULT_REL_LOGFILEDIR: &'static [u8; 5usize] = b"logs\0";
pub const DEFAULT_EXP_PROXYCACHEDIR: &'static [u8; 31usize] = b"/usr/local/apache-2.2.34/proxy\0";
pub const DEFAULT_REL_PROXYCACHEDIR: &'static [u8; 6usize] = b"proxy\0";

//pub const MODULE_MAGIC_COOKIE: u32 = 1095774770;
//pub const MODULE_MAGIC_NUMBER_MAJOR: u32 = 20051115;
//pub const MODULE_MAGIC_NUMBER_MINOR: u32 = 43;
pub const MODULE_MAGIC_NUMBER: u32 = 20051115;

pub const AP_SERVER_COPYRIGHT: &'static [u8; 47usize] = b"Copyright 2017 The Apache Software Foundation.\0";
pub const AP_SERVER_BASEVENDOR: &'static [u8; 27usize] = b"Apache Software Foundation\0";
pub const AP_SERVER_BASEPROJECT: &'static [u8; 19usize] = b"Apache HTTP Server\0";
pub const AP_SERVER_BASEPRODUCT: &'static [u8; 7usize] = b"Apache\0";
pub const AP_SERVER_MAJORVERSION_NUMBER: u32 = 2;
pub const AP_SERVER_MINORVERSION_NUMBER: u32 = 2;
pub const AP_SERVER_PATCHLEVEL_NUMBER: u32 = 34;
pub const AP_SERVER_DEVBUILD_BOOLEAN: u32 = 0;
pub const AP_SERVER_ADD_STRING: &'static [u8; 1usize] = b"\0";
pub const APR_TIME_T_FMT: &'static [u8; 3usize] = b"ld\0";
pub const APR_RFC822_DATE_LEN: u32 = 30;
pub const APR_CTIME_LEN: u32 = 25;
pub const APR_FPROT_USETID: u32 = 32768;
pub const APR_FPROT_UREAD: u32 = 1024;
pub const APR_FPROT_UWRITE: u32 = 512;
pub const APR_FPROT_UEXECUTE: u32 = 256;
pub const APR_FPROT_GSETID: u32 = 16384;
pub const APR_FPROT_GREAD: u32 = 64;
pub const APR_FPROT_GWRITE: u32 = 32;
pub const APR_FPROT_GEXECUTE: u32 = 16;
pub const APR_FPROT_WSTICKY: u32 = 8192;
pub const APR_FPROT_WREAD: u32 = 4;
pub const APR_FPROT_WWRITE: u32 = 2;
pub const APR_FPROT_WEXECUTE: u32 = 1;
pub const APR_FPROT_OS_DEFAULT: u32 = 4095;
pub const APR_FPROT_FILE_SOURCE_PERMS: u32 = 4096;
pub const APR_USETID: u32 = 32768;
pub const APR_UREAD: u32 = 1024;
pub const APR_UWRITE: u32 = 512;
pub const APR_UEXECUTE: u32 = 256;
pub const APR_GSETID: u32 = 16384;
pub const APR_GREAD: u32 = 64;
pub const APR_GWRITE: u32 = 32;
pub const APR_GEXECUTE: u32 = 16;
pub const APR_WSTICKY: u32 = 8192;
pub const APR_WREAD: u32 = 4;
pub const APR_WWRITE: u32 = 2;
pub const APR_WEXECUTE: u32 = 1;
pub const APR_OS_DEFAULT: u32 = 4095;
pub const APR_FILE_SOURCE_PERMS: u32 = 4096;
pub const APR_FINFO_LINK: u32 = 1;
pub const APR_FINFO_MTIME: u32 = 16;
pub const APR_FINFO_CTIME: u32 = 32;
pub const APR_FINFO_ATIME: u32 = 64;
pub const APR_FINFO_SIZE: u32 = 256;
pub const APR_FINFO_CSIZE: u32 = 512;
pub const APR_FINFO_DEV: u32 = 4096;
pub const APR_FINFO_INODE: u32 = 8192;
pub const APR_FINFO_NLINK: u32 = 16384;
pub const APR_FINFO_TYPE: u32 = 32768;
pub const APR_FINFO_USER: u32 = 65536;
pub const APR_FINFO_GROUP: u32 = 131072;
pub const APR_FINFO_UPROT: u32 = 1048576;
pub const APR_FINFO_GPROT: u32 = 2097152;
pub const APR_FINFO_WPROT: u32 = 4194304;
pub const APR_FINFO_ICASE: u32 = 16777216;
pub const APR_FINFO_NAME: u32 = 33554432;
pub const APR_FINFO_MIN: u32 = 33136;
pub const APR_FINFO_IDENT: u32 = 12288;
pub const APR_FINFO_OWNER: u32 = 196608;
pub const APR_FINFO_PROT: u32 = 7340032;
pub const APR_FINFO_NORM: u32 = 7582064;
pub const APR_FINFO_DIRENT: u32 = 33554432;
pub const APR_FILEPATH_NOTABOVEROOT: u32 = 1;
pub const APR_FILEPATH_SECUREROOTTEST: u32 = 2;
pub const APR_FILEPATH_SECUREROOT: u32 = 3;
pub const APR_FILEPATH_NOTRELATIVE: u32 = 4;
pub const APR_FILEPATH_NOTABSOLUTE: u32 = 8;
pub const APR_FILEPATH_NATIVE: u32 = 16;
pub const APR_FILEPATH_TRUENAME: u32 = 32;
pub const APR_FILEPATH_ENCODING_UNKNOWN: u32 = 0;
pub const APR_FILEPATH_ENCODING_LOCALE: u32 = 1;
pub const APR_FILEPATH_ENCODING_UTF8: u32 = 2;
pub const _STDIO_H: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const _G_config_h: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _G_HAVE_MMAP: u32 = 1;
pub const _G_HAVE_MREMAP: u32 = 1;
pub const _G_IO_IO_FILE_VERSION: u32 = 131073;
pub const _G_BUFSIZ: u32 = 8192;
pub const _IO_BUFSIZ: u32 = 8192;
pub const _IO_UNIFIED_JUMPTABLES: u32 = 1;
pub const EOF: i32 = -1;
pub const _IOS_INPUT: u32 = 1;
pub const _IOS_OUTPUT: u32 = 2;
pub const _IOS_ATEND: u32 = 4;
pub const _IOS_APPEND: u32 = 8;
pub const _IOS_TRUNC: u32 = 16;
pub const _IOS_NOCREATE: u32 = 32;
pub const _IOS_NOREPLACE: u32 = 64;
pub const _IOS_BIN: u32 = 128;
pub const _IO_MAGIC: u32 = 4222418944;
pub const _OLD_STDIO_MAGIC: u32 = 4206624768;
pub const _IO_MAGIC_MASK: u32 = 4294901760;
pub const _IO_USER_BUF: u32 = 1;
pub const _IO_UNBUFFERED: u32 = 2;
pub const _IO_NO_READS: u32 = 4;
pub const _IO_NO_WRITES: u32 = 8;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_DELETE_DONT_CLOSE: u32 = 64;
pub const _IO_LINKED: u32 = 128;
pub const _IO_IN_BACKUP: u32 = 256;
pub const _IO_LINE_BUF: u32 = 512;
pub const _IO_TIED_PUT_GET: u32 = 1024;
pub const _IO_CURRENTLY_PUTTING: u32 = 2048;
pub const _IO_IS_APPENDING: u32 = 4096;
pub const _IO_IS_FILEBUF: u32 = 8192;
pub const _IO_BAD_SEEN: u32 = 16384;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IO_FLAGS2_MMAP: u32 = 1;
pub const _IO_FLAGS2_NOTCANCEL: u32 = 2;
pub const _IO_FLAGS2_USER_WBUF: u32 = 8;
pub const _IO_SKIPWS: u32 = 1;
pub const _IO_LEFT: u32 = 2;
pub const _IO_RIGHT: u32 = 4;
pub const _IO_INTERNAL: u32 = 8;
pub const _IO_DEC: u32 = 16;
pub const _IO_OCT: u32 = 32;
pub const _IO_HEX: u32 = 64;
pub const _IO_SHOWBASE: u32 = 128;
pub const _IO_SHOWPOINT: u32 = 256;
pub const _IO_UPPERCASE: u32 = 512;
pub const _IO_SHOWPOS: u32 = 1024;
pub const _IO_SCIENTIFIC: u32 = 2048;
pub const _IO_FIXED: u32 = 4096;
pub const _IO_UNITBUF: u32 = 8192;
pub const _IO_STDIO: u32 = 16384;
pub const _IO_DONT_CLOSE: u32 = 32768;
pub const _IO_BOOLALPHA: u32 = 65536;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const APR_FOPEN_READ: u32 = 1;
pub const APR_FOPEN_WRITE: u32 = 2;
pub const APR_FOPEN_CREATE: u32 = 4;
pub const APR_FOPEN_APPEND: u32 = 8;
pub const APR_FOPEN_TRUNCATE: u32 = 16;
pub const APR_FOPEN_BINARY: u32 = 32;
pub const APR_FOPEN_EXCL: u32 = 64;
pub const APR_FOPEN_BUFFERED: u32 = 128;
pub const APR_FOPEN_DELONCLOSE: u32 = 256;
pub const APR_FOPEN_XTHREAD: u32 = 512;
pub const APR_FOPEN_SHARELOCK: u32 = 1024;
pub const APR_FOPEN_NOCLEANUP: u32 = 2048;
pub const APR_FOPEN_SENDFILE_ENABLED: u32 = 4096;
pub const APR_FOPEN_LARGEFILE: u32 = 16384;
pub const APR_FOPEN_SPARSE: u32 = 32768;
pub const APR_FOPEN_NONBLOCK: u32 = 262144;
pub const APR_READ: u32 = 1;
pub const APR_WRITE: u32 = 2;
pub const APR_CREATE: u32 = 4;
pub const APR_APPEND: u32 = 8;
pub const APR_TRUNCATE: u32 = 16;
pub const APR_BINARY: u32 = 32;
pub const APR_EXCL: u32 = 64;
pub const APR_BUFFERED: u32 = 128;
pub const APR_DELONCLOSE: u32 = 256;
pub const APR_XTHREAD: u32 = 512;
pub const APR_SHARELOCK: u32 = 1024;
pub const APR_FILE_NOCLEANUP: u32 = 2048;
pub const APR_SENDFILE_ENABLED: u32 = 4096;
pub const APR_LARGEFILE: u32 = 16384;
pub const APR_SET: u32 = 0;
pub const APR_CUR: u32 = 1;
pub const APR_END: u32 = 2;
pub const APR_FILE_ATTR_READONLY: u32 = 1;
pub const APR_FILE_ATTR_EXECUTABLE: u32 = 2;
pub const APR_FILE_ATTR_HIDDEN: u32 = 4;
pub const APR_MAX_IOVEC_SIZE: u32 = 1024;
pub const APR_FLOCK_SHARED: u32 = 1;
pub const APR_FLOCK_EXCLUSIVE: u32 = 2;
pub const APR_FLOCK_TYPEMASK: u32 = 15;
pub const APR_FLOCK_NONBLOCK: u32 = 16;
pub const _NETINET_IN_H: u32 = 1;
pub const IP_OPTIONS: u32 = 4;
pub const IP_HDRINCL: u32 = 3;
pub const IP_TOS: u32 = 1;
pub const IP_TTL: u32 = 2;
pub const IP_RECVOPTS: u32 = 6;
pub const IP_RETOPTS: u32 = 7;
pub const IP_MULTICAST_IF: u32 = 32;
pub const IP_MULTICAST_TTL: u32 = 33;
pub const IP_MULTICAST_LOOP: u32 = 34;
pub const IP_ADD_MEMBERSHIP: u32 = 35;
pub const IP_DROP_MEMBERSHIP: u32 = 36;
pub const IP_UNBLOCK_SOURCE: u32 = 37;
pub const IP_BLOCK_SOURCE: u32 = 38;
pub const IP_ADD_SOURCE_MEMBERSHIP: u32 = 39;
pub const IP_DROP_SOURCE_MEMBERSHIP: u32 = 40;
pub const IP_MSFILTER: u32 = 41;
pub const MCAST_JOIN_GROUP: u32 = 42;
pub const MCAST_BLOCK_SOURCE: u32 = 43;
pub const MCAST_UNBLOCK_SOURCE: u32 = 44;
pub const MCAST_LEAVE_GROUP: u32 = 45;
pub const MCAST_JOIN_SOURCE_GROUP: u32 = 46;
pub const MCAST_LEAVE_SOURCE_GROUP: u32 = 47;
pub const MCAST_MSFILTER: u32 = 48;
pub const IP_MULTICAST_ALL: u32 = 49;
pub const IP_UNICAST_IF: u32 = 50;
pub const MCAST_EXCLUDE: u32 = 0;
pub const MCAST_INCLUDE: u32 = 1;
pub const IP_ROUTER_ALERT: u32 = 5;
pub const IP_PKTINFO: u32 = 8;
pub const IP_PKTOPTIONS: u32 = 9;
pub const IP_PMTUDISC: u32 = 10;
pub const IP_MTU_DISCOVER: u32 = 10;
pub const IP_RECVERR: u32 = 11;
pub const IP_RECVTTL: u32 = 12;
pub const IP_RECVTOS: u32 = 13;
pub const IP_MTU: u32 = 14;
pub const IP_FREEBIND: u32 = 15;
pub const IP_IPSEC_POLICY: u32 = 16;
pub const IP_XFRM_POLICY: u32 = 17;
pub const IP_PASSSEC: u32 = 18;
pub const IP_TRANSPARENT: u32 = 19;
pub const IP_ORIGDSTADDR: u32 = 20;
pub const IP_RECVORIGDSTADDR: u32 = 20;
pub const IP_MINTTL: u32 = 21;
pub const IP_NODEFRAG: u32 = 22;
pub const IP_CHECKSUM: u32 = 23;
pub const IP_BIND_ADDRESS_NO_PORT: u32 = 24;
pub const IP_PMTUDISC_DONT: u32 = 0;
pub const IP_PMTUDISC_WANT: u32 = 1;
pub const IP_PMTUDISC_DO: u32 = 2;
pub const IP_PMTUDISC_PROBE: u32 = 3;
pub const IP_PMTUDISC_INTERFACE: u32 = 4;
pub const IP_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IP: u32 = 0;
pub const IP_DEFAULT_MULTICAST_TTL: u32 = 1;
pub const IP_DEFAULT_MULTICAST_LOOP: u32 = 1;
pub const IP_MAX_MEMBERSHIPS: u32 = 20;
pub const IPV6_ADDRFORM: u32 = 1;
pub const IPV6_2292PKTINFO: u32 = 2;
pub const IPV6_2292HOPOPTS: u32 = 3;
pub const IPV6_2292DSTOPTS: u32 = 4;
pub const IPV6_2292RTHDR: u32 = 5;
pub const IPV6_2292PKTOPTIONS: u32 = 6;
pub const IPV6_CHECKSUM: u32 = 7;
pub const IPV6_2292HOPLIMIT: u32 = 8;
pub const IPV6_NEXTHOP: u32 = 9;
pub const IPV6_AUTHHDR: u32 = 10;
pub const IPV6_UNICAST_HOPS: u32 = 16;
pub const IPV6_MULTICAST_IF: u32 = 17;
pub const IPV6_MULTICAST_HOPS: u32 = 18;
pub const IPV6_MULTICAST_LOOP: u32 = 19;
pub const IPV6_JOIN_GROUP: u32 = 20;
pub const IPV6_LEAVE_GROUP: u32 = 21;
pub const IPV6_ROUTER_ALERT: u32 = 22;
pub const IPV6_MTU_DISCOVER: u32 = 23;
pub const IPV6_MTU: u32 = 24;
pub const IPV6_RECVERR: u32 = 25;
pub const IPV6_V6ONLY: u32 = 26;
pub const IPV6_JOIN_ANYCAST: u32 = 27;
pub const IPV6_LEAVE_ANYCAST: u32 = 28;
pub const IPV6_IPSEC_POLICY: u32 = 34;
pub const IPV6_XFRM_POLICY: u32 = 35;
pub const IPV6_RECVPKTINFO: u32 = 49;
pub const IPV6_PKTINFO: u32 = 50;
pub const IPV6_RECVHOPLIMIT: u32 = 51;
pub const IPV6_HOPLIMIT: u32 = 52;
pub const IPV6_RECVHOPOPTS: u32 = 53;
pub const IPV6_HOPOPTS: u32 = 54;
pub const IPV6_RTHDRDSTOPTS: u32 = 55;
pub const IPV6_RECVRTHDR: u32 = 56;
pub const IPV6_RTHDR: u32 = 57;
pub const IPV6_RECVDSTOPTS: u32 = 58;
pub const IPV6_DSTOPTS: u32 = 59;
pub const IPV6_RECVPATHMTU: u32 = 60;
pub const IPV6_PATHMTU: u32 = 61;
pub const IPV6_DONTFRAG: u32 = 62;
pub const IPV6_RECVTCLASS: u32 = 66;
pub const IPV6_TCLASS: u32 = 67;
pub const IPV6_ADD_MEMBERSHIP: u32 = 20;
pub const IPV6_DROP_MEMBERSHIP: u32 = 21;
pub const IPV6_RXHOPOPTS: u32 = 54;
pub const IPV6_RXDSTOPTS: u32 = 59;
pub const IPV6_PMTUDISC_DONT: u32 = 0;
pub const IPV6_PMTUDISC_WANT: u32 = 1;
pub const IPV6_PMTUDISC_DO: u32 = 2;
pub const IPV6_PMTUDISC_PROBE: u32 = 3;
pub const IPV6_PMTUDISC_INTERFACE: u32 = 4;
pub const IPV6_PMTUDISC_OMIT: u32 = 5;
pub const SOL_IPV6: u32 = 41;
pub const SOL_ICMPV6: u32 = 58;
pub const IPV6_RTHDR_LOOSE: u32 = 0;
pub const IPV6_RTHDR_STRICT: u32 = 1;
pub const IPV6_RTHDR_TYPE_0: u32 = 0;
pub const IN_CLASSA_NET: u32 = 4278190080;
pub const IN_CLASSA_NSHIFT: u32 = 24;
pub const IN_CLASSA_HOST: u32 = 16777215;
pub const IN_CLASSA_MAX: u32 = 128;
pub const IN_CLASSB_NET: u32 = 4294901760;
pub const IN_CLASSB_NSHIFT: u32 = 16;
pub const IN_CLASSB_HOST: u32 = 65535;
pub const IN_CLASSB_MAX: u32 = 65536;
pub const IN_CLASSC_NET: u32 = 4294967040;
pub const IN_CLASSC_NSHIFT: u32 = 8;
pub const IN_CLASSC_HOST: u32 = 255;
pub const IN_LOOPBACKNET: u32 = 127;
pub const INET_ADDRSTRLEN: u32 = 16;
pub const INET6_ADDRSTRLEN: u32 = 46;
pub const APR_MAX_SECS_TO_LINGER: u32 = 30;
pub const APRMAXHOSTLEN: u32 = 256;
pub const APR_ANYADDR: &'static [u8; 8usize] = b"0.0.0.0\0";
pub const APR_SO_LINGER: u32 = 1;
pub const APR_SO_KEEPALIVE: u32 = 2;
pub const APR_SO_DEBUG: u32 = 4;
pub const APR_SO_NONBLOCK: u32 = 8;
pub const APR_SO_REUSEADDR: u32 = 16;
pub const APR_SO_SNDBUF: u32 = 64;
pub const APR_SO_RCVBUF: u32 = 128;
pub const APR_SO_DISCONNECTED: u32 = 256;
pub const APR_TCP_NODELAY: u32 = 512;
pub const APR_TCP_NOPUSH: u32 = 1024;
pub const APR_RESET_NODELAY: u32 = 2048;
pub const APR_INCOMPLETE_READ: u32 = 4096;
pub const APR_INCOMPLETE_WRITE: u32 = 8192;
pub const APR_IPV6_V6ONLY: u32 = 16384;
pub const APR_TCP_DEFER_ACCEPT: u32 = 32768;
pub const APR_SO_BROADCAST: u32 = 65536;
pub const APR_IPV4_ADDR_OK: u32 = 1;
pub const APR_IPV6_ADDR_OK: u32 = 2;
pub const APR_INET: u32 = 2;
pub const APR_UNSPEC: u32 = 0;
pub const APR_INET6: u32 = 10;
pub const APR_PROTO_TCP: u32 = 6;
pub const APR_PROTO_UDP: u32 = 17;
pub const APR_PROTO_SCTP: u32 = 132;
pub const APR_SENDFILE_DISCONNECT_SOCKET: u32 = 1;
pub const APR_MMAP_READ: u32 = 1;
pub const APR_MMAP_WRITE: u32 = 2;
pub const APR_MMAP_THRESHOLD: u32 = 1;
pub const APR_MMAP_LIMIT: u32 = 4194304;
pub const APR_BUCKET_BUFF_SIZE: u32 = 8000;
pub const APR_POLLIN: u32 = 1;
pub const APR_POLLPRI: u32 = 2;
pub const APR_POLLOUT: u32 = 4;
pub const APR_POLLERR: u32 = 16;
pub const APR_POLLHUP: u32 = 32;
pub const APR_POLLNVAL: u32 = 64;
pub const APR_POLLSET_THREADSAFE: u32 = 1;
pub const APR_POLLSET_NOCOPY: u32 = 2;
pub const APR_POLLSET_WAKEABLE: u32 = 4;
pub const APR_POLLSET_NODEFAULT: u32 = 16;
pub const AP_REG_ICASE: u32 = 1;
pub const AP_REG_NEWLINE: u32 = 2;
pub const AP_REG_NOTBOL: u32 = 4;
pub const AP_REG_NOTEOL: u32 = 8;
pub const AP_REG_EXTENDED: u32 = 0;
pub const AP_REG_NOSUB: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _ALLOCA_H: u32 = 1;
pub const AP_SERVER_PROTOCOL: &'static [u8; 9usize] = b"HTTP/1.1\0";
pub const AP_DEFAULT_INDEX: &'static [u8; 11usize] = b"index.html\0";
pub const DEFAULT_CONTENT_TYPE: &'static [u8; 11usize] = b"text/plain\0";
pub const NO_CONTENT_TYPE: &'static [u8; 5usize] = b"none\0";
pub const DEFAULT_HTTP_PORT: u32 = 80;
pub const DEFAULT_HTTPS_PORT: u32 = 443;
pub const HUGE_STRING_LEN: u32 = 8192;
pub const AP_IOBUFSIZE: u32 = 8192;
pub const AP_MAX_REG_MATCH: u32 = 10;
pub const AP_MAX_SENDFILE: u32 = 16777216;
pub const APEXIT_OK: u32 = 0;
pub const APEXIT_INIT: u32 = 2;
pub const APEXIT_CHILDINIT: u32 = 3;
pub const APEXIT_CHILDSICK: u32 = 7;
pub const APEXIT_CHILDFATAL: u32 = 15;
pub const DECLINED: i32 = -1;
pub const DONE: i32 = -2;
pub const OK: u32 = 0;
pub const RESPONSE_CODES: u32 = 57;
pub const HTTP_CONTINUE: u32 = 100;
pub const HTTP_SWITCHING_PROTOCOLS: u32 = 101;
pub const HTTP_PROCESSING: u32 = 102;
pub const HTTP_OK: u32 = 200;
pub const HTTP_CREATED: u32 = 201;
pub const HTTP_ACCEPTED: u32 = 202;
pub const HTTP_NON_AUTHORITATIVE: u32 = 203;
pub const HTTP_NO_CONTENT: u32 = 204;
pub const HTTP_RESET_CONTENT: u32 = 205;
pub const HTTP_PARTIAL_CONTENT: u32 = 206;
pub const HTTP_MULTI_STATUS: u32 = 207;
pub const HTTP_MULTIPLE_CHOICES: u32 = 300;
pub const HTTP_MOVED_PERMANENTLY: u32 = 301;
pub const HTTP_MOVED_TEMPORARILY: u32 = 302;
pub const HTTP_SEE_OTHER: u32 = 303;
pub const HTTP_NOT_MODIFIED: u32 = 304;
pub const HTTP_USE_PROXY: u32 = 305;
pub const HTTP_TEMPORARY_REDIRECT: u32 = 307;
pub const HTTP_BAD_REQUEST: u32 = 400;
pub const HTTP_UNAUTHORIZED: u32 = 401;
pub const HTTP_PAYMENT_REQUIRED: u32 = 402;
pub const HTTP_FORBIDDEN: u32 = 403;
pub const HTTP_NOT_FOUND: u32 = 404;
pub const HTTP_METHOD_NOT_ALLOWED: u32 = 405;
pub const HTTP_NOT_ACCEPTABLE: u32 = 406;
pub const HTTP_PROXY_AUTHENTICATION_REQUIRED: u32 = 407;
pub const HTTP_REQUEST_TIME_OUT: u32 = 408;
pub const HTTP_CONFLICT: u32 = 409;
pub const HTTP_GONE: u32 = 410;
pub const HTTP_LENGTH_REQUIRED: u32 = 411;
pub const HTTP_PRECONDITION_FAILED: u32 = 412;
pub const HTTP_REQUEST_ENTITY_TOO_LARGE: u32 = 413;
pub const HTTP_REQUEST_URI_TOO_LARGE: u32 = 414;
pub const HTTP_UNSUPPORTED_MEDIA_TYPE: u32 = 415;
pub const HTTP_RANGE_NOT_SATISFIABLE: u32 = 416;
pub const HTTP_EXPECTATION_FAILED: u32 = 417;
pub const HTTP_UNPROCESSABLE_ENTITY: u32 = 422;
pub const HTTP_LOCKED: u32 = 423;
pub const HTTP_FAILED_DEPENDENCY: u32 = 424;
pub const HTTP_UPGRADE_REQUIRED: u32 = 426;
pub const HTTP_INTERNAL_SERVER_ERROR: u32 = 500;
pub const HTTP_NOT_IMPLEMENTED: u32 = 501;
pub const HTTP_BAD_GATEWAY: u32 = 502;
pub const HTTP_SERVICE_UNAVAILABLE: u32 = 503;
pub const HTTP_GATEWAY_TIME_OUT: u32 = 504;
pub const HTTP_VERSION_NOT_SUPPORTED: u32 = 505;
pub const HTTP_VARIANT_ALSO_VARIES: u32 = 506;
pub const HTTP_INSUFFICIENT_STORAGE: u32 = 507;
pub const HTTP_NOT_EXTENDED: u32 = 510;
pub const M_GET: u32 = 0;
pub const M_PUT: u32 = 1;
pub const M_POST: u32 = 2;
pub const M_DELETE: u32 = 3;
pub const M_CONNECT: u32 = 4;
pub const M_OPTIONS: u32 = 5;
pub const M_TRACE: u32 = 6;
pub const M_PATCH: u32 = 7;
pub const M_PROPFIND: u32 = 8;
pub const M_PROPPATCH: u32 = 9;
pub const M_MKCOL: u32 = 10;
pub const M_COPY: u32 = 11;
pub const M_MOVE: u32 = 12;
pub const M_LOCK: u32 = 13;
pub const M_UNLOCK: u32 = 14;
pub const M_VERSION_CONTROL: u32 = 15;
pub const M_CHECKOUT: u32 = 16;
pub const M_UNCHECKOUT: u32 = 17;
pub const M_CHECKIN: u32 = 18;
pub const M_UPDATE: u32 = 19;
pub const M_LABEL: u32 = 20;
pub const M_REPORT: u32 = 21;
pub const M_MKWORKSPACE: u32 = 22;
pub const M_MKACTIVITY: u32 = 23;
pub const M_BASELINE_CONTROL: u32 = 24;
pub const M_MERGE: u32 = 25;
pub const M_INVALID: u32 = 26;
pub const METHODS: u32 = 64;
pub const CGI_MAGIC_TYPE: &'static [u8; 24usize] = b"application/x-httpd-cgi\0";
pub const INCLUDES_MAGIC_TYPE: &'static [u8; 26usize] = b"text/x-server-parsed-html\0";
pub const INCLUDES_MAGIC_TYPE3: &'static [u8; 27usize] = b"text/x-server-parsed-html3\0";
pub const DIR_MAGIC_TYPE: &'static [u8; 21usize] = b"httpd/unix-directory\0";
pub const LF: u32 = 10;
pub const CR: u32 = 13;
pub const CRLF: &'static [u8; 3usize] = b"\r\n\0";
pub const CRLF_ASCII: &'static [u8; 3usize] = b"\r\n\0";
pub const REQUEST_NO_BODY: u32 = 0;
pub const REQUEST_CHUNKED_ERROR: u32 = 1;
pub const REQUEST_CHUNKED_DECHUNK: u32 = 2;
pub const AP_REQ_ACCEPT_PATH_INFO: u32 = 0;
pub const AP_REQ_REJECT_PATH_INFO: u32 = 1;
pub const AP_REQ_DEFAULT_PATH_INFO: u32 = 2;
pub const APR_URI_FTP_DEFAULT_PORT: u32 = 21;
pub const APR_URI_SSH_DEFAULT_PORT: u32 = 22;
pub const APR_URI_TELNET_DEFAULT_PORT: u32 = 23;
pub const APR_URI_GOPHER_DEFAULT_PORT: u32 = 70;
pub const APR_URI_HTTP_DEFAULT_PORT: u32 = 80;
pub const APR_URI_POP_DEFAULT_PORT: u32 = 110;
pub const APR_URI_NNTP_DEFAULT_PORT: u32 = 119;
pub const APR_URI_IMAP_DEFAULT_PORT: u32 = 143;
pub const APR_URI_PROSPERO_DEFAULT_PORT: u32 = 191;
pub const APR_URI_WAIS_DEFAULT_PORT: u32 = 210;
pub const APR_URI_LDAP_DEFAULT_PORT: u32 = 389;
pub const APR_URI_HTTPS_DEFAULT_PORT: u32 = 443;
pub const APR_URI_RTSP_DEFAULT_PORT: u32 = 554;
pub const APR_URI_SNEWS_DEFAULT_PORT: u32 = 563;
pub const APR_URI_ACAP_DEFAULT_PORT: u32 = 674;
pub const APR_URI_NFS_DEFAULT_PORT: u32 = 2049;
pub const APR_URI_TIP_DEFAULT_PORT: u32 = 3372;
pub const APR_URI_SIP_DEFAULT_PORT: u32 = 5060;
pub const APR_URI_UNP_OMITSITEPART: u32 = 1;
pub const APR_URI_UNP_OMITUSER: u32 = 2;
pub const APR_URI_UNP_OMITPASSWORD: u32 = 4;
pub const APR_URI_UNP_OMITUSERINFO: u32 = 6;
pub const APR_URI_UNP_REVEALPASSWORD: u32 = 8;
pub const APR_URI_UNP_OMITPATHINFO: u32 = 16;
pub const APR_URI_UNP_OMITQUERY: u32 = 32;
pub const PROXYREQ_NONE: u32 = 0;
pub const PROXYREQ_PROXY: u32 = 1;
pub const PROXYREQ_REVERSE: u32 = 2;
pub const PROXYREQ_RESPONSE: u32 = 3;
pub const DEFAULT_VHOST_ADDR: u32 = 4294967295;
pub const SIGSTOP_DETACH: u32 = 1;
pub const SIGSTOP_MAKE_CHILD: u32 = 2;
pub const SIGSTOP_SPAWN_CHILD: u32 = 4;
pub const SIGSTOP_PIPED_LOG_SPAWN: u32 = 8;
pub const SIGSTOP_CGI_CHILD: u32 = 16;
pub const AP_NORESTART: u32 = 120001;

pub type __u_char = ::libc::c_uchar;
pub type __u_short = ::libc::c_ushort;
pub type __u_int = ::libc::c_uint;
pub type __u_long = ::libc::c_ulong;
pub type __int8_t = ::libc::c_schar;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_long;
pub type __uint64_t = ::libc::c_ulong;
pub type __quad_t = ::libc::c_long;
pub type __u_quad_t = ::libc::c_ulong;
pub type __dev_t = ::libc::c_ulong;
pub type __uid_t = ::libc::c_uint;
pub type __gid_t = ::libc::c_uint;
pub type __ino_t = ::libc::c_ulong;
pub type __ino64_t = ::libc::c_ulong;
pub type __mode_t = ::libc::c_uint;
pub type __nlink_t = ::libc::c_ulong;
pub type __off_t = ::libc::c_long;
pub type __off64_t = ::libc::c_long;
pub type __pid_t = ::libc::c_int;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t { pub __val: [::libc::c_int; 2usize] }

#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>(), 8usize, concat!( "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq!(::std::mem::align_of::<__fsid_t>(), 4usize, concat!( "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( __fsid_t ) , "::" , stringify ! ( __val ) ));
}

pub type __clock_t = ::libc::c_long;
pub type __rlim_t = ::libc::c_ulong;
pub type __rlim64_t = ::libc::c_ulong;
pub type __id_t = ::libc::c_uint;
pub type __time_t = ::libc::c_long;
pub type __useconds_t = ::libc::c_uint;
pub type __suseconds_t = ::libc::c_long;
pub type __daddr_t = ::libc::c_int;
pub type __key_t = ::libc::c_int;
pub type __clockid_t = ::libc::c_int;
pub type __timer_t = *mut ::libc::c_void;
pub type __blksize_t = ::libc::c_long;
pub type __blkcnt_t = ::libc::c_long;
pub type __blkcnt64_t = ::libc::c_long;
pub type __fsblkcnt_t = ::libc::c_ulong;
pub type __fsblkcnt64_t = ::libc::c_ulong;
pub type __fsfilcnt_t = ::libc::c_ulong;
pub type __fsfilcnt64_t = ::libc::c_ulong;
pub type __fsword_t = ::libc::c_long;
pub type __ssize_t = ::libc::c_long;
pub type __syscall_slong_t = ::libc::c_long;
pub type __syscall_ulong_t = ::libc::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::libc::c_char;
pub type __intptr_t = ::libc::c_long;
pub type __socklen_t = ::libc::c_uint;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::libc::c_ulong;
pub type ushort = ::libc::c_ushort;
pub type uint = ::libc::c_uint;
pub type u_int8_t = ::libc::c_uchar;
pub type u_int16_t = ::libc::c_ushort;
pub type u_int32_t = ::libc::c_uint;
pub type u_int64_t = ::libc::c_ulong;
pub type register_t = ::libc::c_long;
pub type __sig_atomic_t = ::libc::c_int;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t { pub __val: [::libc::c_ulong; 16usize] }

#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(::std::mem::size_of::<__sigset_t>(), 128usize, concat!( "Size of: " , stringify ! ( __sigset_t ) ));
    assert_eq!(::std::mem::align_of::<__sigset_t>(), 8usize, concat!( "Alignment of " , stringify ! ( __sigset_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( __sigset_t ) , "::" , stringify ! ( __val ) ));
}

pub type sigset_t = __sigset_t;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec { pub tv_sec: __time_t, pub tv_nsec: __syscall_slong_t }

#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>(), 16usize, concat!( "Size of: " , stringify ! ( timespec ) ));
    assert_eq!(::std::mem::align_of::<timespec>(), 8usize, concat!( "Alignment of " , stringify ! ( timespec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( timespec ) , "::" , stringify ! ( tv_sec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( timespec ) , "::" , stringify ! ( tv_nsec ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval { pub tv_sec: __time_t, pub tv_usec: __suseconds_t }

#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>(), 16usize, concat!( "Size of: " , stringify ! ( timeval ) ));
    assert_eq!(::std::mem::align_of::<timeval>(), 8usize, concat!( "Alignment of " , stringify ! ( timeval ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( timeval ) , "::" , stringify ! ( tv_sec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( timeval ) , "::" , stringify ! ( tv_usec ) ));
}

pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::libc::c_long;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set { pub __fds_bits: [__fd_mask; 16usize] }

#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(::std::mem::size_of::<fd_set>(), 128usize, concat!( "Size of: " , stringify ! ( fd_set ) ));
    assert_eq!(::std::mem::align_of::<fd_set>(), 8usize, concat!( "Alignment of " , stringify ! ( fd_set ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( fd_set ) , "::" , stringify ! ( __fds_bits ) ));
}

pub type fd_mask = __fd_mask;
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::libc::c_ulong;

#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t { pub __size: [::libc::c_char; 56usize], pub __align: ::libc::c_long, _bindgen_union_align: [u64; 7usize] }

#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<pthread_attr_t>(), 56usize, concat!( "Size of: " , stringify ! ( pthread_attr_t ) ));
    assert_eq!(::std::mem::align_of::<pthread_attr_t>(), 8usize, concat!( "Alignment of " , stringify ! ( pthread_attr_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( pthread_attr_t ) , "::" , stringify ! ( __size ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( pthread_attr_t ) , "::" , stringify ! ( __align ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list { pub __prev: *mut __pthread_internal_list, pub __next: *mut __pthread_internal_list }

#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(::std::mem::size_of::<__pthread_internal_list>(), 16usize, concat!( "Size of: " , stringify ! ( __pthread_internal_list ) ));
    assert_eq!(::std::mem::align_of::<__pthread_internal_list>(), 8usize, concat!( "Alignment of " , stringify ! ( __pthread_internal_list ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( __pthread_internal_list ) , "::" , stringify ! ( __prev ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( __pthread_internal_list ) , "::" , stringify ! ( __next ) ));
}

pub type __pthread_list_t = __pthread_internal_list;

#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t { pub __data: pthread_mutex_t___pthread_mutex_s, pub __size: [::libc::c_char; 40usize], pub __align: ::libc::c_long, _bindgen_union_align: [u64; 5usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_t___pthread_mutex_s { pub __lock: ::libc::c_int, pub __count: ::libc::c_uint, pub __owner: ::libc::c_int, pub __nusers: ::libc::c_uint, pub __kind: ::libc::c_int, pub __spins: ::libc::c_short, pub __elision: ::libc::c_short, pub __list: __pthread_list_t }

#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>(), 40usize, concat!( "Size of: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) ));
    assert_eq!(::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>(), 8usize, concat!( "Alignment of " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__lock as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __lock ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__count as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __count ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__owner as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __owner ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__nusers as *const _ as usize }, 12usize, concat!( "Offset of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __nusers ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__kind as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __kind ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__spins as *const _ as usize }, 20usize, concat!( "Offset of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __spins ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__elision as *const _ as usize }, 22usize, concat!( "Offset of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __elision ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__list as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( pthread_mutex_t___pthread_mutex_s ) , "::" , stringify ! ( __list ) ));
}

#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutex_t>(), 40usize, concat!( "Size of: " , stringify ! ( pthread_mutex_t ) ));
    assert_eq!(::std::mem::align_of::<pthread_mutex_t>(), 8usize, concat!( "Alignment of " , stringify ! ( pthread_mutex_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __data ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __size ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( pthread_mutex_t ) , "::" , stringify ! ( __align ) ));
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t { pub __size: [::libc::c_char; 4usize], pub __align: ::libc::c_int, _bindgen_union_align: u32 }

#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_mutexattr_t>(), 4usize, concat!( "Size of: " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq!(::std::mem::align_of::<pthread_mutexattr_t>(), 4usize, concat!( "Alignment of " , stringify ! ( pthread_mutexattr_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( pthread_mutexattr_t ) , "::" , stringify ! ( __size ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( pthread_mutexattr_t ) , "::" , stringify ! ( __align ) ));
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t { pub __data: pthread_cond_t__bindgen_ty_1, pub __size: [::libc::c_char; 48usize], pub __align: ::libc::c_longlong, _bindgen_union_align: [u64; 6usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_t__bindgen_ty_1 { pub __lock: ::libc::c_int, pub __futex: ::libc::c_uint, pub __total_seq: ::libc::c_ulonglong, pub __wakeup_seq: ::libc::c_ulonglong, pub __woken_seq: ::libc::c_ulonglong, pub __mutex: *mut ::libc::c_void, pub __nwaiters: ::libc::c_uint, pub __broadcast_seq: ::libc::c_uint }

#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>(), 48usize, concat!( "Size of: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ));
    assert_eq!(::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>(), 8usize, concat!( "Alignment of " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__lock as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__futex as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __futex ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__total_seq as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __total_seq ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__wakeup_seq as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __wakeup_seq ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__woken_seq as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __woken_seq ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__mutex as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __mutex ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__nwaiters as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __nwaiters ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__broadcast_seq as *const _ as usize }, 44usize, concat!( "Offset of field: " , stringify ! ( pthread_cond_t__bindgen_ty_1 ) , "::" , stringify ! ( __broadcast_seq ) ));
}

#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(::std::mem::size_of::<pthread_cond_t>(), 48usize, concat!( "Size of: " , stringify ! ( pthread_cond_t ) ));
    assert_eq!(::std::mem::align_of::<pthread_cond_t>(), 8usize, concat!( "Alignment of " , stringify ! ( pthread_cond_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __data ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __size ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( pthread_cond_t ) , "::" , stringify ! ( __align ) ));
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t { pub __size: [::libc::c_char; 4usize], pub __align: ::libc::c_int, _bindgen_union_align: u32 }

#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_condattr_t>(), 4usize, concat!( "Size of: " , stringify ! ( pthread_condattr_t ) ));
    assert_eq!(::std::mem::align_of::<pthread_condattr_t>(), 4usize, concat!( "Alignment of " , stringify ! ( pthread_condattr_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( pthread_condattr_t ) , "::" , stringify ! ( __size ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( pthread_condattr_t ) , "::" , stringify ! ( __align ) ));
}

pub type pthread_key_t = ::libc::c_uint;
pub type pthread_once_t = ::libc::c_int;

#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t { pub __data: pthread_rwlock_t__bindgen_ty_1, pub __size: [::libc::c_char; 56usize], pub __align: ::libc::c_long, _bindgen_union_align: [u64; 7usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock_t__bindgen_ty_1 { pub __lock: ::libc::c_int, pub __nr_readers: ::libc::c_uint, pub __readers_wakeup: ::libc::c_uint, pub __writer_wakeup: ::libc::c_uint, pub __nr_readers_queued: ::libc::c_uint, pub __nr_writers_queued: ::libc::c_uint, pub __writer: ::libc::c_int, pub __shared: ::libc::c_int, pub __rwelision: ::libc::c_schar, pub __pad1: [::libc::c_uchar; 7usize], pub __pad2: ::libc::c_ulong, pub __flags: ::libc::c_uint }

#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>(), 56usize, concat!( "Size of: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) ));
    assert_eq!(::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>(), 8usize, concat!( "Alignment of " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__lock as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __lock ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__nr_readers as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __nr_readers ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__readers_wakeup as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __readers_wakeup ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__writer_wakeup as *const _ as usize }, 12usize, concat!( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __writer_wakeup ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__nr_readers_queued as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __nr_readers_queued ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__nr_writers_queued as *const _ as usize }, 20usize, concat!( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __nr_writers_queued ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__writer as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __writer ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__shared as *const _ as usize }, 28usize, concat!( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __shared ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__rwelision as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __rwelision ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__pad1 as *const _ as usize }, 33usize, concat!( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__pad2 as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __pad2 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__flags as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( pthread_rwlock_t__bindgen_ty_1 ) , "::" , stringify ! ( __flags ) ));
}

#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlock_t>(), 56usize, concat!( "Size of: " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq!(::std::mem::align_of::<pthread_rwlock_t>(), 8usize, concat!( "Alignment of " , stringify ! ( pthread_rwlock_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( pthread_rwlock_t ) , "::" , stringify ! ( __data ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( pthread_rwlock_t ) , "::" , stringify ! ( __size ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( pthread_rwlock_t ) , "::" , stringify ! ( __align ) ));
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t { pub __size: [::libc::c_char; 8usize], pub __align: ::libc::c_long, _bindgen_union_align: u64 }

#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_rwlockattr_t>(), 8usize, concat!( "Size of: " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq!(::std::mem::align_of::<pthread_rwlockattr_t>(), 8usize, concat!( "Alignment of " , stringify ! ( pthread_rwlockattr_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( pthread_rwlockattr_t ) , "::" , stringify ! ( __size ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( pthread_rwlockattr_t ) , "::" , stringify ! ( __align ) ));
}

pub type pthread_spinlock_t = ::libc::c_int;

#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t { pub __size: [::libc::c_char; 32usize], pub __align: ::libc::c_long, _bindgen_union_align: [u64; 4usize] }

#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrier_t>(), 32usize, concat!( "Size of: " , stringify ! ( pthread_barrier_t ) ));
    assert_eq!(::std::mem::align_of::<pthread_barrier_t>(), 8usize, concat!( "Alignment of " , stringify ! ( pthread_barrier_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( pthread_barrier_t ) , "::" , stringify ! ( __size ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( pthread_barrier_t ) , "::" , stringify ! ( __align ) ));
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t { pub __size: [::libc::c_char; 4usize], pub __align: ::libc::c_int, _bindgen_union_align: u32 }

#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(::std::mem::size_of::<pthread_barrierattr_t>(), 4usize, concat!( "Size of: " , stringify ! ( pthread_barrierattr_t ) ));
    assert_eq!(::std::mem::align_of::<pthread_barrierattr_t>(), 4usize, concat!( "Alignment of " , stringify ! ( pthread_barrierattr_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( pthread_barrierattr_t ) , "::" , stringify ! ( __size ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( pthread_barrierattr_t ) , "::" , stringify ! ( __align ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec { pub iov_base: *mut ::libc::c_void, pub iov_len: usize }

#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(::std::mem::size_of::<iovec>(), 16usize, concat!( "Size of: " , stringify ! ( iovec ) ));
    assert_eq!(::std::mem::align_of::<iovec>(), 8usize, concat!( "Alignment of " , stringify ! ( iovec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<iovec>())).iov_base as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( iovec ) , "::" , stringify ! ( iov_base ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<iovec>())).iov_len as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( iovec ) , "::" , stringify ! ( iov_len ) ));
}

pub type socklen_t = __socklen_t;

pub const __socket_type_SOCK_STREAM: __socket_type = 1;
pub const __socket_type_SOCK_DGRAM: __socket_type = 2;
pub const __socket_type_SOCK_RAW: __socket_type = 3;
pub const __socket_type_SOCK_RDM: __socket_type = 4;
pub const __socket_type_SOCK_SEQPACKET: __socket_type = 5;
pub const __socket_type_SOCK_DCCP: __socket_type = 6;
pub const __socket_type_SOCK_PACKET: __socket_type = 10;
pub const __socket_type_SOCK_CLOEXEC: __socket_type = 524288;
pub const __socket_type_SOCK_NONBLOCK: __socket_type = 2048;

pub type __socket_type = u32;
pub type sa_family_t = ::libc::c_ushort;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr { pub sa_family: sa_family_t, pub sa_data: [::libc::c_char; 14usize] }

#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(::std::mem::size_of::<sockaddr>(), 16usize, concat!( "Size of: " , stringify ! ( sockaddr ) ));
    assert_eq!(::std::mem::align_of::<sockaddr>(), 2usize, concat!( "Alignment of " , stringify ! ( sockaddr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_family as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( sockaddr ) , "::" , stringify ! ( sa_family ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_data as *const _ as usize }, 2usize, concat!( "Offset of field: " , stringify ! ( sockaddr ) , "::" , stringify ! ( sa_data ) ));
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_storage { pub ss_family: sa_family_t, pub __ss_padding: [::libc::c_char; 118usize], pub __ss_align: ::libc::c_ulong }

#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(::std::mem::size_of::<sockaddr_storage>(), 128usize, concat!( "Size of: " , stringify ! ( sockaddr_storage ) ));
    assert_eq!(::std::mem::align_of::<sockaddr_storage>(), 8usize, concat!( "Alignment of " , stringify ! ( sockaddr_storage ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).ss_family as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( sockaddr_storage ) , "::" , stringify ! ( ss_family ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_padding as *const _ as usize }, 2usize, concat!( "Offset of field: " , stringify ! ( sockaddr_storage ) , "::" , stringify ! ( __ss_padding ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_align as *const _ as usize }, 120usize, concat!( "Offset of field: " , stringify ! ( sockaddr_storage ) , "::" , stringify ! ( __ss_align ) ));
}

pub const MSG_OOB: _bindgen_ty_1 = 1;
pub const MSG_PEEK: _bindgen_ty_1 = 2;
pub const MSG_DONTROUTE: _bindgen_ty_1 = 4;
pub const MSG_CTRUNC: _bindgen_ty_1 = 8;
pub const MSG_PROXY: _bindgen_ty_1 = 16;
pub const MSG_TRUNC: _bindgen_ty_1 = 32;
pub const MSG_DONTWAIT: _bindgen_ty_1 = 64;
pub const MSG_EOR: _bindgen_ty_1 = 128;
pub const MSG_WAITALL: _bindgen_ty_1 = 256;
pub const MSG_FIN: _bindgen_ty_1 = 512;
pub const MSG_SYN: _bindgen_ty_1 = 1024;
pub const MSG_CONFIRM: _bindgen_ty_1 = 2048;
pub const MSG_RST: _bindgen_ty_1 = 4096;
pub const MSG_ERRQUEUE: _bindgen_ty_1 = 8192;
pub const MSG_NOSIGNAL: _bindgen_ty_1 = 16384;
pub const MSG_MORE: _bindgen_ty_1 = 32768;
pub const MSG_WAITFORONE: _bindgen_ty_1 = 65536;
pub const MSG_FASTOPEN: _bindgen_ty_1 = 536870912;
pub const MSG_CMSG_CLOEXEC: _bindgen_ty_1 = 1073741824;

pub type _bindgen_ty_1 = u32;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct msghdr { pub msg_name: *mut ::libc::c_void, pub msg_namelen: socklen_t, pub msg_iov: *mut iovec, pub msg_iovlen: usize, pub msg_control: *mut ::libc::c_void, pub msg_controllen: usize, pub msg_flags: ::libc::c_int }

#[test]
fn bindgen_test_layout_msghdr() {
    assert_eq!(::std::mem::size_of::<msghdr>(), 56usize, concat!( "Size of: " , stringify ! ( msghdr ) ));
    assert_eq!(::std::mem::align_of::<msghdr>(), 8usize, concat!( "Alignment of " , stringify ! ( msghdr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<msghdr>())).msg_name as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( msghdr ) , "::" , stringify ! ( msg_name ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<msghdr>())).msg_namelen as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( msghdr ) , "::" , stringify ! ( msg_namelen ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iov as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( msghdr ) , "::" , stringify ! ( msg_iov ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<msghdr>())).msg_iovlen as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( msghdr ) , "::" , stringify ! ( msg_iovlen ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<msghdr>())).msg_control as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( msghdr ) , "::" , stringify ! ( msg_control ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<msghdr>())).msg_controllen as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( msghdr ) , "::" , stringify ! ( msg_controllen ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<msghdr>())).msg_flags as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( msghdr ) , "::" , stringify ! ( msg_flags ) ));
}

#[repr(C)]
#[derive(Debug)]
pub struct cmsghdr { pub cmsg_len: usize, pub cmsg_level: ::libc::c_int, pub cmsg_type: ::libc::c_int, pub __cmsg_data: __IncompleteArrayField<::libc::c_uchar> }

#[test]
fn bindgen_test_layout_cmsghdr() {
    assert_eq!(::std::mem::size_of::<cmsghdr>(), 16usize, concat!( "Size of: " , stringify ! ( cmsghdr ) ));
    assert_eq!(::std::mem::align_of::<cmsghdr>(), 8usize, concat!( "Alignment of " , stringify ! ( cmsghdr ) ));
}

pub const SCM_RIGHTS: _bindgen_ty_2 = 1;

pub type _bindgen_ty_2 = u32;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linger { pub l_onoff: ::libc::c_int, pub l_linger: ::libc::c_int }

#[test]
fn bindgen_test_layout_linger() {
    assert_eq!(::std::mem::size_of::<linger>(), 8usize, concat!( "Size of: " , stringify ! ( linger ) ));
    assert_eq!(::std::mem::align_of::<linger>(), 4usize, concat!( "Alignment of " , stringify ! ( linger ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<linger>())).l_onoff as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( linger ) , "::" , stringify ! ( l_onoff ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<linger>())).l_linger as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( linger ) , "::" , stringify ! ( l_linger ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct osockaddr { pub sa_family: ::libc::c_ushort, pub sa_data: [::libc::c_uchar; 14usize] }

#[test]
fn bindgen_test_layout_osockaddr() {
    assert_eq!(::std::mem::size_of::<osockaddr>(), 16usize, concat!( "Size of: " , stringify ! ( osockaddr ) ));
    assert_eq!(::std::mem::align_of::<osockaddr>(), 2usize, concat!( "Alignment of " , stringify ! ( osockaddr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<osockaddr>())).sa_family as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( osockaddr ) , "::" , stringify ! ( sa_family ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<osockaddr>())).sa_data as *const _ as usize }, 2usize, concat!( "Offset of field: " , stringify ! ( osockaddr ) , "::" , stringify ! ( sa_data ) ));
}

pub const SHUT_RD: _bindgen_ty_3 = 0;
pub const SHUT_WR: _bindgen_ty_3 = 1;
pub const SHUT_RDWR: _bindgen_ty_3 = 2;

pub type _bindgen_ty_3 = u32;
pub type int_least8_t = ::libc::c_schar;
pub type int_least16_t = ::libc::c_short;
pub type int_least32_t = ::libc::c_int;
pub type int_least64_t = ::libc::c_long;
pub type uint_least8_t = ::libc::c_uchar;
pub type uint_least16_t = ::libc::c_ushort;
pub type uint_least32_t = ::libc::c_uint;
pub type uint_least64_t = ::libc::c_ulong;
pub type int_fast8_t = ::libc::c_schar;
pub type int_fast16_t = ::libc::c_long;
pub type int_fast32_t = ::libc::c_long;
pub type int_fast64_t = ::libc::c_long;
pub type uint_fast8_t = ::libc::c_uchar;
pub type uint_fast16_t = ::libc::c_ulong;
pub type uint_fast32_t = ::libc::c_ulong;
pub type uint_fast64_t = ::libc::c_ulong;
pub type intmax_t = ::libc::c_long;
pub type uintmax_t = ::libc::c_ulong;
pub type sig_atomic_t = __sig_atomic_t;

#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval { pub sival_int: ::libc::c_int, pub sival_ptr: *mut ::libc::c_void, _bindgen_union_align: u64 }

#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(::std::mem::size_of::<sigval>(), 8usize, concat!( "Size of: " , stringify ! ( sigval ) ));
    assert_eq!(::std::mem::align_of::<sigval>(), 8usize, concat!( "Alignment of " , stringify ! ( sigval ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigval>())).sival_int as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( sigval ) , "::" , stringify ! ( sival_int ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigval>())).sival_ptr as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( sigval ) , "::" , stringify ! ( sival_ptr ) ));
}

pub type sigval_t = sigval;
pub type __sigchld_clock_t = __clock_t;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t { pub si_signo: ::libc::c_int, pub si_errno: ::libc::c_int, pub si_code: ::libc::c_int, pub _sifields: siginfo_t__bindgen_ty_1 }

#[repr(C)]
#[derive(Copy, Clone)]
pub union siginfo_t__bindgen_ty_1 { pub _pad: [::libc::c_int; 28usize], pub _kill: siginfo_t__bindgen_ty_1__bindgen_ty_1, pub _timer: siginfo_t__bindgen_ty_1__bindgen_ty_2, pub _rt: siginfo_t__bindgen_ty_1__bindgen_ty_3, pub _sigchld: siginfo_t__bindgen_ty_1__bindgen_ty_4, pub _sigfault: siginfo_t__bindgen_ty_1__bindgen_ty_5, pub _sigpoll: siginfo_t__bindgen_ty_1__bindgen_ty_6, pub _sigsys: siginfo_t__bindgen_ty_1__bindgen_ty_7, _bindgen_union_align: [u64; 14usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_1 { pub si_pid: __pid_t, pub si_uid: __uid_t }

#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(), 8usize, concat!( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq!(::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_1>(), 4usize, concat!( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_1>())).si_pid as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( si_pid ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_1>())).si_uid as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( si_uid ) ));
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_2 { pub si_tid: ::libc::c_int, pub si_overrun: ::libc::c_int, pub si_sigval: sigval_t }

#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(), 16usize, concat!( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq!(::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_2>(), 8usize, concat!( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_2>())).si_tid as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! ( si_tid ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_2>())).si_overrun as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! ( si_overrun ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_2>())).si_sigval as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify ! ( si_sigval ) ));
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_3 { pub si_pid: __pid_t, pub si_uid: __uid_t, pub si_sigval: sigval_t }

#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(), 16usize, concat!( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq!(::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_3>(), 8usize, concat!( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_3>())).si_pid as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! ( si_pid ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_3>())).si_uid as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! ( si_uid ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_3>())).si_sigval as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_3 ) , "::" , stringify ! ( si_sigval ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_4 { pub si_pid: __pid_t, pub si_uid: __uid_t, pub si_status: ::libc::c_int, pub si_utime: __sigchld_clock_t, pub si_stime: __sigchld_clock_t }

#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(), 32usize, concat!( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq!(::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_4>(), 8usize, concat!( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_pid as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! ( si_pid ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_uid as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! ( si_uid ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_status as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! ( si_status ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_utime as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! ( si_utime ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_4>())).si_stime as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_4 ) , "::" , stringify ! ( si_stime ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5 { pub si_addr: *mut ::libc::c_void, pub si_addr_lsb: ::libc::c_short, pub si_addr_bnd: siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 { pub _lower: *mut ::libc::c_void, pub _upper: *mut ::libc::c_void }

#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(), 16usize, concat!( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) ));
    assert_eq!(::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>(), 8usize, concat!( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()))._lower as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) , "::" , stringify ! ( _lower ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1>()))._upper as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5__bindgen_ty_1 ) , "::" , stringify ! ( _upper ) ));
}

#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(), 32usize, concat!( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5 ) ));
    assert_eq!(::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_5>(), 8usize, concat!( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5>())).si_addr as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! ( si_addr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5>())).si_addr_lsb as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! ( si_addr_lsb ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_5>())).si_addr_bnd as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_5 ) , "::" , stringify ! ( si_addr_bnd ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_6 { pub si_band: ::libc::c_long, pub si_fd: ::libc::c_int }

#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(), 16usize, concat!( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_6 ) ));
    assert_eq!(::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_6>(), 8usize, concat!( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_6 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_6>())).si_band as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_6 ) , "::" , stringify ! ( si_band ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_6>())).si_fd as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_6 ) , "::" , stringify ! ( si_fd ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct siginfo_t__bindgen_ty_1__bindgen_ty_7 { pub _call_addr: *mut ::libc::c_void, pub _syscall: ::libc::c_int, pub _arch: ::libc::c_uint }

#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(), 16usize, concat!( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_7 ) ));
    assert_eq!(::std::mem::align_of::<siginfo_t__bindgen_ty_1__bindgen_ty_7>(), 8usize, concat!( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_7 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()))._call_addr as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! ( _call_addr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()))._syscall as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! ( _syscall ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1__bindgen_ty_7>()))._arch as *const _ as usize }, 12usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1__bindgen_ty_7 ) , "::" , stringify ! ( _arch ) ));
}

#[test]
fn bindgen_test_layout_siginfo_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<siginfo_t__bindgen_ty_1>(), 112usize, concat!( "Size of: " , stringify ! ( siginfo_t__bindgen_ty_1 ) ));
    assert_eq!(::std::mem::align_of::<siginfo_t__bindgen_ty_1>(), 8usize, concat!( "Alignment of " , stringify ! ( siginfo_t__bindgen_ty_1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._pad as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1 ) , "::" , stringify ! ( _pad ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._kill as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1 ) , "::" , stringify ! ( _kill ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._timer as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1 ) , "::" , stringify ! ( _timer ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._rt as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1 ) , "::" , stringify ! ( _rt ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigchld as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1 ) , "::" , stringify ! ( _sigchld ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigfault as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1 ) , "::" , stringify ! ( _sigfault ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigpoll as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1 ) , "::" , stringify ! ( _sigpoll ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t__bindgen_ty_1>()))._sigsys as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( siginfo_t__bindgen_ty_1 ) , "::" , stringify ! ( _sigsys ) ));
}

#[test]
fn bindgen_test_layout_siginfo_t() {
    assert_eq!(::std::mem::size_of::<siginfo_t>(), 128usize, concat!( "Size of: " , stringify ! ( siginfo_t ) ));
    assert_eq!(::std::mem::align_of::<siginfo_t>(), 8usize, concat!( "Alignment of " , stringify ! ( siginfo_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_signo as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( siginfo_t ) , "::" , stringify ! ( si_signo ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_errno as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( siginfo_t ) , "::" , stringify ! ( si_errno ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t>())).si_code as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( siginfo_t ) , "::" , stringify ! ( si_code ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<siginfo_t>()))._sifields as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( siginfo_t ) , "::" , stringify ! ( _sifields ) ));
}

pub const SI_ASYNCNL: _bindgen_ty_4 = -60;
pub const SI_TKILL: _bindgen_ty_4 = -6;
pub const SI_SIGIO: _bindgen_ty_4 = -5;
pub const SI_ASYNCIO: _bindgen_ty_4 = -4;
pub const SI_MESGQ: _bindgen_ty_4 = -3;
pub const SI_TIMER: _bindgen_ty_4 = -2;
pub const SI_QUEUE: _bindgen_ty_4 = -1;
pub const SI_USER: _bindgen_ty_4 = 0;
pub const SI_KERNEL: _bindgen_ty_4 = 128;

pub type _bindgen_ty_4 = i32;

pub const ILL_ILLOPC: _bindgen_ty_5 = 1;
pub const ILL_ILLOPN: _bindgen_ty_5 = 2;
pub const ILL_ILLADR: _bindgen_ty_5 = 3;
pub const ILL_ILLTRP: _bindgen_ty_5 = 4;
pub const ILL_PRVOPC: _bindgen_ty_5 = 5;
pub const ILL_PRVREG: _bindgen_ty_5 = 6;
pub const ILL_COPROC: _bindgen_ty_5 = 7;
pub const ILL_BADSTK: _bindgen_ty_5 = 8;

pub type _bindgen_ty_5 = u32;

pub const FPE_INTDIV: _bindgen_ty_6 = 1;
pub const FPE_INTOVF: _bindgen_ty_6 = 2;
pub const FPE_FLTDIV: _bindgen_ty_6 = 3;
pub const FPE_FLTOVF: _bindgen_ty_6 = 4;
pub const FPE_FLTUND: _bindgen_ty_6 = 5;
pub const FPE_FLTRES: _bindgen_ty_6 = 6;
pub const FPE_FLTINV: _bindgen_ty_6 = 7;
pub const FPE_FLTSUB: _bindgen_ty_6 = 8;

pub type _bindgen_ty_6 = u32;

pub const SEGV_MAPERR: _bindgen_ty_7 = 1;
pub const SEGV_ACCERR: _bindgen_ty_7 = 2;

pub type _bindgen_ty_7 = u32;

pub const BUS_ADRALN: _bindgen_ty_8 = 1;
pub const BUS_ADRERR: _bindgen_ty_8 = 2;
pub const BUS_OBJERR: _bindgen_ty_8 = 3;
pub const BUS_MCEERR_AR: _bindgen_ty_8 = 4;
pub const BUS_MCEERR_AO: _bindgen_ty_8 = 5;

pub type _bindgen_ty_8 = u32;

pub const CLD_EXITED: _bindgen_ty_9 = 1;
pub const CLD_KILLED: _bindgen_ty_9 = 2;
pub const CLD_DUMPED: _bindgen_ty_9 = 3;
pub const CLD_TRAPPED: _bindgen_ty_9 = 4;
pub const CLD_STOPPED: _bindgen_ty_9 = 5;
pub const CLD_CONTINUED: _bindgen_ty_9 = 6;

pub type _bindgen_ty_9 = u32;

pub const POLL_IN: _bindgen_ty_10 = 1;
pub const POLL_OUT: _bindgen_ty_10 = 2;
pub const POLL_MSG: _bindgen_ty_10 = 3;
pub const POLL_ERR: _bindgen_ty_10 = 4;
pub const POLL_PRI: _bindgen_ty_10 = 5;
pub const POLL_HUP: _bindgen_ty_10 = 6;

pub type _bindgen_ty_10 = u32;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent { pub sigev_value: sigval_t, pub sigev_signo: ::libc::c_int, pub sigev_notify: ::libc::c_int, pub _sigev_un: sigevent__bindgen_ty_1 }

#[repr(C)]
#[derive(Copy, Clone)]
pub union sigevent__bindgen_ty_1 { pub _pad: [::libc::c_int; 12usize], pub _tid: __pid_t, pub _sigev_thread: sigevent__bindgen_ty_1__bindgen_ty_1, _bindgen_union_align: [u64; 6usize] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent__bindgen_ty_1__bindgen_ty_1 { pub _function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval_t)>, pub _attribute: *mut pthread_attr_t }

#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(), 16usize, concat!( "Size of: " , stringify ! ( sigevent__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq!(::std::mem::align_of::<sigevent__bindgen_ty_1__bindgen_ty_1>(), 8usize, concat!( "Alignment of " , stringify ! ( sigevent__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1__bindgen_ty_1>()))._function as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( sigevent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( _function ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1__bindgen_ty_1>()))._attribute as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( sigevent__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify ! ( _attribute ) ));
}

#[test]
fn bindgen_test_layout_sigevent__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sigevent__bindgen_ty_1>(), 48usize, concat!( "Size of: " , stringify ! ( sigevent__bindgen_ty_1 ) ));
    assert_eq!(::std::mem::align_of::<sigevent__bindgen_ty_1>(), 8usize, concat!( "Alignment of " , stringify ! ( sigevent__bindgen_ty_1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._pad as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( sigevent__bindgen_ty_1 ) , "::" , stringify ! ( _pad ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._tid as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( sigevent__bindgen_ty_1 ) , "::" , stringify ! ( _tid ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigevent__bindgen_ty_1>()))._sigev_thread as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( sigevent__bindgen_ty_1 ) , "::" , stringify ! ( _sigev_thread ) ));
}

#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(::std::mem::size_of::<sigevent>(), 64usize, concat!( "Size of: " , stringify ! ( sigevent ) ));
    assert_eq!(::std::mem::align_of::<sigevent>(), 8usize, concat!( "Alignment of " , stringify ! ( sigevent ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_value as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( sigevent ) , "::" , stringify ! ( sigev_value ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_signo as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( sigevent ) , "::" , stringify ! ( sigev_signo ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify as *const _ as usize }, 12usize, concat!( "Offset of field: " , stringify ! ( sigevent ) , "::" , stringify ! ( sigev_notify ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigevent>()))._sigev_un as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( sigevent ) , "::" , stringify ! ( _sigev_un ) ));
}

pub type sigevent_t = sigevent;

pub const SIGEV_SIGNAL: _bindgen_ty_11 = 0;
pub const SIGEV_NONE: _bindgen_ty_11 = 1;
pub const SIGEV_THREAD: _bindgen_ty_11 = 2;
pub const SIGEV_THREAD_ID: _bindgen_ty_11 = 4;

pub type _bindgen_ty_11 = u32;
pub type __sighandler_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>;
pub type sig_t = __sighandler_t;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction { pub __sigaction_handler: sigaction__bindgen_ty_1, pub sa_mask: __sigset_t, pub sa_flags: ::libc::c_int, pub sa_restorer: ::std::option::Option<unsafe extern "C" fn()> }

#[repr(C)]
#[derive(Copy, Clone)]
pub union sigaction__bindgen_ty_1 { pub sa_handler: __sighandler_t, pub sa_sigaction: ::std::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int, arg2: *mut siginfo_t, arg3: *mut ::libc::c_void)>, _bindgen_union_align: u64 }

#[test]
fn bindgen_test_layout_sigaction__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sigaction__bindgen_ty_1>(), 8usize, concat!( "Size of: " , stringify ! ( sigaction__bindgen_ty_1 ) ));
    assert_eq!(::std::mem::align_of::<sigaction__bindgen_ty_1>(), 8usize, concat!( "Alignment of " , stringify ! ( sigaction__bindgen_ty_1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigaction__bindgen_ty_1>())).sa_handler as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( sigaction__bindgen_ty_1 ) , "::" , stringify ! ( sa_handler ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigaction__bindgen_ty_1>())).sa_sigaction as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( sigaction__bindgen_ty_1 ) , "::" , stringify ! ( sa_sigaction ) ));
}

#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(::std::mem::size_of::<sigaction>(), 152usize, concat!( "Size of: " , stringify ! ( sigaction ) ));
    assert_eq!(::std::mem::align_of::<sigaction>(), 8usize, concat!( "Alignment of " , stringify ! ( sigaction ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigaction>())).__sigaction_handler as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( sigaction ) , "::" , stringify ! ( __sigaction_handler ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigaction>())).sa_mask as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( sigaction ) , "::" , stringify ! ( sa_mask ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigaction>())).sa_flags as *const _ as usize }, 136usize, concat!( "Offset of field: " , stringify ! ( sigaction ) , "::" , stringify ! ( sa_flags ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigaction>())).sa_restorer as *const _ as usize }, 144usize, concat!( "Offset of field: " , stringify ! ( sigaction ) , "::" , stringify ! ( sa_restorer ) ));
}

extern "C" {
    #[link_name = "\u{1}_sys_siglist"]
    pub static mut _sys_siglist: [*const ::libc::c_char; 65usize];
}

extern "C" {
    #[link_name = "\u{1}sys_siglist"]
    pub static mut sys_siglist: [*const ::libc::c_char; 65usize];
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpx_sw_bytes { pub magic1: __uint32_t, pub extended_size: __uint32_t, pub xstate_bv: __uint64_t, pub xstate_size: __uint32_t, pub padding: [__uint32_t; 7usize] }

#[test]
fn bindgen_test_layout__fpx_sw_bytes() {
    assert_eq!(::std::mem::size_of::<_fpx_sw_bytes>(), 48usize, concat!( "Size of: " , stringify ! ( _fpx_sw_bytes ) ));
    assert_eq!(::std::mem::align_of::<_fpx_sw_bytes>(), 8usize, concat!( "Alignment of " , stringify ! ( _fpx_sw_bytes ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).magic1 as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( _fpx_sw_bytes ) , "::" , stringify ! ( magic1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).extended_size as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( _fpx_sw_bytes ) , "::" , stringify ! ( extended_size ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).xstate_bv as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( _fpx_sw_bytes ) , "::" , stringify ! ( xstate_bv ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).xstate_size as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( _fpx_sw_bytes ) , "::" , stringify ! ( xstate_size ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_fpx_sw_bytes>())).padding as *const _ as usize }, 20usize, concat!( "Offset of field: " , stringify ! ( _fpx_sw_bytes ) , "::" , stringify ! ( padding ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpreg { pub significand: [::libc::c_ushort; 4usize], pub exponent: ::libc::c_ushort }

#[test]
fn bindgen_test_layout__fpreg() {
    assert_eq!(::std::mem::size_of::<_fpreg>(), 10usize, concat!( "Size of: " , stringify ! ( _fpreg ) ));
    assert_eq!(::std::mem::align_of::<_fpreg>(), 2usize, concat!( "Alignment of " , stringify ! ( _fpreg ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_fpreg>())).significand as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( _fpreg ) , "::" , stringify ! ( significand ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_fpreg>())).exponent as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( _fpreg ) , "::" , stringify ! ( exponent ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpxreg { pub significand: [::libc::c_ushort; 4usize], pub exponent: ::libc::c_ushort, pub padding: [::libc::c_ushort; 3usize] }

#[test]
fn bindgen_test_layout__fpxreg() {
    assert_eq!(::std::mem::size_of::<_fpxreg>(), 16usize, concat!( "Size of: " , stringify ! ( _fpxreg ) ));
    assert_eq!(::std::mem::align_of::<_fpxreg>(), 2usize, concat!( "Alignment of " , stringify ! ( _fpxreg ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_fpxreg>())).significand as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( _fpxreg ) , "::" , stringify ! ( significand ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_fpxreg>())).exponent as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( _fpxreg ) , "::" , stringify ! ( exponent ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_fpxreg>())).padding as *const _ as usize }, 10usize, concat!( "Offset of field: " , stringify ! ( _fpxreg ) , "::" , stringify ! ( padding ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xmmreg { pub element: [__uint32_t; 4usize] }

#[test]
fn bindgen_test_layout__xmmreg() {
    assert_eq!(::std::mem::size_of::<_xmmreg>(), 16usize, concat!( "Size of: " , stringify ! ( _xmmreg ) ));
    assert_eq!(::std::mem::align_of::<_xmmreg>(), 4usize, concat!( "Alignment of " , stringify ! ( _xmmreg ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_xmmreg>())).element as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( _xmmreg ) , "::" , stringify ! ( element ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _fpstate { pub cwd: __uint16_t, pub swd: __uint16_t, pub ftw: __uint16_t, pub fop: __uint16_t, pub rip: __uint64_t, pub rdp: __uint64_t, pub mxcsr: __uint32_t, pub mxcr_mask: __uint32_t, pub _st: [_fpxreg; 8usize], pub _xmm: [_xmmreg; 16usize], pub padding: [__uint32_t; 24usize] }

#[test]
fn bindgen_test_layout__fpstate() {
    assert_eq!(::std::mem::size_of::<_fpstate>(), 512usize, concat!( "Size of: " , stringify ! ( _fpstate ) ));
    assert_eq!(::std::mem::align_of::<_fpstate>(), 8usize, concat!( "Alignment of " , stringify ! ( _fpstate ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_fpstate>())).cwd as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( _fpstate ) , "::" , stringify ! ( cwd ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_fpstate>())).swd as *const _ as usize }, 2usize, concat!( "Offset of field: " , stringify ! ( _fpstate ) , "::" , stringify ! ( swd ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_fpstate>())).ftw as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( _fpstate ) , "::" , stringify ! ( ftw ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_fpstate>())).fop as *const _ as usize }, 6usize, concat!( "Offset of field: " , stringify ! ( _fpstate ) , "::" , stringify ! ( fop ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_fpstate>())).rip as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( _fpstate ) , "::" , stringify ! ( rip ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_fpstate>())).rdp as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( _fpstate ) , "::" , stringify ! ( rdp ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_fpstate>())).mxcsr as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( _fpstate ) , "::" , stringify ! ( mxcsr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_fpstate>())).mxcr_mask as *const _ as usize }, 28usize, concat!( "Offset of field: " , stringify ! ( _fpstate ) , "::" , stringify ! ( mxcr_mask ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_fpstate>()))._st as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( _fpstate ) , "::" , stringify ! ( _st ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_fpstate>()))._xmm as *const _ as usize }, 160usize, concat!( "Offset of field: " , stringify ! ( _fpstate ) , "::" , stringify ! ( _xmm ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_fpstate>())).padding as *const _ as usize }, 416usize, concat!( "Offset of field: " , stringify ! ( _fpstate ) , "::" , stringify ! ( padding ) ));
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigcontext { pub r8: __uint64_t, pub r9: __uint64_t, pub r10: __uint64_t, pub r11: __uint64_t, pub r12: __uint64_t, pub r13: __uint64_t, pub r14: __uint64_t, pub r15: __uint64_t, pub rdi: __uint64_t, pub rsi: __uint64_t, pub rbp: __uint64_t, pub rbx: __uint64_t, pub rdx: __uint64_t, pub rax: __uint64_t, pub rcx: __uint64_t, pub rsp: __uint64_t, pub rip: __uint64_t, pub eflags: __uint64_t, pub cs: ::libc::c_ushort, pub gs: ::libc::c_ushort, pub fs: ::libc::c_ushort, pub __pad0: ::libc::c_ushort, pub err: __uint64_t, pub trapno: __uint64_t, pub oldmask: __uint64_t, pub cr2: __uint64_t, pub __bindgen_anon_1: sigcontext__bindgen_ty_1, pub __reserved1: [__uint64_t; 8usize] }

#[repr(C)]
#[derive(Copy, Clone)]
pub union sigcontext__bindgen_ty_1 { pub fpstate: *mut _fpstate, pub __fpstate_word: __uint64_t, _bindgen_union_align: u64 }

#[test]
fn bindgen_test_layout_sigcontext__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<sigcontext__bindgen_ty_1>(), 8usize, concat!( "Size of: " , stringify ! ( sigcontext__bindgen_ty_1 ) ));
    assert_eq!(::std::mem::align_of::<sigcontext__bindgen_ty_1>(), 8usize, concat!( "Alignment of " , stringify ! ( sigcontext__bindgen_ty_1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext__bindgen_ty_1>())).fpstate as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( sigcontext__bindgen_ty_1 ) , "::" , stringify ! ( fpstate ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext__bindgen_ty_1>())).__fpstate_word as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( sigcontext__bindgen_ty_1 ) , "::" , stringify ! ( __fpstate_word ) ));
}

#[test]
fn bindgen_test_layout_sigcontext() {
    assert_eq!(::std::mem::size_of::<sigcontext>(), 256usize, concat!( "Size of: " , stringify ! ( sigcontext ) ));
    assert_eq!(::std::mem::align_of::<sigcontext>(), 8usize, concat!( "Alignment of " , stringify ! ( sigcontext ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).r8 as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( r8 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).r9 as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( r9 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).r10 as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( r10 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).r11 as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( r11 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).r12 as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( r12 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).r13 as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( r13 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).r14 as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( r14 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).r15 as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( r15 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).rdi as *const _ as usize }, 64usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( rdi ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).rsi as *const _ as usize }, 72usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( rsi ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).rbp as *const _ as usize }, 80usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( rbp ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).rbx as *const _ as usize }, 88usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( rbx ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).rdx as *const _ as usize }, 96usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( rdx ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).rax as *const _ as usize }, 104usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( rax ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).rcx as *const _ as usize }, 112usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( rcx ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).rsp as *const _ as usize }, 120usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( rsp ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).rip as *const _ as usize }, 128usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( rip ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).eflags as *const _ as usize }, 136usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( eflags ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).cs as *const _ as usize }, 144usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( cs ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).gs as *const _ as usize }, 146usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( gs ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).fs as *const _ as usize }, 148usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( fs ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).__pad0 as *const _ as usize }, 150usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( __pad0 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).err as *const _ as usize }, 152usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( err ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).trapno as *const _ as usize }, 160usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( trapno ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).oldmask as *const _ as usize }, 168usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( oldmask ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).cr2 as *const _ as usize }, 176usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( cr2 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigcontext>())).__reserved1 as *const _ as usize }, 192usize, concat!( "Offset of field: " , stringify ! ( sigcontext ) , "::" , stringify ! ( __reserved1 ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _xsave_hdr { pub xstate_bv: __uint64_t, pub reserved1: [__uint64_t; 2usize], pub reserved2: [__uint64_t; 5usize] }

#[test]
fn bindgen_test_layout__xsave_hdr() {
    assert_eq!(::std::mem::size_of::<_xsave_hdr>(), 64usize, concat!( "Size of: " , stringify ! ( _xsave_hdr ) ));
    assert_eq!(::std::mem::align_of::<_xsave_hdr>(), 8usize, concat!( "Alignment of " , stringify ! ( _xsave_hdr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_xsave_hdr>())).xstate_bv as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( _xsave_hdr ) , "::" , stringify ! ( xstate_bv ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_xsave_hdr>())).reserved1 as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( _xsave_hdr ) , "::" , stringify ! ( reserved1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_xsave_hdr>())).reserved2 as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( _xsave_hdr ) , "::" , stringify ! ( reserved2 ) ));
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ymmh_state { pub ymmh_space: [__uint32_t; 64usize] }

#[test]
fn bindgen_test_layout__ymmh_state() {
    assert_eq!(::std::mem::size_of::<_ymmh_state>(), 256usize, concat!( "Size of: " , stringify ! ( _ymmh_state ) ));
    assert_eq!(::std::mem::align_of::<_ymmh_state>(), 4usize, concat!( "Alignment of " , stringify ! ( _ymmh_state ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_ymmh_state>())).ymmh_space as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( _ymmh_state ) , "::" , stringify ! ( ymmh_space ) ));
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct _xstate { pub fpstate: _fpstate, pub xstate_hdr: _xsave_hdr, pub ymmh: _ymmh_state }

#[test]
fn bindgen_test_layout__xstate() {
    assert_eq!(::std::mem::size_of::<_xstate>(), 832usize, concat!( "Size of: " , stringify ! ( _xstate ) ));
    assert_eq!(::std::mem::align_of::<_xstate>(), 8usize, concat!( "Alignment of " , stringify ! ( _xstate ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_xstate>())).fpstate as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( _xstate ) , "::" , stringify ! ( fpstate ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_xstate>())).xstate_hdr as *const _ as usize }, 512usize, concat!( "Offset of field: " , stringify ! ( _xstate ) , "::" , stringify ! ( xstate_hdr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_xstate>())).ymmh as *const _ as usize }, 576usize, concat!( "Offset of field: " , stringify ! ( _xstate ) , "::" , stringify ! ( ymmh ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack { pub ss_sp: *mut ::libc::c_void, pub ss_onstack: ::libc::c_int }

#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(::std::mem::size_of::<sigstack>(), 16usize, concat!( "Size of: " , stringify ! ( sigstack ) ));
    assert_eq!(::std::mem::align_of::<sigstack>(), 8usize, concat!( "Alignment of " , stringify ! ( sigstack ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigstack>())).ss_sp as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( sigstack ) , "::" , stringify ! ( ss_sp ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigstack>())).ss_onstack as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( sigstack ) , "::" , stringify ! ( ss_onstack ) ));
}

pub const SS_ONSTACK: _bindgen_ty_12 = 1;
pub const SS_DISABLE: _bindgen_ty_12 = 2;

pub type _bindgen_ty_12 = u32;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigaltstack { pub ss_sp: *mut ::libc::c_void, pub ss_flags: ::libc::c_int, pub ss_size: usize }

#[test]
fn bindgen_test_layout_sigaltstack() {
    assert_eq!(::std::mem::size_of::<sigaltstack>(), 24usize, concat!( "Size of: " , stringify ! ( sigaltstack ) ));
    assert_eq!(::std::mem::align_of::<sigaltstack>(), 8usize, concat!( "Alignment of " , stringify ! ( sigaltstack ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigaltstack>())).ss_sp as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( sigaltstack ) , "::" , stringify ! ( ss_sp ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigaltstack>())).ss_flags as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( sigaltstack ) , "::" , stringify ! ( ss_flags ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sigaltstack>())).ss_size as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( sigaltstack ) , "::" , stringify ! ( ss_size ) ));
}

pub type stack_t = sigaltstack;
pub type greg_t = ::libc::c_longlong;
pub type gregset_t = [greg_t; 23usize];

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpxreg { pub significand: [::libc::c_ushort; 4usize], pub exponent: ::libc::c_ushort, pub padding: [::libc::c_ushort; 3usize] }

#[test]
fn bindgen_test_layout__libc_fpxreg() {
    assert_eq!(::std::mem::size_of::<_libc_fpxreg>(), 16usize, concat!( "Size of: " , stringify ! ( _libc_fpxreg ) ));
    assert_eq!(::std::mem::align_of::<_libc_fpxreg>(), 2usize, concat!( "Alignment of " , stringify ! ( _libc_fpxreg ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_libc_fpxreg>())).significand as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( _libc_fpxreg ) , "::" , stringify ! ( significand ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_libc_fpxreg>())).exponent as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( _libc_fpxreg ) , "::" , stringify ! ( exponent ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_libc_fpxreg>())).padding as *const _ as usize }, 10usize, concat!( "Offset of field: " , stringify ! ( _libc_fpxreg ) , "::" , stringify ! ( padding ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_xmmreg { pub element: [__uint32_t; 4usize] }

#[test]
fn bindgen_test_layout__libc_xmmreg() {
    assert_eq!(::std::mem::size_of::<_libc_xmmreg>(), 16usize, concat!( "Size of: " , stringify ! ( _libc_xmmreg ) ));
    assert_eq!(::std::mem::align_of::<_libc_xmmreg>(), 4usize, concat!( "Alignment of " , stringify ! ( _libc_xmmreg ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_libc_xmmreg>())).element as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( _libc_xmmreg ) , "::" , stringify ! ( element ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _libc_fpstate { pub cwd: __uint16_t, pub swd: __uint16_t, pub ftw: __uint16_t, pub fop: __uint16_t, pub rip: __uint64_t, pub rdp: __uint64_t, pub mxcsr: __uint32_t, pub mxcr_mask: __uint32_t, pub _st: [_libc_fpxreg; 8usize], pub _xmm: [_libc_xmmreg; 16usize], pub padding: [__uint32_t; 24usize] }

#[test]
fn bindgen_test_layout__libc_fpstate() {
    assert_eq!(::std::mem::size_of::<_libc_fpstate>(), 512usize, concat!( "Size of: " , stringify ! ( _libc_fpstate ) ));
    assert_eq!(::std::mem::align_of::<_libc_fpstate>(), 8usize, concat!( "Alignment of " , stringify ! ( _libc_fpstate ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).cwd as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( _libc_fpstate ) , "::" , stringify ! ( cwd ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).swd as *const _ as usize }, 2usize, concat!( "Offset of field: " , stringify ! ( _libc_fpstate ) , "::" , stringify ! ( swd ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).ftw as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( _libc_fpstate ) , "::" , stringify ! ( ftw ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).fop as *const _ as usize }, 6usize, concat!( "Offset of field: " , stringify ! ( _libc_fpstate ) , "::" , stringify ! ( fop ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).rip as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( _libc_fpstate ) , "::" , stringify ! ( rip ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).rdp as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( _libc_fpstate ) , "::" , stringify ! ( rdp ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).mxcsr as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( _libc_fpstate ) , "::" , stringify ! ( mxcsr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).mxcr_mask as *const _ as usize }, 28usize, concat!( "Offset of field: " , stringify ! ( _libc_fpstate ) , "::" , stringify ! ( mxcr_mask ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_libc_fpstate>()))._st as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( _libc_fpstate ) , "::" , stringify ! ( _st ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_libc_fpstate>()))._xmm as *const _ as usize }, 160usize, concat!( "Offset of field: " , stringify ! ( _libc_fpstate ) , "::" , stringify ! ( _xmm ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_libc_fpstate>())).padding as *const _ as usize }, 416usize, concat!( "Offset of field: " , stringify ! ( _libc_fpstate ) , "::" , stringify ! ( padding ) ));
}

pub type fpregset_t = *mut _libc_fpstate;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mcontext_t { pub gregs: gregset_t, pub fpregs: fpregset_t, pub __reserved1: [::libc::c_ulonglong; 8usize] }

#[test]
fn bindgen_test_layout_mcontext_t() {
    assert_eq!(::std::mem::size_of::<mcontext_t>(), 256usize, concat!( "Size of: " , stringify ! ( mcontext_t ) ));
    assert_eq!(::std::mem::align_of::<mcontext_t>(), 8usize, concat!( "Alignment of " , stringify ! ( mcontext_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<mcontext_t>())).gregs as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( mcontext_t ) , "::" , stringify ! ( gregs ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<mcontext_t>())).fpregs as *const _ as usize }, 184usize, concat!( "Offset of field: " , stringify ! ( mcontext_t ) , "::" , stringify ! ( fpregs ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<mcontext_t>())).__reserved1 as *const _ as usize }, 192usize, concat!( "Offset of field: " , stringify ! ( mcontext_t ) , "::" , stringify ! ( __reserved1 ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucontext { pub uc_flags: ::libc::c_ulong, pub uc_link: *mut ucontext, pub uc_stack: stack_t, pub uc_mcontext: mcontext_t, pub uc_sigmask: __sigset_t, pub __fpregs_mem: _libc_fpstate }

#[test]
fn bindgen_test_layout_ucontext() {
    assert_eq!(::std::mem::size_of::<ucontext>(), 936usize, concat!( "Size of: " , stringify ! ( ucontext ) ));
    assert_eq!(::std::mem::align_of::<ucontext>(), 8usize, concat!( "Alignment of " , stringify ! ( ucontext ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ucontext>())).uc_flags as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ucontext ) , "::" , stringify ! ( uc_flags ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ucontext>())).uc_link as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ucontext ) , "::" , stringify ! ( uc_link ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ucontext>())).uc_stack as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ucontext ) , "::" , stringify ! ( uc_stack ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ucontext>())).uc_mcontext as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( ucontext ) , "::" , stringify ! ( uc_mcontext ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ucontext>())).uc_sigmask as *const _ as usize }, 296usize, concat!( "Offset of field: " , stringify ! ( ucontext ) , "::" , stringify ! ( uc_sigmask ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ucontext>())).__fpregs_mem as *const _ as usize }, 424usize, concat!( "Offset of field: " , stringify ! ( ucontext ) , "::" , stringify ! ( __fpregs_mem ) ));
}

pub type ucontext_t = ucontext;

pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;

pub type idtype_t = u32;

#[repr(C)]
#[derive(Copy, Clone)]
pub union __WAIT_STATUS { pub __uptr: *mut wait, pub __iptr: *mut ::libc::c_int, _bindgen_union_align: u64 }

#[test]
fn bindgen_test_layout___WAIT_STATUS() {
    assert_eq!(::std::mem::size_of::<__WAIT_STATUS>(), 8usize, concat!( "Size of: " , stringify ! ( __WAIT_STATUS ) ));
    assert_eq!(::std::mem::align_of::<__WAIT_STATUS>(), 8usize, concat!( "Alignment of " , stringify ! ( __WAIT_STATUS ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__WAIT_STATUS>())).__uptr as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( __WAIT_STATUS ) , "::" , stringify ! ( __uptr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__WAIT_STATUS>())).__iptr as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( __WAIT_STATUS ) , "::" , stringify ! ( __iptr ) ));
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union wait { pub w_status: ::libc::c_int, pub __wait_terminated: wait__bindgen_ty_1, pub __wait_stopped: wait__bindgen_ty_2, _bindgen_union_align: u32 }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 { pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>, pub __bindgen_align: [u32; 0usize] }

#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_1>(), 4usize, concat!( "Size of: " , stringify ! ( wait__bindgen_ty_1 ) ));
    assert_eq!(::std::mem::align_of::<wait__bindgen_ty_1>(), 4usize, concat!( "Alignment of " , stringify ! ( wait__bindgen_ty_1 ) ));
}

impl wait__bindgen_ty_1 {
    #[inline]
    pub fn __w_termsig(&self) -> ::libc::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) } }
    #[inline]
    pub fn set___w_termsig(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn __w_coredump(&self) -> ::libc::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) } }
    #[inline]
    pub fn set___w_coredump(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __w_retcode(&self) -> ::libc::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) } }
    #[inline]
    pub fn set___w_retcode(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(__w_termsig: ::libc::c_uint, __w_coredump: ::libc::c_uint, __w_retcode: ::libc::c_uint) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let __w_termsig: u32 = unsafe { ::std::mem::transmute(__w_termsig) };
            __w_termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let __w_coredump: u32 = unsafe { ::std::mem::transmute(__w_coredump) };
            __w_coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let __w_retcode: u32 = unsafe { ::std::mem::transmute(__w_retcode) };
            __w_retcode as u64
        });
        __bindgen_bitfield_unit
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 { pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>, pub __bindgen_align: [u32; 0usize] }

#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<wait__bindgen_ty_2>(), 4usize, concat!( "Size of: " , stringify ! ( wait__bindgen_ty_2 ) ));
    assert_eq!(::std::mem::align_of::<wait__bindgen_ty_2>(), 4usize, concat!( "Alignment of " , stringify ! ( wait__bindgen_ty_2 ) ));
}

impl wait__bindgen_ty_2 {
    #[inline]
    pub fn __w_stopval(&self) -> ::libc::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) } }
    #[inline]
    pub fn set___w_stopval(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn __w_stopsig(&self) -> ::libc::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) } }
    #[inline]
    pub fn set___w_stopsig(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(__w_stopval: ::libc::c_uint, __w_stopsig: ::libc::c_uint) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let __w_stopval: u32 = unsafe { ::std::mem::transmute(__w_stopval) };
            __w_stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let __w_stopsig: u32 = unsafe { ::std::mem::transmute(__w_stopsig) };
            __w_stopsig as u64
        });
        __bindgen_bitfield_unit
    }
}

#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(::std::mem::size_of::<wait>(), 4usize, concat!( "Size of: " , stringify ! ( wait ) ));
    assert_eq!(::std::mem::align_of::<wait>(), 4usize, concat!( "Alignment of " , stringify ! ( wait ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<wait>())).w_status as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( wait ) , "::" , stringify ! ( w_status ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<wait>())).__wait_terminated as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( wait ) , "::" , stringify ! ( __wait_terminated ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<wait>())).__wait_stopped as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( wait ) , "::" , stringify ! ( __wait_stopped ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage { _unused: [u8; 0] }

pub type apr_byte_t = ::libc::c_uchar;
pub type apr_int16_t = ::libc::c_short;
pub type apr_uint16_t = ::libc::c_ushort;
pub type apr_int32_t = ::libc::c_int;
pub type apr_uint32_t = ::libc::c_uint;
pub type apr_int64_t = ::libc::c_long;
pub type apr_uint64_t = ::libc::c_ulong;
pub type apr_size_t = usize;
pub type apr_ssize_t = isize;
pub type apr_off_t = off_t;
pub type apr_socklen_t = socklen_t;
pub type apr_ino_t = ino_t;
pub type apr_uintptr_t = apr_uint64_t;
/// Type for specifying an error or status code.
pub type apr_status_t = ::libc::c_int;
/// signal numbers typedef
pub type apr_signum_t = ::libc::c_int;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct { pub __locales: [*mut __locale_data; 13usize], pub __ctype_b: *const ::libc::c_ushort, pub __ctype_tolower: *const ::libc::c_int, pub __ctype_toupper: *const ::libc::c_int, pub __names: [*const ::libc::c_char; 13usize] }

#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(::std::mem::size_of::<__locale_struct>(), 232usize, concat!( "Size of: " , stringify ! ( __locale_struct ) ));
    assert_eq!(::std::mem::align_of::<__locale_struct>(), 8usize, concat!( "Alignment of " , stringify ! ( __locale_struct ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __locales ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize }, 104usize, concat!( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __ctype_b ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize }, 112usize, concat!( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __ctype_tolower ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize }, 120usize, concat!( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __ctype_toupper ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize }, 128usize, concat!( "Offset of field: " , stringify ! ( __locale_struct ) , "::" , stringify ! ( __names ) ));
}

pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_pool_t { _unused: [u8; 0] }

/// A function that is called when allocation fails.
pub type apr_abortfunc_t = ::std::option::Option<unsafe extern "C" fn(retcode: ::libc::c_int) -> ::libc::c_int>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_allocator_t { _unused: [u8; 0] }

/// basic memory node structure
/// @note The next, ref and first_avail fields are available for use by the
/// caller of apr_allocator_alloc(), the remaining fields are read-only.
/// The next field has to be used with caution and sensibly set when the
/// memnode is passed back to apr_allocator_free().  See apr_allocator_free()
/// for details.
/// The ref and first_avail fields will be properly restored by
/// apr_allocator_free().
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_memnode_t {
    /// < next memnode
    pub next: *mut apr_memnode_t,
    /// < reference to self
    pub ref_: *mut *mut apr_memnode_t,
    /// < size
    pub index: apr_uint32_t,
    /// < how much free
    pub free_index: apr_uint32_t,
    /// < pointer to first free memory
    pub first_avail: *mut ::libc::c_char,
    /// < pointer to end of free memory
    pub endp: *mut ::libc::c_char,
}

#[test]
fn bindgen_test_layout_apr_memnode_t() {
    assert_eq!(::std::mem::size_of::<apr_memnode_t>(), 40usize, concat!( "Size of: " , stringify ! ( apr_memnode_t ) ));
    assert_eq!(::std::mem::align_of::<apr_memnode_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_memnode_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_memnode_t>())).next as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_memnode_t ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_memnode_t>())).ref_ as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_memnode_t ) , "::" , stringify ! ( ref_ ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_memnode_t>())).index as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_memnode_t ) , "::" , stringify ! ( index ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_memnode_t>())).free_index as *const _ as usize }, 20usize, concat!( "Offset of field: " , stringify ! ( apr_memnode_t ) , "::" , stringify ! ( free_index ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_memnode_t>())).first_avail as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_memnode_t ) , "::" , stringify ! ( first_avail ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_memnode_t>())).endp as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( apr_memnode_t ) , "::" , stringify ! ( endp ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_thread_mutex_t { _unused: [u8; 0] }

pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_table_t { _unused: [u8; 0] }

/// An opaque array type
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_array_header_t {
    /// The pool the array is allocated out of
    pub pool: *mut apr_pool_t,
    /// The amount of memory allocated for each element of the array
    pub elt_size: ::libc::c_int,
    /// The number of active elements in the array
    pub nelts: ::libc::c_int,
    /// The number of elements allocated in the array
    pub nalloc: ::libc::c_int,
    /// The elements in the array
    pub elts: *mut ::libc::c_char,
}

#[test]
fn bindgen_test_layout_apr_array_header_t() {
    assert_eq!(::std::mem::size_of::<apr_array_header_t>(), 32usize, concat!( "Size of: " , stringify ! ( apr_array_header_t ) ));
    assert_eq!(::std::mem::align_of::<apr_array_header_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_array_header_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_array_header_t>())).pool as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_array_header_t ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_array_header_t>())).elt_size as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_array_header_t ) , "::" , stringify ! ( elt_size ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_array_header_t>())).nelts as *const _ as usize }, 12usize, concat!( "Offset of field: " , stringify ! ( apr_array_header_t ) , "::" , stringify ! ( nelts ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_array_header_t>())).nalloc as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_array_header_t ) , "::" , stringify ! ( nalloc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_array_header_t>())).elts as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_array_header_t ) , "::" , stringify ! ( elts ) ));
}

/// The type for each entry in a string-content table
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_table_entry_t {
    /// The key for the current table entry
    pub key: *mut ::libc::c_char,
    /// The value for the current table entry
    pub val: *mut ::libc::c_char,
    /// A checksum for the key, for use by the apr_table internals
    pub key_checksum: apr_uint32_t,
}

#[test]
fn bindgen_test_layout_apr_table_entry_t() {
    assert_eq!(::std::mem::size_of::<apr_table_entry_t>(), 24usize, concat!( "Size of: " , stringify ! ( apr_table_entry_t ) ));
    assert_eq!(::std::mem::align_of::<apr_table_entry_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_table_entry_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_table_entry_t>())).key as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_table_entry_t ) , "::" , stringify ! ( key ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_table_entry_t>())).val as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_table_entry_t ) , "::" , stringify ! ( val ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_table_entry_t>())).key_checksum as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_table_entry_t ) , "::" , stringify ! ( key_checksum ) ));
}

/// Declaration prototype for the iterator callback function of apr_table_do()
/// and apr_table_vdo().
/// @param rec The data passed as the first argument to apr_table_[v]do()
/// @param key The key from this iteration of the table
/// @param value The value from this iteration of the table
/// @remark Iteration continues while this callback function returns non-zero.
/// To export the callback function for apr_table_[v]do() it must be declared
/// in the _NONSTD convention.
pub type apr_table_do_callback_fn_t = ::std::option::Option<unsafe extern "C" fn(rec: *mut ::libc::c_void, key: *const ::libc::c_char, value: *const ::libc::c_char) -> ::libc::c_int>;

extern "C" {
    #[link_name = "\u{1}apr_hook_global_pool"]
    pub static mut apr_hook_global_pool: *mut apr_pool_t;
}

extern "C" {
    #[link_name = "\u{1}apr_hook_debug_enabled"]
    pub static mut apr_hook_debug_enabled: ::libc::c_int;
}

extern "C" {
    #[link_name = "\u{1}apr_hook_debug_current"]
    pub static mut apr_hook_debug_current: *const ::libc::c_char;
}

extern "C" {
    #[link_name = "\u{1}apr_month_snames"]
    pub static mut apr_month_snames: [[::libc::c_char; 4usize]; 12usize];
}

extern "C" {
    #[link_name = "\u{1}apr_day_snames"]
    pub static mut apr_day_snames: [[::libc::c_char; 4usize]; 7usize];
}

/// number of microseconds since 00:00:00 january 1, 1970 UTC
pub type apr_time_t = apr_int64_t;
/// intervals for I/O timeouts, in microseconds
pub type apr_interval_time_t = apr_int64_t;
/// short interval for I/O timeouts, in microseconds
pub type apr_short_interval_time_t = apr_int32_t;

/// a structure similar to ANSI struct tm with the following differences:
/// - tm_usec isn't an ANSI field
/// - tm_gmtoff isn't an ANSI field (it's a bsdism)
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_time_exp_t {
    /// microseconds past tm_sec
    pub tm_usec: apr_int32_t,
    /// (0-61) seconds past tm_min
    pub tm_sec: apr_int32_t,
    /// (0-59) minutes past tm_hour
    pub tm_min: apr_int32_t,
    /// (0-23) hours past midnight
    pub tm_hour: apr_int32_t,
    /// (1-31) day of the month
    pub tm_mday: apr_int32_t,
    /// (0-11) month of the year
    pub tm_mon: apr_int32_t,
    /// year since 1900
    pub tm_year: apr_int32_t,
    /// (0-6) days since sunday
    pub tm_wday: apr_int32_t,
    /// (0-365) days since jan 1
    pub tm_yday: apr_int32_t,
    /// daylight saving time
    pub tm_isdst: apr_int32_t,
    /// seconds east of UTC
    pub tm_gmtoff: apr_int32_t,
}

#[test]
fn bindgen_test_layout_apr_time_exp_t() {
    assert_eq!(::std::mem::size_of::<apr_time_exp_t>(), 44usize, concat!( "Size of: " , stringify ! ( apr_time_exp_t ) ));
    assert_eq!(::std::mem::align_of::<apr_time_exp_t>(), 4usize, concat!( "Alignment of " , stringify ! ( apr_time_exp_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_usec as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_usec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_sec as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_sec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_min as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_min ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_hour as *const _ as usize }, 12usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_hour ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_mday as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_mday ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_mon as *const _ as usize }, 20usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_mon ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_year as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_year ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_wday as *const _ as usize }, 28usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_wday ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_yday as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_yday ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_isdst as *const _ as usize }, 36usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_isdst ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_gmtoff as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_gmtoff ) ));
}

pub type apr_uid_t = uid_t;
pub type apr_gid_t = gid_t;

/// < no file type determined
pub const apr_filetype_e_APR_NOFILE: apr_filetype_e = 0;
/// < a regular file
pub const apr_filetype_e_APR_REG: apr_filetype_e = 1;
/// < a directory
pub const apr_filetype_e_APR_DIR: apr_filetype_e = 2;
/// < a character device
pub const apr_filetype_e_APR_CHR: apr_filetype_e = 3;
/// < a block device
pub const apr_filetype_e_APR_BLK: apr_filetype_e = 4;
/// < a FIFO / pipe
pub const apr_filetype_e_APR_PIPE: apr_filetype_e = 5;
/// < a symbolic link
pub const apr_filetype_e_APR_LNK: apr_filetype_e = 6;
/// < a [unix domain] socket
pub const apr_filetype_e_APR_SOCK: apr_filetype_e = 7;
/// < a file of some other unknown type
pub const apr_filetype_e_APR_UNKFILE: apr_filetype_e = 127;

/// apr_filetype_e values for the filetype member of the
/// apr_file_info_t structure
/// @warning: Not all of the filetypes below can be determined.
/// For example, a given platform might not correctly report
/// a socket descriptor as APR_SOCK if that type isn't
/// well-identified on that platform.  In such cases where
/// a filetype exists but cannot be described by the recognized
/// flags below, the filetype will be APR_UNKFILE.  If the
/// filetype member is not determined, the type will be APR_NOFILE.
pub type apr_filetype_e = u32;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_dir_t { _unused: [u8; 0] }

/// Structure for determining file permissions.
pub type apr_fileperms_t = apr_int32_t;
/// Structure for determining the device the file is on.
pub type apr_dev_t = dev_t;

/// The file information structure.  This is analogous to the POSIX
/// stat structure.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_finfo_t {
    /// Allocates memory and closes lingering handles in the specified pool
    pub pool: *mut apr_pool_t,
    /// The bitmask describing valid fields of this apr_finfo_t structure
    /// including all available 'wanted' fields and potentially more
    pub valid: apr_int32_t,
    /// The access permissions of the file.  Mimics Unix access rights.
    pub protection: apr_fileperms_t,
    /// The type of file.  One of APR_REG, APR_DIR, APR_CHR, APR_BLK, APR_PIPE,
    /// APR_LNK or APR_SOCK.  If the type is undetermined, the value is APR_NOFILE.
    /// If the type cannot be determined, the value is APR_UNKFILE.
    pub filetype: apr_filetype_e,
    /// The user id that owns the file
    pub user: apr_uid_t,
    /// The group id that owns the file
    pub group: apr_gid_t,
    /// The inode of the file.
    pub inode: apr_ino_t,
    /// The id of the device the file is on.
    pub device: apr_dev_t,
    /// The number of hard links to the file.
    pub nlink: apr_int32_t,
    /// The size of the file
    pub size: apr_off_t,
    /// The storage size consumed by the file
    pub csize: apr_off_t,
    /// The time the file was last accessed
    pub atime: apr_time_t,
    /// The time the file was last modified
    pub mtime: apr_time_t,
    /// The time the file was created, or the inode was last changed
    pub ctime: apr_time_t,
    /// The pathname of the file (possibly unrooted)
    pub fname: *const ::libc::c_char,
    /// The file's name (no path) in filesystem case
    pub name: *const ::libc::c_char,
    /// The file's handle, if accessed (can be submitted to apr_duphandle)
    pub filehand: *mut apr_file_t,
}

#[test]
fn bindgen_test_layout_apr_finfo_t() {
    assert_eq!(::std::mem::size_of::<apr_finfo_t>(), 120usize, concat!( "Size of: " , stringify ! ( apr_finfo_t ) ));
    assert_eq!(::std::mem::align_of::<apr_finfo_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_finfo_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).pool as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).valid as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( valid ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).protection as *const _ as usize }, 12usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( protection ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).filetype as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( filetype ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).user as *const _ as usize }, 20usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( user ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).group as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( group ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).inode as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( inode ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).device as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( device ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).nlink as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( nlink ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).size as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( size ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).csize as *const _ as usize }, 64usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( csize ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).atime as *const _ as usize }, 72usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( atime ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).mtime as *const _ as usize }, 80usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( mtime ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).ctime as *const _ as usize }, 88usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( ctime ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).fname as *const _ as usize }, 96usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( fname ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).name as *const _ as usize }, 104usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( name ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).filehand as *const _ as usize }, 112usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( filehand ) ));
}

pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t { pub __count: ::libc::c_int, pub __value: __mbstate_t__bindgen_ty_1 }

#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 { pub __wch: ::libc::c_uint, pub __wchb: [::libc::c_char; 4usize], _bindgen_union_align: u32 }

#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(), 4usize, concat!( "Size of: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ));
    assert_eq!(::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(), 4usize, concat!( "Alignment of " , stringify ! ( __mbstate_t__bindgen_ty_1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wch ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( __mbstate_t__bindgen_ty_1 ) , "::" , stringify ! ( __wchb ) ));
}

#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::std::mem::size_of::<__mbstate_t>(), 8usize, concat!( "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq!(::std::mem::align_of::<__mbstate_t>(), 4usize, concat!( "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( __mbstate_t ) , "::" , stringify ! ( __count ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( __mbstate_t ) , "::" , stringify ! ( __value ) ));
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t { pub __pos: __off_t, pub __state: __mbstate_t }

#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos_t>(), 16usize, concat!( "Size of: " , stringify ! ( _G_fpos_t ) ));
    assert_eq!(::std::mem::align_of::<_G_fpos_t>(), 8usize, concat!( "Alignment of " , stringify ! ( _G_fpos_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( _G_fpos_t ) , "::" , stringify ! ( __pos ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( _G_fpos_t ) , "::" , stringify ! ( __state ) ));
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t { pub __pos: __off64_t, pub __state: __mbstate_t }

#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(::std::mem::size_of::<_G_fpos64_t>(), 16usize, concat!( "Size of: " , stringify ! ( _G_fpos64_t ) ));
    assert_eq!(::std::mem::align_of::<_G_fpos64_t>(), 8usize, concat!( "Alignment of " , stringify ! ( _G_fpos64_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( _G_fpos64_t ) , "::" , stringify ! ( __pos ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( _G_fpos64_t ) , "::" , stringify ! ( __state ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t { _unused: [u8; 0] }

pub type _IO_lock_t = ::libc::c_void;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker { pub _next: *mut _IO_marker, pub _sbuf: *mut _IO_FILE, pub _pos: ::libc::c_int }

#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(::std::mem::size_of::<_IO_marker>(), 24usize, concat!( "Size of: " , stringify ! ( _IO_marker ) ));
    assert_eq!(::std::mem::align_of::<_IO_marker>(), 8usize, concat!( "Alignment of " , stringify ! ( _IO_marker ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_marker>()))._next as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( _IO_marker ) , "::" , stringify ! ( _next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_marker>()))._sbuf as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( _IO_marker ) , "::" , stringify ! ( _sbuf ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_marker>()))._pos as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( _IO_marker ) , "::" , stringify ! ( _pos ) ));
}

pub const __codecvt_result___codecvt_ok: __codecvt_result = 0;
pub const __codecvt_result___codecvt_partial: __codecvt_result = 1;
pub const __codecvt_result___codecvt_error: __codecvt_result = 2;
pub const __codecvt_result___codecvt_noconv: __codecvt_result = 3;

pub type __codecvt_result = u32;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE { pub _flags: ::libc::c_int, pub _IO_read_ptr: *mut ::libc::c_char, pub _IO_read_end: *mut ::libc::c_char, pub _IO_read_base: *mut ::libc::c_char, pub _IO_write_base: *mut ::libc::c_char, pub _IO_write_ptr: *mut ::libc::c_char, pub _IO_write_end: *mut ::libc::c_char, pub _IO_buf_base: *mut ::libc::c_char, pub _IO_buf_end: *mut ::libc::c_char, pub _IO_save_base: *mut ::libc::c_char, pub _IO_backup_base: *mut ::libc::c_char, pub _IO_save_end: *mut ::libc::c_char, pub _markers: *mut _IO_marker, pub _chain: *mut _IO_FILE, pub _fileno: ::libc::c_int, pub _flags2: ::libc::c_int, pub _old_offset: __off_t, pub _cur_column: ::libc::c_ushort, pub _vtable_offset: ::libc::c_schar, pub _shortbuf: [::libc::c_char; 1usize], pub _lock: *mut _IO_lock_t, pub _offset: __off64_t, pub __pad1: *mut ::libc::c_void, pub __pad2: *mut ::libc::c_void, pub __pad3: *mut ::libc::c_void, pub __pad4: *mut ::libc::c_void, pub __pad5: usize, pub _mode: ::libc::c_int, pub _unused2: [::libc::c_char; 20usize] }

#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(::std::mem::size_of::<_IO_FILE>(), 216usize, concat!( "Size of: " , stringify ! ( _IO_FILE ) ));
    assert_eq!(::std::mem::align_of::<_IO_FILE>(), 8usize, concat!( "Alignment of " , stringify ! ( _IO_FILE ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _flags ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_read_ptr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_read_end ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_read_base ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_write_base ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_write_ptr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_write_end ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_buf_base ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize }, 64usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_buf_end ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize }, 72usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_save_base ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize }, 80usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_backup_base ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize }, 88usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _IO_save_end ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize }, 96usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _markers ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize }, 104usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _chain ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize }, 112usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _fileno ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize }, 116usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _flags2 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize }, 120usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _old_offset ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize }, 128usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _cur_column ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize }, 130usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _vtable_offset ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize }, 131usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _shortbuf ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize }, 136usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _lock ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize }, 144usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _offset ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad1 as *const _ as usize }, 152usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad2 as *const _ as usize }, 160usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad2 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad3 as *const _ as usize }, 168usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad3 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad4 as *const _ as usize }, 176usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad4 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize }, 184usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( __pad5 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize }, 192usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _mode ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize }, 196usize, concat!( "Offset of field: " , stringify ! ( _IO_FILE ) , "::" , stringify ! ( _unused2 ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus { _unused: [u8; 0] }

extern "C" {
    #[link_name = "\u{1}_IO_2_1_stdin_"]
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}

extern "C" {
    #[link_name = "\u{1}_IO_2_1_stdout_"]
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}

extern "C" {
    #[link_name = "\u{1}_IO_2_1_stderr_"]
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}

pub type __io_read_fn = ::std::option::Option<unsafe extern "C" fn(__cookie: *mut ::libc::c_void, __buf: *mut ::libc::c_char, __nbytes: usize) -> __ssize_t>;
pub type __io_write_fn = ::std::option::Option<unsafe extern "C" fn(__cookie: *mut ::libc::c_void, __buf: *const ::libc::c_char, __n: usize) -> __ssize_t>;
pub type __io_seek_fn = ::std::option::Option<unsafe extern "C" fn(__cookie: *mut ::libc::c_void, __pos: *mut __off64_t, __w: ::libc::c_int) -> ::libc::c_int>;
pub type __io_close_fn = ::std::option::Option<unsafe extern "C" fn(__cookie: *mut ::libc::c_void) -> ::libc::c_int>;
pub type cookie_read_function_t = __io_read_fn;
pub type cookie_write_function_t = __io_write_fn;
pub type cookie_seek_function_t = __io_seek_fn;
pub type cookie_close_function_t = __io_close_fn;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_io_functions_t { pub read: __io_read_fn, pub write: __io_write_fn, pub seek: __io_seek_fn, pub close: __io_close_fn }

#[test]
fn bindgen_test_layout__IO_cookie_io_functions_t() {
    assert_eq!(::std::mem::size_of::<_IO_cookie_io_functions_t>(), 32usize, concat!( "Size of: " , stringify ! ( _IO_cookie_io_functions_t ) ));
    assert_eq!(::std::mem::align_of::<_IO_cookie_io_functions_t>(), 8usize, concat!( "Alignment of " , stringify ! ( _IO_cookie_io_functions_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_cookie_io_functions_t>())).read as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( _IO_cookie_io_functions_t ) , "::" , stringify ! ( read ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_cookie_io_functions_t>())).write as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( _IO_cookie_io_functions_t ) , "::" , stringify ! ( write ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_cookie_io_functions_t>())).seek as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( _IO_cookie_io_functions_t ) , "::" , stringify ! ( seek ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<_IO_cookie_io_functions_t>())).close as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( _IO_cookie_io_functions_t ) , "::" , stringify ! ( close ) ));
}

pub type cookie_io_functions_t = _IO_cookie_io_functions_t;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_cookie_file { _unused: [u8; 0] }

pub type fpos_t = _G_fpos_t;

extern "C" {
    #[link_name = "\u{1}stdin"]
    pub static mut stdin: *mut _IO_FILE;
}

extern "C" {
    #[link_name = "\u{1}stdout"]
    pub static mut stdout: *mut _IO_FILE;
}

extern "C" {
    #[link_name = "\u{1}stderr"]
    pub static mut stderr: *mut _IO_FILE;
}

extern "C" {
    #[link_name = "\u{1}sys_nerr"]
    pub static mut sys_nerr: ::libc::c_int;
}

extern "C" {
    #[link_name = "\u{1}sys_errlist"]
    pub static mut sys_errlist: [*const ::libc::c_char; 0usize];
}

/// File attributes
pub type apr_fileattrs_t = apr_uint32_t;
/// Type to pass as whence argument to apr_file_seek.
pub type apr_seek_where_t = ::libc::c_int;
pub type in_addr_t = u32;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_addr { pub s_addr: in_addr_t }

#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(::std::mem::size_of::<in_addr>(), 4usize, concat!( "Size of: " , stringify ! ( in_addr ) ));
    assert_eq!(::std::mem::align_of::<in_addr>(), 4usize, concat!( "Alignment of " , stringify ! ( in_addr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<in_addr>())).s_addr as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( in_addr ) , "::" , stringify ! ( s_addr ) ));
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_opts { pub ip_dst: in_addr, pub ip_opts: [::libc::c_char; 40usize] }

#[test]
fn bindgen_test_layout_ip_opts() {
    assert_eq!(::std::mem::size_of::<ip_opts>(), 44usize, concat!( "Size of: " , stringify ! ( ip_opts ) ));
    assert_eq!(::std::mem::align_of::<ip_opts>(), 4usize, concat!( "Alignment of " , stringify ! ( ip_opts ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ip_opts>())).ip_dst as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ip_opts ) , "::" , stringify ! ( ip_dst ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ip_opts>())).ip_opts as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( ip_opts ) , "::" , stringify ! ( ip_opts ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreqn { pub imr_multiaddr: in_addr, pub imr_address: in_addr, pub imr_ifindex: ::libc::c_int }

#[test]
fn bindgen_test_layout_ip_mreqn() {
    assert_eq!(::std::mem::size_of::<ip_mreqn>(), 12usize, concat!( "Size of: " , stringify ! ( ip_mreqn ) ));
    assert_eq!(::std::mem::align_of::<ip_mreqn>(), 4usize, concat!( "Alignment of " , stringify ! ( ip_mreqn ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_multiaddr as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ip_mreqn ) , "::" , stringify ! ( imr_multiaddr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_address as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( ip_mreqn ) , "::" , stringify ! ( imr_address ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ip_mreqn>())).imr_ifindex as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ip_mreqn ) , "::" , stringify ! ( imr_ifindex ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct in_pktinfo { pub ipi_ifindex: ::libc::c_int, pub ipi_spec_dst: in_addr, pub ipi_addr: in_addr }

#[test]
fn bindgen_test_layout_in_pktinfo() {
    assert_eq!(::std::mem::size_of::<in_pktinfo>(), 12usize, concat!( "Size of: " , stringify ! ( in_pktinfo ) ));
    assert_eq!(::std::mem::align_of::<in_pktinfo>(), 4usize, concat!( "Alignment of " , stringify ! ( in_pktinfo ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_ifindex as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( in_pktinfo ) , "::" , stringify ! ( ipi_ifindex ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_spec_dst as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( in_pktinfo ) , "::" , stringify ! ( ipi_spec_dst ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<in_pktinfo>())).ipi_addr as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( in_pktinfo ) , "::" , stringify ! ( ipi_addr ) ));
}

pub const IPPROTO_IP: _bindgen_ty_13 = 0;
pub const IPPROTO_ICMP: _bindgen_ty_13 = 1;
pub const IPPROTO_IGMP: _bindgen_ty_13 = 2;
pub const IPPROTO_IPIP: _bindgen_ty_13 = 4;
pub const IPPROTO_TCP: _bindgen_ty_13 = 6;
pub const IPPROTO_EGP: _bindgen_ty_13 = 8;
pub const IPPROTO_PUP: _bindgen_ty_13 = 12;
pub const IPPROTO_UDP: _bindgen_ty_13 = 17;
pub const IPPROTO_IDP: _bindgen_ty_13 = 22;
pub const IPPROTO_TP: _bindgen_ty_13 = 29;
pub const IPPROTO_DCCP: _bindgen_ty_13 = 33;
pub const IPPROTO_IPV6: _bindgen_ty_13 = 41;
pub const IPPROTO_RSVP: _bindgen_ty_13 = 46;
pub const IPPROTO_GRE: _bindgen_ty_13 = 47;
pub const IPPROTO_ESP: _bindgen_ty_13 = 50;
pub const IPPROTO_AH: _bindgen_ty_13 = 51;
pub const IPPROTO_MTP: _bindgen_ty_13 = 92;
pub const IPPROTO_BEETPH: _bindgen_ty_13 = 94;
pub const IPPROTO_ENCAP: _bindgen_ty_13 = 98;
pub const IPPROTO_PIM: _bindgen_ty_13 = 103;
pub const IPPROTO_COMP: _bindgen_ty_13 = 108;
pub const IPPROTO_SCTP: _bindgen_ty_13 = 132;
pub const IPPROTO_UDPLITE: _bindgen_ty_13 = 136;
pub const IPPROTO_MPLS: _bindgen_ty_13 = 137;
pub const IPPROTO_RAW: _bindgen_ty_13 = 255;
pub const IPPROTO_MAX: _bindgen_ty_13 = 256;

pub type _bindgen_ty_13 = u32;

pub const IPPROTO_HOPOPTS: _bindgen_ty_14 = 0;
pub const IPPROTO_ROUTING: _bindgen_ty_14 = 43;
pub const IPPROTO_FRAGMENT: _bindgen_ty_14 = 44;
pub const IPPROTO_ICMPV6: _bindgen_ty_14 = 58;
pub const IPPROTO_NONE: _bindgen_ty_14 = 59;
pub const IPPROTO_DSTOPTS: _bindgen_ty_14 = 60;
pub const IPPROTO_MH: _bindgen_ty_14 = 135;

pub type _bindgen_ty_14 = u32;
pub type in_port_t = u16;

pub const IPPORT_ECHO: _bindgen_ty_15 = 7;
pub const IPPORT_DISCARD: _bindgen_ty_15 = 9;
pub const IPPORT_SYSTAT: _bindgen_ty_15 = 11;
pub const IPPORT_DAYTIME: _bindgen_ty_15 = 13;
pub const IPPORT_NETSTAT: _bindgen_ty_15 = 15;
pub const IPPORT_FTP: _bindgen_ty_15 = 21;
pub const IPPORT_TELNET: _bindgen_ty_15 = 23;
pub const IPPORT_SMTP: _bindgen_ty_15 = 25;
pub const IPPORT_TIMESERVER: _bindgen_ty_15 = 37;
pub const IPPORT_NAMESERVER: _bindgen_ty_15 = 42;
pub const IPPORT_WHOIS: _bindgen_ty_15 = 43;
pub const IPPORT_MTP: _bindgen_ty_15 = 57;
pub const IPPORT_TFTP: _bindgen_ty_15 = 69;
pub const IPPORT_RJE: _bindgen_ty_15 = 77;
pub const IPPORT_FINGER: _bindgen_ty_15 = 79;
pub const IPPORT_TTYLINK: _bindgen_ty_15 = 87;
pub const IPPORT_SUPDUP: _bindgen_ty_15 = 95;
pub const IPPORT_EXECSERVER: _bindgen_ty_15 = 512;
pub const IPPORT_LOGINSERVER: _bindgen_ty_15 = 513;
pub const IPPORT_CMDSERVER: _bindgen_ty_15 = 514;
pub const IPPORT_EFSSERVER: _bindgen_ty_15 = 520;
pub const IPPORT_BIFFUDP: _bindgen_ty_15 = 512;
pub const IPPORT_WHOSERVER: _bindgen_ty_15 = 513;
pub const IPPORT_ROUTESERVER: _bindgen_ty_15 = 520;
pub const IPPORT_RESERVED: _bindgen_ty_15 = 1024;
pub const IPPORT_USERRESERVED: _bindgen_ty_15 = 5000;

pub type _bindgen_ty_15 = u32;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr { pub __in6_u: in6_addr__bindgen_ty_1 }

#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 { pub __u6_addr8: [u8; 16usize], pub __u6_addr16: [u16; 8usize], pub __u6_addr32: [u32; 4usize], _bindgen_union_align: [u32; 4usize] }

#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<in6_addr__bindgen_ty_1>(), 16usize, concat!( "Size of: " , stringify ! ( in6_addr__bindgen_ty_1 ) ));
    assert_eq!(::std::mem::align_of::<in6_addr__bindgen_ty_1>(), 4usize, concat!( "Alignment of " , stringify ! ( in6_addr__bindgen_ty_1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr8 as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( in6_addr__bindgen_ty_1 ) , "::" , stringify ! ( __u6_addr8 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr16 as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( in6_addr__bindgen_ty_1 ) , "::" , stringify ! ( __u6_addr16 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr32 as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( in6_addr__bindgen_ty_1 ) , "::" , stringify ! ( __u6_addr32 ) ));
}

#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(::std::mem::size_of::<in6_addr>(), 16usize, concat!( "Size of: " , stringify ! ( in6_addr ) ));
    assert_eq!(::std::mem::align_of::<in6_addr>(), 4usize, concat!( "Alignment of " , stringify ! ( in6_addr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<in6_addr>())).__in6_u as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( in6_addr ) , "::" , stringify ! ( __in6_u ) ));
}

extern "C" {
    #[link_name = "\u{1}in6addr_any"]
    pub static mut in6addr_any: in6_addr;
}

extern "C" {
    #[link_name = "\u{1}in6addr_loopback"]
    pub static mut in6addr_loopback: in6_addr;
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sockaddr_in { pub sin_family: sa_family_t, pub sin_port: in_port_t, pub sin_addr: in_addr, pub sin_zero: [::libc::c_uchar; 8usize] }

#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(::std::mem::size_of::<sockaddr_in>(), 16usize, concat!( "Size of: " , stringify ! ( sockaddr_in ) ));
    assert_eq!(::std::mem::align_of::<sockaddr_in>(), 4usize, concat!( "Alignment of " , stringify ! ( sockaddr_in ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_family as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( sockaddr_in ) , "::" , stringify ! ( sin_family ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_port as *const _ as usize }, 2usize, concat!( "Offset of field: " , stringify ! ( sockaddr_in ) , "::" , stringify ! ( sin_port ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_addr as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( sockaddr_in ) , "::" , stringify ! ( sin_addr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_zero as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( sockaddr_in ) , "::" , stringify ! ( sin_zero ) ));
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 { pub sin6_family: sa_family_t, pub sin6_port: in_port_t, pub sin6_flowinfo: u32, pub sin6_addr: ::libc::in6_addr, pub sin6_scope_id: u32 }

#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(::std::mem::size_of::<sockaddr_in6>(), 28usize, concat!( "Size of: " , stringify ! ( sockaddr_in6 ) ));
    assert_eq!(::std::mem::align_of::<sockaddr_in6>(), 4usize, concat!( "Alignment of " , stringify ! ( sockaddr_in6 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_family as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( sockaddr_in6 ) , "::" , stringify ! ( sin6_family ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_port as *const _ as usize }, 2usize, concat!( "Offset of field: " , stringify ! ( sockaddr_in6 ) , "::" , stringify ! ( sin6_port ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_flowinfo as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( sockaddr_in6 ) , "::" , stringify ! ( sin6_flowinfo ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_addr as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( sockaddr_in6 ) , "::" , stringify ! ( sin6_addr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_scope_id as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( sockaddr_in6 ) , "::" , stringify ! ( sin6_scope_id ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq { pub imr_multiaddr: in_addr, pub imr_interface: in_addr }

#[test]
fn bindgen_test_layout_ip_mreq() {
    assert_eq!(::std::mem::size_of::<ip_mreq>(), 8usize, concat!( "Size of: " , stringify ! ( ip_mreq ) ));
    assert_eq!(::std::mem::align_of::<ip_mreq>(), 4usize, concat!( "Alignment of " , stringify ! ( ip_mreq ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ip_mreq>())).imr_multiaddr as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ip_mreq ) , "::" , stringify ! ( imr_multiaddr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ip_mreq>())).imr_interface as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( ip_mreq ) , "::" , stringify ! ( imr_interface ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_mreq_source { pub imr_multiaddr: in_addr, pub imr_interface: in_addr, pub imr_sourceaddr: in_addr }

#[test]
fn bindgen_test_layout_ip_mreq_source() {
    assert_eq!(::std::mem::size_of::<ip_mreq_source>(), 12usize, concat!( "Size of: " , stringify ! ( ip_mreq_source ) ));
    assert_eq!(::std::mem::align_of::<ip_mreq_source>(), 4usize, concat!( "Alignment of " , stringify ! ( ip_mreq_source ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_multiaddr as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ip_mreq_source ) , "::" , stringify ! ( imr_multiaddr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_interface as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( ip_mreq_source ) , "::" , stringify ! ( imr_interface ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ip_mreq_source>())).imr_sourceaddr as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ip_mreq_source ) , "::" , stringify ! ( imr_sourceaddr ) ));
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ipv6_mreq { pub ipv6mr_multiaddr: in6_addr, pub ipv6mr_interface: ::libc::c_uint }

#[test]
fn bindgen_test_layout_ipv6_mreq() {
    assert_eq!(::std::mem::size_of::<ipv6_mreq>(), 20usize, concat!( "Size of: " , stringify ! ( ipv6_mreq ) ));
    assert_eq!(::std::mem::align_of::<ipv6_mreq>(), 4usize, concat!( "Alignment of " , stringify ! ( ipv6_mreq ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ipv6_mreq>())).ipv6mr_multiaddr as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ipv6_mreq ) , "::" , stringify ! ( ipv6mr_multiaddr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ipv6_mreq>())).ipv6mr_interface as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ipv6_mreq ) , "::" , stringify ! ( ipv6mr_interface ) ));
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct group_req { pub gr_interface: u32, pub gr_group: sockaddr_storage }

#[test]
fn bindgen_test_layout_group_req() {
    assert_eq!(::std::mem::size_of::<group_req>(), 136usize, concat!( "Size of: " , stringify ! ( group_req ) ));
    assert_eq!(::std::mem::align_of::<group_req>(), 8usize, concat!( "Alignment of " , stringify ! ( group_req ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<group_req>())).gr_interface as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( group_req ) , "::" , stringify ! ( gr_interface ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<group_req>())).gr_group as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( group_req ) , "::" , stringify ! ( gr_group ) ));
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct group_source_req { pub gsr_interface: u32, pub gsr_group: sockaddr_storage, pub gsr_source: sockaddr_storage }

#[test]
fn bindgen_test_layout_group_source_req() {
    assert_eq!(::std::mem::size_of::<group_source_req>(), 264usize, concat!( "Size of: " , stringify ! ( group_source_req ) ));
    assert_eq!(::std::mem::align_of::<group_source_req>(), 8usize, concat!( "Alignment of " , stringify ! ( group_source_req ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_interface as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( group_source_req ) , "::" , stringify ! ( gsr_interface ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_group as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( group_source_req ) , "::" , stringify ! ( gsr_group ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<group_source_req>())).gsr_source as *const _ as usize }, 136usize, concat!( "Offset of field: " , stringify ! ( group_source_req ) , "::" , stringify ! ( gsr_source ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip_msfilter { pub imsf_multiaddr: in_addr, pub imsf_interface: in_addr, pub imsf_fmode: u32, pub imsf_numsrc: u32, pub imsf_slist: [in_addr; 1usize] }

#[test]
fn bindgen_test_layout_ip_msfilter() {
    assert_eq!(::std::mem::size_of::<ip_msfilter>(), 20usize, concat!( "Size of: " , stringify ! ( ip_msfilter ) ));
    assert_eq!(::std::mem::align_of::<ip_msfilter>(), 4usize, concat!( "Alignment of " , stringify ! ( ip_msfilter ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_multiaddr as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ip_msfilter ) , "::" , stringify ! ( imsf_multiaddr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_interface as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( ip_msfilter ) , "::" , stringify ! ( imsf_interface ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_fmode as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ip_msfilter ) , "::" , stringify ! ( imsf_fmode ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_numsrc as *const _ as usize }, 12usize, concat!( "Offset of field: " , stringify ! ( ip_msfilter ) , "::" , stringify ! ( imsf_numsrc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ip_msfilter>())).imsf_slist as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ip_msfilter ) , "::" , stringify ! ( imsf_slist ) ));
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct group_filter { pub gf_interface: u32, pub gf_group: sockaddr_storage, pub gf_fmode: u32, pub gf_numsrc: u32, pub gf_slist: [sockaddr_storage; 1usize] }

#[test]
fn bindgen_test_layout_group_filter() {
    assert_eq!(::std::mem::size_of::<group_filter>(), 272usize, concat!( "Size of: " , stringify ! ( group_filter ) ));
    assert_eq!(::std::mem::align_of::<group_filter>(), 8usize, concat!( "Alignment of " , stringify ! ( group_filter ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<group_filter>())).gf_interface as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( group_filter ) , "::" , stringify ! ( gf_interface ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<group_filter>())).gf_group as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( group_filter ) , "::" , stringify ! ( gf_group ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<group_filter>())).gf_fmode as *const _ as usize }, 136usize, concat!( "Offset of field: " , stringify ! ( group_filter ) , "::" , stringify ! ( gf_fmode ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<group_filter>())).gf_numsrc as *const _ as usize }, 140usize, concat!( "Offset of field: " , stringify ! ( group_filter ) , "::" , stringify ! ( gf_numsrc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<group_filter>())).gf_slist as *const _ as usize }, 144usize, concat!( "Offset of field: " , stringify ! ( group_filter ) , "::" , stringify ! ( gf_slist ) ));
}

/// < no longer allow read request
pub const apr_shutdown_how_e_APR_SHUTDOWN_READ: apr_shutdown_how_e = 0;
/// < no longer allow write requests
pub const apr_shutdown_how_e_APR_SHUTDOWN_WRITE: apr_shutdown_how_e = 1;
/// < no longer allow read or write requests
pub const apr_shutdown_how_e_APR_SHUTDOWN_READWRITE: apr_shutdown_how_e = 2;

/// Define what type of socket shutdown should occur.
pub type apr_shutdown_how_e = u32;

/// < Socket information for local end of connection
pub const apr_interface_e_APR_LOCAL: apr_interface_e = 0;
/// < Socket information for remote end of connection
pub const apr_interface_e_APR_REMOTE: apr_interface_e = 1;

/// Enum used to denote either the local and remote endpoint of a
/// connection.
pub type apr_interface_e = u32;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_socket_t { _unused: [u8; 0] }

/// A structure to represent in_addr
pub type apr_in_addr_t = in_addr;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_ipsubnet_t { _unused: [u8; 0] }

/// @remark use apr_uint16_t just in case some system has a short that isn't 16 bits...
pub type apr_port_t = apr_uint16_t;

/// APRs socket address type, used to ensure protocol independence
#[repr(C)]
#[derive(Copy, Clone)]
pub struct apr_sockaddr_t {
    /// The pool to use...
    pub pool: *mut apr_pool_t,
    /// The hostname
    pub hostname: *mut ::libc::c_char,
    /// Either a string of the port number or the service name for the port
    pub servname: *mut ::libc::c_char,
    /// The numeric port
    pub port: apr_port_t,
    /// The family
    pub family: apr_int32_t,
    /// How big is the sockaddr we're using?
    pub salen: apr_socklen_t,
    /// How big is the ip address structure we're using?
    pub ipaddr_len: ::libc::c_int,
    /// How big should the address buffer be?  16 for v4 or 46 for v6
    /// used in inet_ntop...
    pub addr_str_len: ::libc::c_int,
    /// This points to the IP address structure within the appropriate
    /// sockaddr structure.
    pub ipaddr_ptr: *mut ::libc::c_void,
    /// If multiple addresses were found by apr_sockaddr_info_get(), this
    /// points to a representation of the next address.
    pub next: *mut apr_sockaddr_t,
    pub sa: apr_sockaddr_sa_t,
}

/// Union of either IPv4 or IPv6 sockaddr.
#[repr(C)]
#[derive(Copy, Clone)]
pub union apr_sockaddr_sa_t {
    /// IPv4 sockaddr structure
    pub sin: sockaddr_in,
    /// IPv6 sockaddr structure
    pub sin6: sockaddr_in6,
    /// Placeholder to ensure that the size of this union is not
    /// dependent on whether APR_HAVE_IPV6 is defined.
    pub sas: sockaddr_storage,
    _bindgen_union_align: [u64; 16usize],
}

#[test]
fn bindgen_test_layout_apr_sockaddr_sa_t() {
    assert_eq!(::std::mem::size_of::<apr_sockaddr_sa_t>(), 128usize, concat!( "Size of: " , stringify ! ( apr_sockaddr_t__bindgen_ty_1 ) ));
    assert_eq!(::std::mem::align_of::<apr_sockaddr_sa_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_sockaddr_t__bindgen_ty_1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_sa_t>())).sin as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t__bindgen_ty_1 ) , "::" , stringify ! ( sin ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_sa_t>())).sin6 as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t__bindgen_ty_1 ) , "::" , stringify ! ( sin6 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_sa_t>())).sas as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t__bindgen_ty_1 ) , "::" , stringify ! ( sas ) ));
}

#[test]
fn bindgen_test_layout_apr_sockaddr_t() {
    assert_eq!(::std::mem::size_of::<apr_sockaddr_t>(), 192usize, concat!( "Size of: " , stringify ! ( apr_sockaddr_t ) ));
    assert_eq!(::std::mem::align_of::<apr_sockaddr_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_sockaddr_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).pool as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).hostname as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( hostname ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).servname as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( servname ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).port as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( port ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).family as *const _ as usize }, 28usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( family ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).salen as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( salen ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).ipaddr_len as *const _ as usize }, 36usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( ipaddr_len ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).addr_str_len as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( addr_str_len ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).ipaddr_ptr as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( ipaddr_ptr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).next as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).sa as *const _ as usize }, 64usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( sa ) ));
}

/// A structure to encapsulate headers and trailers for apr_socket_sendfile
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_hdtr_t {
    /// An iovec to store the headers sent before the file.
    pub headers: *mut iovec,
    /// number of headers in the iovec
    pub numheaders: ::libc::c_int,
    /// An iovec to store the trailers sent after the file.
    pub trailers: *mut iovec,
    /// number of trailers in the iovec
    pub numtrailers: ::libc::c_int,
}

#[test]
fn bindgen_test_layout_apr_hdtr_t() {
    assert_eq!(::std::mem::size_of::<apr_hdtr_t>(), 32usize, concat!( "Size of: " , stringify ! ( apr_hdtr_t ) ));
    assert_eq!(::std::mem::align_of::<apr_hdtr_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_hdtr_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_hdtr_t>())).headers as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_hdtr_t ) , "::" , stringify ! ( headers ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_hdtr_t>())).numheaders as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_hdtr_t ) , "::" , stringify ! ( numheaders ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_hdtr_t>())).trailers as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_hdtr_t ) , "::" , stringify ! ( trailers ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_hdtr_t>())).numtrailers as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_hdtr_t ) , "::" , stringify ! ( numtrailers ) ));
}

/// @remark
/// As far as I can tell the only really sane way to store an MMAP is as a
/// void * and a length.  BeOS requires this area_id, but that's just a little
/// something extra.  I am exposing this type, because it doesn't make much
/// sense to keep it private, and opening it up makes some stuff easier in
/// Apache.
/// /
/// /** The MMAP structure
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_mmap_t {
    /// The pool the mmap structure was allocated out of.
    pub cntxt: *mut apr_pool_t,
    /// The start of the memory mapped area
    pub mm: *mut ::libc::c_void,
    /// The amount of data in the mmap
    pub size: apr_size_t,
    /// ring of apr_mmap_t's that reference the same
    /// mmap'ed region; acts in place of a reference count
    pub link: apr_mmap_t__bindgen_ty_1,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_mmap_t__bindgen_ty_1 { pub next: *mut apr_mmap_t, pub prev: *mut apr_mmap_t }

#[test]
fn bindgen_test_layout_apr_mmap_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<apr_mmap_t__bindgen_ty_1>(), 16usize, concat!( "Size of: " , stringify ! ( apr_mmap_t__bindgen_ty_1 ) ));
    assert_eq!(::std::mem::align_of::<apr_mmap_t__bindgen_ty_1>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_mmap_t__bindgen_ty_1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_mmap_t__bindgen_ty_1>())).next as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_mmap_t__bindgen_ty_1 ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_mmap_t__bindgen_ty_1>())).prev as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_mmap_t__bindgen_ty_1 ) , "::" , stringify ! ( prev ) ));
}

#[test]
fn bindgen_test_layout_apr_mmap_t() {
    assert_eq!(::std::mem::size_of::<apr_mmap_t>(), 40usize, concat!( "Size of: " , stringify ! ( apr_mmap_t ) ));
    assert_eq!(::std::mem::align_of::<apr_mmap_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_mmap_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_mmap_t>())).cntxt as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_mmap_t ) , "::" , stringify ! ( cntxt ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_mmap_t>())).mm as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_mmap_t ) , "::" , stringify ! ( mm ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_mmap_t>())).size as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_mmap_t ) , "::" , stringify ! ( size ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_mmap_t>())).link as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_mmap_t ) , "::" , stringify ! ( link ) ));
}

/// < block until data becomes available
pub const apr_read_type_e_APR_BLOCK_READ: apr_read_type_e = 0;
/// < return immediately if no data is available
pub const apr_read_type_e_APR_NONBLOCK_READ: apr_read_type_e = 1;

/// Determines how a bucket or brigade should be read
pub type apr_read_type_e = u32;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_alloc_t { _unused: [u8; 0] }

/// Basic bucket type
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_type_t {
    /// The name of the bucket type
    pub name: *const ::libc::c_char,
    /// The number of functions this bucket understands.  Can not be less than
    /// five.
    pub num_func: ::libc::c_int,
    pub is_metadata: apr_bucket_type_t__bindgen_ty_1,
    /// Free the private data and any resources used by the bucket (if they
    /// aren't shared with another bucket).  This function is required to be
    /// implemented for all bucket types, though it might be a no-op on some
    /// of them (namely ones that never allocate any private data structures).
    /// @param data The private data pointer from the bucket to be destroyed
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::libc::c_void)>,
    /// Read the data from the bucket. This is required to be implemented
    /// for all bucket types.
    /// @param b The bucket to read from
    /// @param str A place to store the data read.  Allocation should only be
    /// done if absolutely necessary.
    /// @param len The amount of data read.
    /// @param block Should this read function block if there is more data that
    /// cannot be read immediately.
    pub read: ::std::option::Option<unsafe extern "C" fn(b: *mut apr_bucket, str: *mut *const ::libc::c_char, len: *mut apr_size_t, block: apr_read_type_e) -> apr_status_t>,
    /// Make it possible to set aside the data for at least as long as the
    /// given pool. Buckets containing data that could potentially die before
    /// this pool (e.g. the data resides on the stack, in a child pool of
    /// the given pool, or in a disjoint pool) must somehow copy, shift, or
    /// transform the data to have the proper lifetime.
    /// @param e The bucket to convert
    /// @remark Some bucket types contain data that will always outlive the
    /// bucket itself. For example no data (EOS and FLUSH), or the data
    /// resides in global, constant memory (IMMORTAL), or the data is on
    /// the heap (HEAP). For these buckets, apr_bucket_setaside_noop can
    /// be used.
    pub setaside: ::std::option::Option<unsafe extern "C" fn(e: *mut apr_bucket, pool: *mut apr_pool_t) -> apr_status_t>,
    /// Split one bucket in two at the specified position by duplicating
    /// the bucket structure (not the data) and modifying any necessary
    /// start/end/offset information.  If it's not possible to do this
    /// for the bucket type (perhaps the length of the data is indeterminate,
    /// as with pipe and socket buckets), then APR_ENOTIMPL is returned.
    /// @param e The bucket to split
    /// @param point The offset of the first byte in the new bucket
    pub split: ::std::option::Option<unsafe extern "C" fn(e: *mut apr_bucket, point: apr_size_t) -> apr_status_t>,
    /// Copy the bucket structure (not the data), assuming that this is
    /// possible for the bucket type. If it's not, APR_ENOTIMPL is returned.
    /// @param e The bucket to copy
    /// @param c Returns a pointer to the new bucket
    pub copy: ::std::option::Option<unsafe extern "C" fn(e: *mut apr_bucket, c: *mut *mut apr_bucket) -> apr_status_t>,
}

/// This bucket type represents actual data to send to the client.
pub const apr_bucket_type_t_APR_BUCKET_DATA: apr_bucket_type_t__bindgen_ty_1 = 0;
/// This bucket type represents metadata.
pub const apr_bucket_type_t_APR_BUCKET_METADATA: apr_bucket_type_t__bindgen_ty_1 = 1;

/// Whether the bucket contains metadata (ie, information that
/// describes the regular contents of the brigade).  The metadata
/// is not returned by apr_bucket_read() and is not indicated by
/// the ->length of the apr_bucket itself.  In other words, an
/// empty bucket is safe to arbitrarily remove if and only if it
/// contains no metadata.  In this sense, "data" is just raw bytes
/// that are the "content" of the brigade and "metadata" describes
/// that data but is not a proper part of it.
pub type apr_bucket_type_t__bindgen_ty_1 = u32;

#[test]
fn bindgen_test_layout_apr_bucket_type_t() {
    assert_eq!(::std::mem::size_of::<apr_bucket_type_t>(), 56usize, concat!( "Size of: " , stringify ! ( apr_bucket_type_t ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_type_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket_type_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_type_t>())).name as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_type_t ) , "::" , stringify ! ( name ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_type_t>())).num_func as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_type_t ) , "::" , stringify ! ( num_func ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_type_t>())).is_metadata as *const _ as usize }, 12usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_type_t ) , "::" , stringify ! ( is_metadata ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_type_t>())).destroy as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_type_t ) , "::" , stringify ! ( destroy ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_type_t>())).read as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_type_t ) , "::" , stringify ! ( read ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_type_t>())).setaside as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_type_t ) , "::" , stringify ! ( setaside ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_type_t>())).split as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_type_t ) , "::" , stringify ! ( split ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_type_t>())).copy as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_type_t ) , "::" , stringify ! ( copy ) ));
}

/// apr_bucket structures are allocated on the malloc() heap and
/// their lifetime is controlled by the parent apr_bucket_brigade
/// structure. Buckets can move from one brigade to another e.g. by
/// calling APR_BRIGADE_CONCAT(). In general the data in a bucket has
/// the same lifetime as the bucket and is freed when the bucket is
/// destroyed; if the data is shared by more than one bucket (e.g.
/// after a split) the data is freed when the last bucket goes away.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket {
    /// Links to the rest of the brigade
    pub link: apr_bucket__bindgen_ty_1,
    /// The type of bucket.
    pub type_: *const apr_bucket_type_t,
    /// The length of the data in the bucket.  This could have been implemented
    /// with a function, but this is an optimization, because the most
    /// common thing to do will be to get the length.  If the length is unknown,
    /// the value of this field will be (apr_size_t)(-1).
    pub length: apr_size_t,
    /// The start of the data in the bucket relative to the private base
    /// pointer.  The vast majority of bucket types allow a fixed block of
    /// data to be referenced by multiple buckets, each bucket pointing to
    /// a different segment of the data.  That segment starts at base+start
    /// and ends at base+start+length.
    /// If the length == (apr_size_t)(-1), then start == -1.
    pub start: apr_off_t,
    /// type-dependent data hangs off this pointer
    pub data: *mut ::libc::c_void,
    /// Pointer to function used to free the bucket. This function should
    /// always be defined and it should be consistent with the memory
    /// function used to allocate the bucket. For example, if malloc() is
    /// used to allocate the bucket, this pointer should point to free().
    /// @param e Pointer to the bucket being freed
    pub free: ::std::option::Option<unsafe extern "C" fn(e: *mut ::libc::c_void)>,
    /// The freelist from which this bucket was allocated
    pub list: *mut apr_bucket_alloc_t,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket__bindgen_ty_1 { pub next: *mut apr_bucket, pub prev: *mut apr_bucket }

#[test]
fn bindgen_test_layout_apr_bucket__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<apr_bucket__bindgen_ty_1>(), 16usize, concat!( "Size of: " , stringify ! ( apr_bucket__bindgen_ty_1 ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket__bindgen_ty_1>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket__bindgen_ty_1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket__bindgen_ty_1>())).next as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket__bindgen_ty_1 ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket__bindgen_ty_1>())).prev as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_bucket__bindgen_ty_1 ) , "::" , stringify ! ( prev ) ));
}

#[test]
fn bindgen_test_layout_apr_bucket() {
    assert_eq!(::std::mem::size_of::<apr_bucket>(), 64usize, concat!( "Size of: " , stringify ! ( apr_bucket ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket>())).link as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket ) , "::" , stringify ! ( link ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket>())).type_ as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_bucket ) , "::" , stringify ! ( type_ ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket>())).length as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_bucket ) , "::" , stringify ! ( length ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket>())).start as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( apr_bucket ) , "::" , stringify ! ( start ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket>())).data as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( apr_bucket ) , "::" , stringify ! ( data ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket>())).free as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( apr_bucket ) , "::" , stringify ! ( free ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket>())).list as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( apr_bucket ) , "::" , stringify ! ( list ) ));
}

/// A list of buckets
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_brigade {
    /// The pool to associate the brigade with.  The data is not allocated out
    /// of the pool, but a cleanup is registered with this pool.  If the
    /// brigade is destroyed by some mechanism other than pool destruction,
    /// the destroying function is responsible for killing the cleanup.
    pub p: *mut apr_pool_t,
    pub list: apr_bucket_brigade_apr_bucket_list,
    /// The freelist from which this bucket was allocated
    pub bucket_alloc: *mut apr_bucket_alloc_t,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_brigade_apr_bucket_list { pub next: *mut apr_bucket, pub prev: *mut apr_bucket }

#[test]
fn bindgen_test_layout_apr_bucket_brigade_apr_bucket_list() {
    assert_eq!(::std::mem::size_of::<apr_bucket_brigade_apr_bucket_list>(), 16usize, concat!( "Size of: " , stringify ! ( apr_bucket_brigade_apr_bucket_list ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_brigade_apr_bucket_list>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket_brigade_apr_bucket_list ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_brigade_apr_bucket_list>())).next as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_brigade_apr_bucket_list ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_brigade_apr_bucket_list>())).prev as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_brigade_apr_bucket_list ) , "::" , stringify ! ( prev ) ));
}

#[test]
fn bindgen_test_layout_apr_bucket_brigade() {
    assert_eq!(::std::mem::size_of::<apr_bucket_brigade>(), 32usize, concat!( "Size of: " , stringify ! ( apr_bucket_brigade ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_brigade>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket_brigade ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_brigade>())).p as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_brigade ) , "::" , stringify ! ( p ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_brigade>())).list as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_brigade ) , "::" , stringify ! ( list ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_brigade>())).bucket_alloc as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_brigade ) , "::" , stringify ! ( bucket_alloc ) ));
}

/// Function called when a brigade should be flushed
pub type apr_brigade_flush = ::std::option::Option<unsafe extern "C" fn(bb: *mut apr_bucket_brigade, ctx: *mut ::libc::c_void) -> apr_status_t>;

/// The structure used to manage the shared resource must start with an
/// apr_bucket_refcount which is updated by the general-purpose refcount
/// code. A pointer to the bucket-type-dependent private data structure
/// can be cast to a pointer to an apr_bucket_refcount and vice versa.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_refcount {
    /// The number of references to this bucket
    pub refcount: ::libc::c_int,
}

#[test]
fn bindgen_test_layout_apr_bucket_refcount() {
    assert_eq!(::std::mem::size_of::<apr_bucket_refcount>(), 4usize, concat!( "Size of: " , stringify ! ( apr_bucket_refcount ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_refcount>(), 4usize, concat!( "Alignment of " , stringify ! ( apr_bucket_refcount ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_refcount>())).refcount as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_refcount ) , "::" , stringify ! ( refcount ) ));
}

/// A bucket referring to data allocated off the heap.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_heap {
    /// Number of buckets using this memory
    pub refcount: apr_bucket_refcount,
    /// The start of the data actually allocated.  This should never be
    /// modified, it is only used to free the bucket.
    pub base: *mut ::libc::c_char,
    /// how much memory was allocated
    pub alloc_len: apr_size_t,
    /// function to use to delete the data
    pub free_func: ::std::option::Option<unsafe extern "C" fn(data: *mut ::libc::c_void)>,
}

#[test]
fn bindgen_test_layout_apr_bucket_heap() {
    assert_eq!(::std::mem::size_of::<apr_bucket_heap>(), 32usize, concat!( "Size of: " , stringify ! ( apr_bucket_heap ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_heap>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket_heap ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_heap>())).refcount as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_heap ) , "::" , stringify ! ( refcount ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_heap>())).base as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_heap ) , "::" , stringify ! ( base ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_heap>())).alloc_len as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_heap ) , "::" , stringify ! ( alloc_len ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_heap>())).free_func as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_heap ) , "::" , stringify ! ( free_func ) ));
}

/// A bucket referring to data allocated from a pool
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_pool {
    /// The pool bucket must be able to be easily morphed to a heap
    /// bucket if the pool gets cleaned up before all references are
    /// destroyed.  This apr_bucket_heap structure is populated automatically
    /// when the pool gets cleaned up, and subsequent calls to pool_read()
    /// will result in the apr_bucket in question being morphed into a
    /// regular heap bucket.  (To avoid having to do many extra refcount
    /// manipulations and b->data manipulations, the apr_bucket_pool
    /// struct actually *contains* the apr_bucket_heap struct that it
    /// will become as its first element; the two share their
    /// apr_bucket_refcount members.)
    pub heap: apr_bucket_heap,
    /// The block of data actually allocated from the pool.
    /// Segments of this block are referenced by adjusting
    /// the start and length of the apr_bucket accordingly.
    /// This will be NULL after the pool gets cleaned up.
    pub base: *const ::libc::c_char,
    /// The pool the data was allocated from.  When the pool
    /// is cleaned up, this gets set to NULL as an indicator
    /// to pool_read() that the data is now on the heap and
    /// so it should morph the bucket into a regular heap
    /// bucket before continuing.
    pub pool: *mut apr_pool_t,
    /// The freelist this structure was allocated from, which is
    /// needed in the cleanup phase in order to allocate space on the heap
    pub list: *mut apr_bucket_alloc_t,
}

#[test]
fn bindgen_test_layout_apr_bucket_pool() {
    assert_eq!(::std::mem::size_of::<apr_bucket_pool>(), 56usize, concat!( "Size of: " , stringify ! ( apr_bucket_pool ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_pool>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket_pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_pool>())).heap as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_pool ) , "::" , stringify ! ( heap ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_pool>())).base as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_pool ) , "::" , stringify ! ( base ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_pool>())).pool as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_pool ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_pool>())).list as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_pool ) , "::" , stringify ! ( list ) ));
}

/// A bucket referring to an mmap()ed file
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_mmap {
    /// Number of buckets using this memory
    pub refcount: apr_bucket_refcount,
    /// The mmap this sub_bucket refers to
    pub mmap: *mut apr_mmap_t,
}

#[test]
fn bindgen_test_layout_apr_bucket_mmap() {
    assert_eq!(::std::mem::size_of::<apr_bucket_mmap>(), 16usize, concat!( "Size of: " , stringify ! ( apr_bucket_mmap ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_mmap>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket_mmap ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_mmap>())).refcount as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_mmap ) , "::" , stringify ! ( refcount ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_mmap>())).mmap as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_mmap ) , "::" , stringify ! ( mmap ) ));
}

/// A bucket referring to an file
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_file {
    /// Number of buckets using this memory
    pub refcount: apr_bucket_refcount,
    /// The file this bucket refers to
    pub fd: *mut apr_file_t,
    /// The pool into which any needed structures should
    /// be created while reading from this file bucket
    pub readpool: *mut apr_pool_t,
    /// Whether this bucket should be memory-mapped if
    /// a caller tries to read from it
    pub can_mmap: ::libc::c_int,
}

#[test]
fn bindgen_test_layout_apr_bucket_file() {
    assert_eq!(::std::mem::size_of::<apr_bucket_file>(), 32usize, concat!( "Size of: " , stringify ! ( apr_bucket_file ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_file>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket_file ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_file>())).refcount as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_file ) , "::" , stringify ! ( refcount ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_file>())).fd as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_file ) , "::" , stringify ! ( fd ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_file>())).readpool as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_file ) , "::" , stringify ! ( readpool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_file>())).can_mmap as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_file ) , "::" , stringify ! ( can_mmap ) ));
}

/// A union of all bucket structures so we know what
/// the max size is.
#[repr(C)]
#[derive(Copy, Clone)]
pub union apr_bucket_structs {
    /// < Bucket
    pub b: apr_bucket,
    /// < Heap
    pub heap: apr_bucket_heap,
    /// < Pool
    pub pool: apr_bucket_pool,
    /// < MMap
    pub mmap: apr_bucket_mmap,
    /// < File
    pub file: apr_bucket_file,
    _bindgen_union_align: [u64; 8usize],
}

#[test]
fn bindgen_test_layout_apr_bucket_structs() {
    assert_eq!(::std::mem::size_of::<apr_bucket_structs>(), 64usize, concat!( "Size of: " , stringify ! ( apr_bucket_structs ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_structs>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket_structs ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_structs>())).b as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_structs ) , "::" , stringify ! ( b ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_structs>())).heap as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_structs ) , "::" , stringify ! ( heap ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_structs>())).pool as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_structs ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_structs>())).mmap as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_structs ) , "::" , stringify ! ( mmap ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_structs>())).file as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_structs ) , "::" , stringify ! ( file ) ));
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_flush"]
    pub static mut apr_bucket_type_flush: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_eos"]
    pub static mut apr_bucket_type_eos: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_file"]
    pub static mut apr_bucket_type_file: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_heap"]
    pub static mut apr_bucket_type_heap: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_mmap"]
    pub static mut apr_bucket_type_mmap: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_pool"]
    pub static mut apr_bucket_type_pool: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_pipe"]
    pub static mut apr_bucket_type_pipe: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_immortal"]
    pub static mut apr_bucket_type_immortal: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_transient"]
    pub static mut apr_bucket_type_transient: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_socket"]
    pub static mut apr_bucket_type_socket: apr_bucket_type_t;
}

/// < Platform default poll method
pub const apr_pollset_method_e_APR_POLLSET_DEFAULT: apr_pollset_method_e = 0;
/// < Poll uses select method
pub const apr_pollset_method_e_APR_POLLSET_SELECT: apr_pollset_method_e = 1;
/// < Poll uses kqueue method
pub const apr_pollset_method_e_APR_POLLSET_KQUEUE: apr_pollset_method_e = 2;
/// < Poll uses Solaris event port method
pub const apr_pollset_method_e_APR_POLLSET_PORT: apr_pollset_method_e = 3;
/// < Poll uses epoll method
pub const apr_pollset_method_e_APR_POLLSET_EPOLL: apr_pollset_method_e = 4;
/// < Poll uses poll method
pub const apr_pollset_method_e_APR_POLLSET_POLL: apr_pollset_method_e = 5;
/// < Poll uses z/OS asio method
pub const apr_pollset_method_e_APR_POLLSET_AIO_MSGQ: apr_pollset_method_e = 6;

/// Pollset Methods
pub type apr_pollset_method_e = u32;

/// < nothing here
pub const apr_datatype_e_APR_NO_DESC: apr_datatype_e = 0;
/// < descriptor refers to a socket
pub const apr_datatype_e_APR_POLL_SOCKET: apr_datatype_e = 1;
/// < descriptor refers to a file
pub const apr_datatype_e_APR_POLL_FILE: apr_datatype_e = 2;
/// < @deprecated descriptor is the last one in the list
pub const apr_datatype_e_APR_POLL_LASTDESC: apr_datatype_e = 3;

/// Used in apr_pollfd_t to determine what the apr_descriptor is
pub type apr_datatype_e = u32;

/// Union of either an APR file or socket.
#[repr(C)]
#[derive(Copy, Clone)]
pub union apr_descriptor {
    /// < file
    pub f: *mut apr_file_t,
    /// < socket
    pub s: *mut apr_socket_t,
    _bindgen_union_align: u64,
}

#[test]
fn bindgen_test_layout_apr_descriptor() {
    assert_eq!(::std::mem::size_of::<apr_descriptor>(), 8usize, concat!( "Size of: " , stringify ! ( apr_descriptor ) ));
    assert_eq!(::std::mem::align_of::<apr_descriptor>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_descriptor ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_descriptor>())).f as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_descriptor ) , "::" , stringify ! ( f ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_descriptor>())).s as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_descriptor ) , "::" , stringify ! ( s ) ));
}

/// Poll descriptor set.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct apr_pollfd_t {
    /// < associated pool
    pub p: *mut apr_pool_t,
    /// < descriptor type
    pub desc_type: apr_datatype_e,
    /// < requested events
    pub reqevents: apr_int16_t,
    /// < returned events
    pub rtnevents: apr_int16_t,
    /// < @see apr_descriptor
    pub desc: apr_descriptor,
    /// < allows app to associate context
    pub client_data: *mut ::libc::c_void,
}

#[test]
fn bindgen_test_layout_apr_pollfd_t() {
    assert_eq!(::std::mem::size_of::<apr_pollfd_t>(), 32usize, concat!( "Size of: " , stringify ! ( apr_pollfd_t ) ));
    assert_eq!(::std::mem::align_of::<apr_pollfd_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_pollfd_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_pollfd_t>())).p as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_pollfd_t ) , "::" , stringify ! ( p ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_pollfd_t>())).desc_type as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_pollfd_t ) , "::" , stringify ! ( desc_type ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_pollfd_t>())).reqevents as *const _ as usize }, 12usize, concat!( "Offset of field: " , stringify ! ( apr_pollfd_t ) , "::" , stringify ! ( reqevents ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_pollfd_t>())).rtnevents as *const _ as usize }, 14usize, concat!( "Offset of field: " , stringify ! ( apr_pollfd_t ) , "::" , stringify ! ( rtnevents ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_pollfd_t>())).desc as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_pollfd_t ) , "::" , stringify ! ( desc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_pollfd_t>())).client_data as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_pollfd_t ) , "::" , stringify ! ( client_data ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_pollset_t { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_pollcb_t { _unused: [u8; 0] }

/// Function prototype for pollcb handlers
/// @param baton Opaque baton passed into apr_pollcb_poll()
/// @param descriptor Contains the notification for an active descriptor,
/// the rtnevents member contains what events were triggered
/// for this descriptor.
pub type apr_pollcb_cb_t = ::std::option::Option<unsafe extern "C" fn(baton: *mut ::libc::c_void, descriptor: *mut apr_pollfd_t) -> apr_status_t>;

pub const AP_REG_ASSERT: _bindgen_ty_16 = 1;
/// internal error ?
pub const AP_REG_ESPACE: _bindgen_ty_16 = 2;
/// failed to get memory
pub const AP_REG_INVARG: _bindgen_ty_16 = 3;
/// invalid argument
pub const AP_REG_NOMATCH: _bindgen_ty_16 = 4;

/// unused
pub type _bindgen_ty_16 = u32;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_regex_t { pub re_pcre: *mut ::libc::c_void, pub re_nsub: apr_size_t, pub re_erroffset: apr_size_t }

#[test]
fn bindgen_test_layout_ap_regex_t() {
    assert_eq!(::std::mem::size_of::<ap_regex_t>(), 24usize, concat!( "Size of: " , stringify ! ( ap_regex_t ) ));
    assert_eq!(::std::mem::align_of::<ap_regex_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_regex_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_regex_t>())).re_pcre as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_regex_t ) , "::" , stringify ! ( re_pcre ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_regex_t>())).re_nsub as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_regex_t ) , "::" , stringify ! ( re_nsub ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_regex_t>())).re_erroffset as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_regex_t ) , "::" , stringify ! ( re_erroffset ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_regmatch_t { pub rm_so: ::libc::c_int, pub rm_eo: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_regmatch_t() {
    assert_eq!(::std::mem::size_of::<ap_regmatch_t>(), 8usize, concat!( "Size of: " , stringify ! ( ap_regmatch_t ) ));
    assert_eq!(::std::mem::align_of::<ap_regmatch_t>(), 4usize, concat!( "Alignment of " , stringify ! ( ap_regmatch_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_regmatch_t>())).rm_so as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_regmatch_t ) , "::" , stringify ! ( rm_so ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_regmatch_t>())).rm_eo as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( ap_regmatch_t ) , "::" , stringify ! ( rm_eo ) ));
}

pub type wchar_t = ::libc::c_int;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t { pub quot: ::libc::c_int, pub rem: ::libc::c_int }

#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(::std::mem::size_of::<div_t>(), 8usize, concat!( "Size of: " , stringify ! ( div_t ) ));
    assert_eq!(::std::mem::align_of::<div_t>(), 4usize, concat!( "Alignment of " , stringify ! ( div_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( div_t ) , "::" , stringify ! ( quot ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( div_t ) , "::" , stringify ! ( rem ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t { pub quot: ::libc::c_long, pub rem: ::libc::c_long }

#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(::std::mem::size_of::<ldiv_t>(), 16usize, concat!( "Size of: " , stringify ! ( ldiv_t ) ));
    assert_eq!(::std::mem::align_of::<ldiv_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ldiv_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ldiv_t ) , "::" , stringify ! ( quot ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ldiv_t ) , "::" , stringify ! ( rem ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t { pub quot: ::libc::c_longlong, pub rem: ::libc::c_longlong }

#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(::std::mem::size_of::<lldiv_t>(), 16usize, concat!( "Size of: " , stringify ! ( lldiv_t ) ));
    assert_eq!(::std::mem::align_of::<lldiv_t>(), 8usize, concat!( "Alignment of " , stringify ! ( lldiv_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( lldiv_t ) , "::" , stringify ! ( quot ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( lldiv_t ) , "::" , stringify ! ( rem ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data { pub fptr: *mut i32, pub rptr: *mut i32, pub state: *mut i32, pub rand_type: ::libc::c_int, pub rand_deg: ::libc::c_int, pub rand_sep: ::libc::c_int, pub end_ptr: *mut i32 }

#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(::std::mem::size_of::<random_data>(), 48usize, concat!( "Size of: " , stringify ! ( random_data ) ));
    assert_eq!(::std::mem::align_of::<random_data>(), 8usize, concat!( "Alignment of " , stringify ! ( random_data ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( random_data ) , "::" , stringify ! ( fptr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( random_data ) , "::" , stringify ! ( rptr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( random_data ) , "::" , stringify ! ( state ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( random_data ) , "::" , stringify ! ( rand_type ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize }, 28usize, concat!( "Offset of field: " , stringify ! ( random_data ) , "::" , stringify ! ( rand_deg ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( random_data ) , "::" , stringify ! ( rand_sep ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( random_data ) , "::" , stringify ! ( end_ptr ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data { pub __x: [::libc::c_ushort; 3usize], pub __old_x: [::libc::c_ushort; 3usize], pub __c: ::libc::c_ushort, pub __init: ::libc::c_ushort, pub __a: ::libc::c_ulonglong }

#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(::std::mem::size_of::<drand48_data>(), 24usize, concat!( "Size of: " , stringify ! ( drand48_data ) ));
    assert_eq!(::std::mem::align_of::<drand48_data>(), 8usize, concat!( "Alignment of " , stringify ! ( drand48_data ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( drand48_data ) , "::" , stringify ! ( __x ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize }, 6usize, concat!( "Offset of field: " , stringify ! ( drand48_data ) , "::" , stringify ! ( __old_x ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize }, 12usize, concat!( "Offset of field: " , stringify ! ( drand48_data ) , "::" , stringify ! ( __c ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize }, 14usize, concat!( "Offset of field: " , stringify ! ( drand48_data ) , "::" , stringify ! ( __init ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( drand48_data ) , "::" , stringify ! ( __a ) ));
}

pub type __compar_fn_t = ::std::option::Option<unsafe extern "C" fn(arg1: *const ::libc::c_void, arg2: *const ::libc::c_void) -> ::libc::c_int>;

/// @brief The numeric version information is broken out into fields within this
/// structure.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_version_t {
    /// < major number
    pub major: ::libc::c_int,
    /// < minor number
    pub minor: ::libc::c_int,
    /// < patch number
    pub patch: ::libc::c_int,
    /// < additional string like "-dev"
    pub add_string: *const ::libc::c_char,
}

#[test]
fn bindgen_test_layout_ap_version_t() {
    assert_eq!(::std::mem::size_of::<ap_version_t>(), 24usize, concat!( "Size of: " , stringify ! ( ap_version_t ) ));
    assert_eq!(::std::mem::align_of::<ap_version_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_version_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_version_t>())).major as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_version_t ) , "::" , stringify ! ( major ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_version_t>())).minor as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( ap_version_t ) , "::" , stringify ! ( minor ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_version_t>())).patch as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_version_t ) , "::" , stringify ! ( patch ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_version_t>())).add_string as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_version_t ) , "::" , stringify ! ( add_string ) ));
}

/// @struct ap_method_list_t
/// @brief  Structure for handling HTTP methods.
///
/// Methods known to the server are accessed via a bitmask shortcut;
/// extension methods are handled by an array.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_method_list_t {
    /// The bitmask used for known methods
    pub method_mask: apr_int64_t,
    /// the array used for extension methods
    pub method_list: *mut apr_array_header_t,
}

#[test]
fn bindgen_test_layout_ap_method_list_t() {
    assert_eq!(::std::mem::size_of::<ap_method_list_t>(), 16usize, concat!( "Size of: " , stringify ! ( ap_method_list_t ) ));
    assert_eq!(::std::mem::align_of::<ap_method_list_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_method_list_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_method_list_t>())).method_mask as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_method_list_t ) , "::" , stringify ! ( method_mask ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_method_list_t>())).method_list as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_method_list_t ) , "::" , stringify ! ( method_list ) ));
}

/// @brief This represents the result of calling htaccess; these are cached for
/// each request.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct htaccess_result {
    /// the directory to which this applies
    pub dir: *const ::libc::c_char,
    /// the overrides allowed for the .htaccess file
    pub override_: ::libc::c_int,
    /// the override options allowed for the .htaccess file
    pub override_opts: ::libc::c_int,
    /// the configuration directives
    pub htaccess: *mut ap_conf_vector_t,
    /// the next one, or NULL if no more; N.B. never change this
    pub next: *const htaccess_result,
}

#[test]
fn bindgen_test_layout_htaccess_result() {
    assert_eq!(::std::mem::size_of::<htaccess_result>(), 32usize, concat!( "Size of: " , stringify ! ( htaccess_result ) ));
    assert_eq!(::std::mem::align_of::<htaccess_result>(), 8usize, concat!( "Alignment of " , stringify ! ( htaccess_result ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<htaccess_result>())).dir as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( htaccess_result ) , "::" , stringify ! ( dir ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<htaccess_result>())).override_ as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( htaccess_result ) , "::" , stringify ! ( override_ ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<htaccess_result>())).override_opts as *const _ as usize }, 12usize, concat!( "Offset of field: " , stringify ! ( htaccess_result ) , "::" , stringify ! ( override_opts ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<htaccess_result>())).htaccess as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( htaccess_result ) , "::" , stringify ! ( htaccess ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<htaccess_result>())).next as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( htaccess_result ) , "::" , stringify ! ( next ) ));
}

/// A structure to encompass all of the fields in a uri
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_uri_t {
    /// scheme ("http"/"ftp"/...)
    pub scheme: *mut ::libc::c_char,
    /// combined [user[:password]\@]host[:port]
    pub hostinfo: *mut ::libc::c_char,
    /// user name, as in http://user:passwd\@host:port/
    pub user: *mut ::libc::c_char,
    /// password, as in http://user:passwd\@host:port/
    pub password: *mut ::libc::c_char,
    /// hostname from URI (or from Host: header)
    pub hostname: *mut ::libc::c_char,
    /// port string (integer representation is in "port")
    pub port_str: *mut ::libc::c_char,
    /// the request path (or NULL if only scheme://host was given)
    pub path: *mut ::libc::c_char,
    /// Everything after a '?' in the path, if present
    pub query: *mut ::libc::c_char,
    /// Trailing "#fragment" string, if present
    pub fragment: *mut ::libc::c_char,
    /// structure returned from gethostbyname()
    pub hostent: *mut hostent,
    /// The port number, numeric, valid only if port_str != NULL
    pub port: apr_port_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 5usize],
}

#[test]
fn bindgen_test_layout_apr_uri_t() {
    assert_eq!(::std::mem::size_of::<apr_uri_t>(), 88usize, concat!( "Size of: " , stringify ! ( apr_uri_t ) ));
    assert_eq!(::std::mem::align_of::<apr_uri_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_uri_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).scheme as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( scheme ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).hostinfo as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( hostinfo ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).user as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( user ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).password as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( password ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).hostname as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( hostname ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).port_str as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( port_str ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).path as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( path ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).query as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( query ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).fragment as *const _ as usize }, 64usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( fragment ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).hostent as *const _ as usize }, 72usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( hostent ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).port as *const _ as usize }, 80usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( port ) ));
}

impl apr_uri_t {
    #[inline]
    pub fn is_initialized(&self) -> ::libc::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) } }
    #[inline]
    pub fn set_is_initialized(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dns_looked_up(&self) -> ::libc::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) } }
    #[inline]
    pub fn set_dns_looked_up(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dns_resolved(&self) -> ::libc::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) } }
    #[inline]
    pub fn set_dns_resolved(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(is_initialized: ::libc::c_uint, dns_looked_up: ::libc::c_uint, dns_resolved: ::libc::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_initialized: u32 = unsafe { ::std::mem::transmute(is_initialized) };
            is_initialized as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dns_looked_up: u32 = unsafe { ::std::mem::transmute(dns_looked_up) };
            dns_looked_up as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dns_resolved: u32 = unsafe { ::std::mem::transmute(dns_resolved) };
            dns_resolved as u64
        });
        __bindgen_bitfield_unit
    }
}

/// @brief A structure that represents one process
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct process_rec {
    /// Global pool. Cleared upon normal exit
    pub pool: *mut apr_pool_t,
    /// Configuration pool. Cleared upon restart
    pub pconf: *mut apr_pool_t,
    /// Number of command line arguments passed to the program
    pub argc: ::libc::c_int,
    /// The command line arguments
    pub argv: *const *const ::libc::c_char,
    /// The program name used to execute the program
    pub short_name: *const ::libc::c_char,
}

#[test]
fn bindgen_test_layout_process_rec() {
    assert_eq!(::std::mem::size_of::<process_rec>(), 40usize, concat!( "Size of: " , stringify ! ( process_rec ) ));
    assert_eq!(::std::mem::align_of::<process_rec>(), 8usize, concat!( "Alignment of " , stringify ! ( process_rec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<process_rec>())).pool as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( process_rec ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<process_rec>())).pconf as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( process_rec ) , "::" , stringify ! ( pconf ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<process_rec>())).argc as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( process_rec ) , "::" , stringify ! ( argc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<process_rec>())).argv as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( process_rec ) , "::" , stringify ! ( argv ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<process_rec>())).short_name as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( process_rec ) , "::" , stringify ! ( short_name ) ));
}

/// @brief A structure that represents the current request
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct request_rec {
    /// The pool associated with the request
    pub pool: *mut ffi::apr_pool_t,
    /// The connection to the client
    pub connection: *mut ffi::conn_rec,
    /// The virtual host for this request
    pub server: *mut ffi::server_rec,
    /// Pointer to the redirected request if this is an external redirect
    pub next: *mut request_rec,
    /// Pointer to the previous request if this is an internal redirect
    pub prev: *mut request_rec,
    /// Pointer to the main request if this is a sub-request
    /// (see http_request.h)
    pub main: *mut request_rec,
    /// First line of request
    pub the_request: *mut ::libc::c_char,
    /// HTTP/0.9, "simple" request (e.g. GET /foo\n w/no headers)
    pub assbackwards: ::libc::c_int,
    /// A proxy request (calculated during post_read_request/translate_name)
    /// possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,
    /// PROXYREQ_RESPONSE
    pub proxyreq: ::libc::c_int,
    /// HEAD request, as opposed to GET
    pub header_only: ::libc::c_int,
    /// Protocol string, as given to us, or HTTP/0.9
    pub protocol: *mut ::libc::c_char,
    /// Protocol version number of protocol; 1.1 = 1001
    pub proto_num: ::libc::c_int,
    /// Host, as set by full URI or Host:
    pub hostname: *const ::libc::c_char,
    /// Time when the request started
    pub request_time: apr_time_t,
    /// Status line, if set by script
    pub status_line: *const ::libc::c_char,
    /// Status line
    pub status: ::libc::c_int,
    /// Request method (eg. GET, HEAD, POST, etc.)
    pub method: *const ::libc::c_char,
    /// M_GET, M_POST, etc.
    pub method_number: ::libc::c_int,
    /// 'allowed' is a bitvector of the allowed methods.
    ///
    /// A handler must ensure that the request method is one that
    /// it is capable of handling.  Generally modules should DECLINE
    /// any request methods they do not handle.  Prior to aborting the
    /// handler like this the handler should set r->allowed to the list
    /// of methods that it is willing to handle.  This bitvector is used
    /// to construct the "Allow:" header required for OPTIONS requests,
    /// and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.
    ///
    /// Since the default_handler deals with OPTIONS, all modules can
    /// usually decline to deal with OPTIONS.  TRACE is always allowed,
    /// modules don't need to set it explicitly.
    ///
    /// Since the default_handler will always handle a GET, a
    /// module which does *not* implement GET should probably return
    /// HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET
    /// handler can't be installed by mod_actions.
    pub allowed: apr_int64_t,
    /// Array of extension methods
    pub allowed_xmethods: *mut apr_array_header_t,
    /// List of allowed methods
    pub allowed_methods: *mut ap_method_list_t,
    /// byte count in stream is for body
    pub sent_bodyct: apr_off_t,
    /// body byte count, for easy access
    pub bytes_sent: apr_off_t,
    /// Last modified time of the requested resource
    pub mtime: apr_time_t,
    /// sending chunked transfer-coding
    pub chunked: ::libc::c_int,
    /// The Range: header
    pub range: *const ::libc::c_char,
    /// The "real" content length
    pub clength: apr_off_t,
    /// Remaining bytes left to read from the request body
    pub remaining: apr_off_t,
    /// Number of bytes that have been read  from the request body
    pub read_length: apr_off_t,
    /// Method for reading the request body
    /// (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,
    /// REQUEST_CHUNKED_DECHUNK, etc...)
    pub read_body: ::libc::c_int,
    /// reading chunked transfer-coding
    pub read_chunked: ::libc::c_int,
    /// is client waiting for a 100 response?
    pub expecting_100: ::libc::c_uint,
    /// MIME header environment from the request
    pub headers_in: *mut ffi::apr_table_t,
    /// MIME header environment for the response
    pub headers_out: *mut ffi::apr_table_t,
    /// MIME header environment for the response, printed even on errors and
    /// persist across internal redirects
    pub err_headers_out: *mut ffi::apr_table_t,
    /// Array of environment variables to be used for sub processes
    pub subprocess_env: *mut ffi::apr_table_t,
    /// Notes from one module to another
    pub notes: *mut ffi::apr_table_t,
    /// The content-type for the current request
    pub content_type: *const ::libc::c_char,
    /// The handler string that we use to call a handler function
    pub handler: *const ::libc::c_char,
    /// How to encode the data
    pub content_encoding: *const ::libc::c_char,
    /// Array of strings representing the content languages
    pub content_languages: *mut apr_array_header_t,
    /// variant list validator (if negotiated)
    pub vlist_validator: *mut ::libc::c_char,
    /// If an authentication check was made, this gets set to the user name.
    pub user: *mut ::libc::c_char,
    /// If an authentication check was made, this gets set to the auth type.
    pub ap_auth_type: *mut ::libc::c_char,
    /// This response can not be cached
    pub no_cache: ::libc::c_int,
    /// There is no local copy of this response
    pub no_local_copy: ::libc::c_int,
    /// The URI without any parsing performed
    pub unparsed_uri: *mut ::libc::c_char,
    /// The path portion of the URI, or "/" if no path provided
    pub uri: *mut ::libc::c_char,
    /// The filename on disk corresponding to this response
    pub filename: *mut ::libc::c_char,
    /// The true filename, we canonicalize r->filename if these don't match
    pub canonical_filename: *mut ::libc::c_char,
    /// The PATH_INFO extracted from this request
    pub path_info: *mut ::libc::c_char,
    /// The QUERY_ARGS extracted from this request
    pub args: *mut ::libc::c_char,
    /// finfo.protection (st_mode) set to zero if no such file
    pub finfo: apr_finfo_t,
    /// A struct containing the components of URI
    pub parsed_uri: apr_uri_t,
    /// Flag for the handler to accept or reject path_info on
    /// the current request.  All modules should respect the
    /// AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO
    /// values, while AP_REQ_DEFAULT_PATH_INFO indicates they
    /// may follow existing conventions.  This is set to the
    /// user's preference upon HOOK_VERY_FIRST of the fixups.
    pub used_path_info: ::libc::c_int,
    /// Options set in config files, etc.
    pub per_dir_config: *mut ffi::ap_conf_vector_t,
    /// Notes on *this* request
    pub request_config: *mut ap_conf_vector_t,
    /// A linked list of the .htaccess configuration directives
    /// accessed by this request.
    /// N.B. always add to the head of the list, _never_ to the end.
    /// that way, a sub request's list can (temporarily) point to a parent's list
    pub htaccess: *const htaccess_result,
    /// A list of output filters to be used for this request
    pub output_filters: *mut ap_filter_t,
    /// A list of input filters to be used for this request
    pub input_filters: *mut ap_filter_t,
    /// A list of protocol level output filters to be used for this
    /// request
    pub proto_output_filters: *mut ap_filter_t,
    /// A list of protocol level input filters to be used for this
    /// request
    pub proto_input_filters: *mut ap_filter_t,
    /// A flag to determine if the eos bucket has been sent yet
    pub eos_sent: ::libc::c_int,
    /// MIME trailer environment from the request
    pub trailers_in: *mut apr_table_t,
    /// MIME trailer environment from the response
    pub trailers_out: *mut apr_table_t,
}

#[test]
fn bindgen_test_layout_request_rec() {
    assert_eq!(::std::mem::size_of::<request_rec>(), 688usize, concat!( "Size of: " , stringify ! ( request_rec ) ));
    assert_eq!(::std::mem::align_of::<request_rec>(), 8usize, concat!( "Alignment of " , stringify ! ( request_rec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).pool as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).connection as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( connection ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).server as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( server ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).next as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).prev as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( prev ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).main as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( main ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).the_request as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( the_request ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).assbackwards as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( assbackwards ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).proxyreq as *const _ as usize }, 60usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( proxyreq ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).header_only as *const _ as usize }, 64usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( header_only ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).protocol as *const _ as usize }, 72usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( protocol ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).proto_num as *const _ as usize }, 80usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( proto_num ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).hostname as *const _ as usize }, 88usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( hostname ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).request_time as *const _ as usize }, 96usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( request_time ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).status_line as *const _ as usize }, 104usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( status_line ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).status as *const _ as usize }, 112usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( status ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).method as *const _ as usize }, 120usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( method ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).method_number as *const _ as usize }, 128usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( method_number ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).allowed as *const _ as usize }, 136usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( allowed ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).allowed_xmethods as *const _ as usize }, 144usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( allowed_xmethods ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).allowed_methods as *const _ as usize }, 152usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( allowed_methods ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).sent_bodyct as *const _ as usize }, 160usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( sent_bodyct ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).bytes_sent as *const _ as usize }, 168usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( bytes_sent ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).mtime as *const _ as usize }, 176usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( mtime ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).chunked as *const _ as usize }, 184usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( chunked ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).range as *const _ as usize }, 192usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( range ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).clength as *const _ as usize }, 200usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( clength ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).remaining as *const _ as usize }, 208usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( remaining ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).read_length as *const _ as usize }, 216usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( read_length ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).read_body as *const _ as usize }, 224usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( read_body ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).read_chunked as *const _ as usize }, 228usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( read_chunked ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).expecting_100 as *const _ as usize }, 232usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( expecting_100 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).headers_in as *const _ as usize }, 240usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( headers_in ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).headers_out as *const _ as usize }, 248usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( headers_out ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).err_headers_out as *const _ as usize }, 256usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( err_headers_out ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).subprocess_env as *const _ as usize }, 264usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( subprocess_env ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).notes as *const _ as usize }, 272usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( notes ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).content_type as *const _ as usize }, 280usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( content_type ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).handler as *const _ as usize }, 288usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( handler ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).content_encoding as *const _ as usize }, 296usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( content_encoding ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).content_languages as *const _ as usize }, 304usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( content_languages ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).vlist_validator as *const _ as usize }, 312usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( vlist_validator ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).user as *const _ as usize }, 320usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( user ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).ap_auth_type as *const _ as usize }, 328usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( ap_auth_type ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).no_cache as *const _ as usize }, 336usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( no_cache ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).no_local_copy as *const _ as usize }, 340usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( no_local_copy ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).unparsed_uri as *const _ as usize }, 344usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( unparsed_uri ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).uri as *const _ as usize }, 352usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( uri ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).filename as *const _ as usize }, 360usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( filename ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).canonical_filename as *const _ as usize }, 368usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( canonical_filename ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).path_info as *const _ as usize }, 376usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( path_info ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).args as *const _ as usize }, 384usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( args ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).finfo as *const _ as usize }, 392usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( finfo ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).parsed_uri as *const _ as usize }, 512usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( parsed_uri ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).used_path_info as *const _ as usize }, 600usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( used_path_info ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).per_dir_config as *const _ as usize }, 608usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( per_dir_config ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).request_config as *const _ as usize }, 616usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( request_config ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).htaccess as *const _ as usize }, 624usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( htaccess ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).output_filters as *const _ as usize }, 632usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( output_filters ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).input_filters as *const _ as usize }, 640usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( input_filters ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).proto_output_filters as *const _ as usize }, 648usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( proto_output_filters ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).proto_input_filters as *const _ as usize }, 656usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( proto_input_filters ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).eos_sent as *const _ as usize }, 664usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( eos_sent ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).trailers_in as *const _ as usize }, 672usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( trailers_in ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).trailers_out as *const _ as usize }, 680usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( trailers_out ) ));
}

pub const ap_conn_keepalive_e_AP_CONN_UNKNOWN: ap_conn_keepalive_e = 0;
pub const ap_conn_keepalive_e_AP_CONN_CLOSE: ap_conn_keepalive_e = 1;
pub const ap_conn_keepalive_e_AP_CONN_KEEPALIVE: ap_conn_keepalive_e = 2;

/// @brief Enumeration of connection keepalive options
pub type ap_conn_keepalive_e = u32;

/// @brief Structure to store things which are per connection
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conn_rec {
    /// Pool associated with this connection
    pub pool: *mut apr_pool_t,
    /// Physical vhost this conn came in on
    pub base_server: *mut server_rec,
    /// used by http_vhost.c
    pub vhost_lookup_data: *mut ::libc::c_void,
    /// local address
    pub local_addr: *mut apr_sockaddr_t,
    /// remote address
    pub remote_addr: *mut apr_sockaddr_t,
    /// Client's IP address
    pub remote_ip: *mut ::libc::c_char,
    /// Client's DNS name, if known.  NULL if DNS hasn't been checked,
    /// "" if it has and no address was found.  N.B. Only access this though
    /// get_remote_host()
    pub remote_host: *mut ::libc::c_char,
    /// Only ever set if doing rfc1413 lookups.  N.B. Only access this through
    /// get_remote_logname()
    pub remote_logname: *mut ::libc::c_char,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    /// Are we going to keep the connection alive for another request?
    /// @see ap_conn_keepalive_e
    pub keepalive: ap_conn_keepalive_e,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    /// How many times have we used it?
    pub keepalives: ::libc::c_int,
    /// server IP address
    pub local_ip: *mut ::libc::c_char,
    /// used for ap_get_server_name when UseCanonicalName is set to DNS
    /// (ignores setting of HostnameLookups)
    pub local_host: *mut ::libc::c_char,
    /// ID of this connection; unique at any point in time
    pub id: ::libc::c_long,
    /// Config vector containing pointers to connections per-server
    /// config structures.
    pub conn_config: *mut ap_conf_vector_t,
    /// Notes on *this* connection: send note from one module to
    /// another. must remain valid for all requests on this conn
    pub notes: *mut apr_table_t,
    /// A list of input filters to be used for this connection
    pub input_filters: *mut ap_filter_t,
    /// A list of output filters to be used for this connection
    pub output_filters: *mut ap_filter_t,
    /// handle to scoreboard information for this connection
    pub sbh: *mut ::libc::c_void,
    /// The bucket allocator to use for all bucket/brigade creations
    pub bucket_alloc: *mut apr_bucket_alloc_t,
    /// The current state of this connection
    pub cs: *mut conn_state_t,
    /// Is there data pending in the input filters?
    pub data_in_input_filters: ::libc::c_int,
    /// Are there any filters that clogg/buffer the input stream, breaking
    /// the event mpm.
    pub clogging_input_filters: ::libc::c_int,
}

#[test]
fn bindgen_test_layout_conn_rec() {
    assert_eq!(::std::mem::size_of::<conn_rec>(), 168usize, concat!( "Size of: " , stringify ! ( conn_rec ) ));
    assert_eq!(::std::mem::align_of::<conn_rec>(), 8usize, concat!( "Alignment of " , stringify ! ( conn_rec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).pool as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).base_server as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( base_server ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).vhost_lookup_data as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( vhost_lookup_data ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).local_addr as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( local_addr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).remote_addr as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( remote_addr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).remote_ip as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( remote_ip ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).remote_host as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( remote_host ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).remote_logname as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( remote_logname ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).keepalive as *const _ as usize }, 68usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( keepalive ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).keepalives as *const _ as usize }, 76usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( keepalives ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).local_ip as *const _ as usize }, 80usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( local_ip ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).local_host as *const _ as usize }, 88usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( local_host ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).id as *const _ as usize }, 96usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( id ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).conn_config as *const _ as usize }, 104usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( conn_config ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).notes as *const _ as usize }, 112usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( notes ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).input_filters as *const _ as usize }, 120usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( input_filters ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).output_filters as *const _ as usize }, 128usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( output_filters ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).sbh as *const _ as usize }, 136usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( sbh ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).bucket_alloc as *const _ as usize }, 144usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( bucket_alloc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).cs as *const _ as usize }, 152usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( cs ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).data_in_input_filters as *const _ as usize }, 160usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( data_in_input_filters ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).clogging_input_filters as *const _ as usize }, 164usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( clogging_input_filters ) ));
}

impl conn_rec {
    #[inline]
    pub fn aborted(&self) -> ::libc::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) } }
    #[inline]
    pub fn set_aborted(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(aborted: ::libc::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let aborted: u32 = unsafe { ::std::mem::transmute(aborted) };
            aborted as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn double_reverse(&self) -> ::libc::c_int { unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 2u8) as u32) } }
    #[inline]
    pub fn set_double_reverse(&mut self, val: ::libc::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(double_reverse: ::libc::c_int) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let double_reverse: u32 = unsafe { ::std::mem::transmute(double_reverse) };
            double_reverse as u64
        });
        __bindgen_bitfield_unit
    }
}

pub const conn_state_e_CONN_STATE_CHECK_REQUEST_LINE_READABLE: conn_state_e = 0;
pub const conn_state_e_CONN_STATE_READ_REQUEST_LINE: conn_state_e = 1;
pub const conn_state_e_CONN_STATE_LINGER: conn_state_e = 2;

/// Enumeration of connection states
pub type conn_state_e = u32;

/// @brief A structure to contain connection state information
#[repr(C)]
#[derive(Copy, Clone)]
pub struct conn_state_t {
    /// APR_RING of expiration timeouts
    pub timeout_list: conn_state_t__bindgen_ty_1,
    /// the expiration time of the next keepalive timeout
    pub expiration_time: apr_time_t,
    /// Current state of the connection
    pub state: conn_state_e,
    /// connection record this struct refers to
    pub c: *mut conn_rec,
    /// memory pool to allocate from
    pub p: *mut apr_pool_t,
    /// bucket allocator
    pub bucket_alloc: *mut apr_bucket_alloc_t,
    /// poll file decriptor information
    pub pfd: apr_pollfd_t,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conn_state_t__bindgen_ty_1 { pub next: *mut conn_state_t, pub prev: *mut conn_state_t }

#[test]
fn bindgen_test_layout_conn_state_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<conn_state_t__bindgen_ty_1>(), 16usize, concat!( "Size of: " , stringify ! ( conn_state_t__bindgen_ty_1 ) ));
    assert_eq!(::std::mem::align_of::<conn_state_t__bindgen_ty_1>(), 8usize, concat!( "Alignment of " , stringify ! ( conn_state_t__bindgen_ty_1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_state_t__bindgen_ty_1>())).next as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( conn_state_t__bindgen_ty_1 ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_state_t__bindgen_ty_1>())).prev as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( conn_state_t__bindgen_ty_1 ) , "::" , stringify ! ( prev ) ));
}

#[test]
fn bindgen_test_layout_conn_state_t() {
    assert_eq!(::std::mem::size_of::<conn_state_t>(), 88usize, concat!( "Size of: " , stringify ! ( conn_state_t ) ));
    assert_eq!(::std::mem::align_of::<conn_state_t>(), 8usize, concat!( "Alignment of " , stringify ! ( conn_state_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_state_t>())).timeout_list as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( conn_state_t ) , "::" , stringify ! ( timeout_list ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_state_t>())).expiration_time as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( conn_state_t ) , "::" , stringify ! ( expiration_time ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_state_t>())).state as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( conn_state_t ) , "::" , stringify ! ( state ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_state_t>())).c as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( conn_state_t ) , "::" , stringify ! ( c ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_state_t>())).p as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( conn_state_t ) , "::" , stringify ! ( p ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_state_t>())).bucket_alloc as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( conn_state_t ) , "::" , stringify ! ( bucket_alloc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_state_t>())).pfd as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( conn_state_t ) , "::" , stringify ! ( pfd ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct server_addr_rec {
    /// The next server in the list
    pub next: *mut server_addr_rec,
    /// The bound address, for this server
    pub host_addr: *mut apr_sockaddr_t,
    /// The bound port, for this server
    pub host_port: apr_port_t,
    /// The name given in "<VirtualHost>"
    pub virthost: *mut ::libc::c_char,
}

#[test]
fn bindgen_test_layout_server_addr_rec() {
    assert_eq!(::std::mem::size_of::<server_addr_rec>(), 32usize, concat!( "Size of: " , stringify ! ( server_addr_rec ) ));
    assert_eq!(::std::mem::align_of::<server_addr_rec>(), 8usize, concat!( "Alignment of " , stringify ! ( server_addr_rec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_addr_rec>())).next as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( server_addr_rec ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_addr_rec>())).host_addr as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( server_addr_rec ) , "::" , stringify ! ( host_addr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_addr_rec>())).host_port as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( server_addr_rec ) , "::" , stringify ! ( host_port ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_addr_rec>())).virthost as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( server_addr_rec ) , "::" , stringify ! ( virthost ) ));
}

/// @brief A structure to store information for each virtual server
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct server_rec {
    /// The process this server is running in
    pub process: *mut process_rec,
    /// The next server in the list
    pub next: *mut server_rec,
    /// The name of the server
    pub defn_name: *const ::libc::c_char,
    /// The line of the config file that the server was defined on
    pub defn_line_number: ::libc::c_uint,
    /// The admin's contact information
    pub server_admin: *mut ::libc::c_char,
    /// The server hostname
    pub server_hostname: *mut ::libc::c_char,
    /// for redirects, etc.
    pub port: apr_port_t,
    /// The name of the error log
    pub error_fname: *mut ::libc::c_char,
    /// A file descriptor that references the error log
    pub error_log: *mut apr_file_t,
    /// The log level for this server
    pub loglevel: ::libc::c_int,
    /// true if this is the virtual server
    pub is_virtual: ::libc::c_int,
    /// Config vector containing pointers to modules' per-server config
    /// structures.
    pub module_config: *mut ap_conf_vector_t,
    /// MIME type info, etc., before we start checking per-directory info
    pub lookup_defaults: *mut ap_conf_vector_t,
    /// I haven't got a clue
    pub addrs: *mut server_addr_rec,
    /// Timeout, as an apr interval, before we give up
    pub timeout: apr_interval_time_t,
    /// The apr interval we will wait for another request
    pub keep_alive_timeout: apr_interval_time_t,
    /// Maximum requests per connection
    pub keep_alive_max: ::libc::c_int,
    /// Use persistent connections?
    pub keep_alive: ::libc::c_int,
    /// Pathname for ServerPath
    pub path: *const ::libc::c_char,
    /// Length of path
    pub pathlen: ::libc::c_int,
    /// Normal names for ServerAlias servers
    pub names: *mut apr_array_header_t,
    /// Wildcarded names for ServerAlias servers
    pub wild_names: *mut apr_array_header_t,
    /// limit on size of the HTTP request line
    pub limit_req_line: ::libc::c_int,
    /// limit on size of any request header field
    pub limit_req_fieldsize: ::libc::c_int,
    /// limit on number of request header fields
    pub limit_req_fields: ::libc::c_int,
    /// The server request scheme for redirect responses
    pub server_scheme: *const ::libc::c_char,
}

#[test]
fn bindgen_test_layout_server_rec() {
    assert_eq!(::std::mem::size_of::<server_rec>(), 184usize, concat!( "Size of: " , stringify ! ( server_rec ) ));
    assert_eq!(::std::mem::align_of::<server_rec>(), 8usize, concat!( "Alignment of " , stringify ! ( server_rec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).process as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( process ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).next as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).defn_name as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( defn_name ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).defn_line_number as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( defn_line_number ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).server_admin as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( server_admin ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).server_hostname as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( server_hostname ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).port as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( port ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).error_fname as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( error_fname ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).error_log as *const _ as usize }, 64usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( error_log ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).loglevel as *const _ as usize }, 72usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( loglevel ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).is_virtual as *const _ as usize }, 76usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( is_virtual ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).module_config as *const _ as usize }, 80usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( module_config ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).lookup_defaults as *const _ as usize }, 88usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( lookup_defaults ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).addrs as *const _ as usize }, 96usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( addrs ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).timeout as *const _ as usize }, 104usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( timeout ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).keep_alive_timeout as *const _ as usize }, 112usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( keep_alive_timeout ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).keep_alive_max as *const _ as usize }, 120usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( keep_alive_max ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).keep_alive as *const _ as usize }, 124usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( keep_alive ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).path as *const _ as usize }, 128usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( path ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).pathlen as *const _ as usize }, 136usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( pathlen ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).names as *const _ as usize }, 144usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( names ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).wild_names as *const _ as usize }, 152usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( wild_names ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).limit_req_line as *const _ as usize }, 160usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( limit_req_line ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).limit_req_fieldsize as *const _ as usize }, 164usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( limit_req_fieldsize ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).limit_req_fields as *const _ as usize }, 168usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( limit_req_fields ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).server_scheme as *const _ as usize }, 176usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( server_scheme ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct core_output_filter_ctx {
    pub b: *mut apr_bucket_brigade,
    /// subpool of c->pool used for resources
    /// which may outlive the request
    pub deferred_write_pool: *mut apr_pool_t,
}

#[test]
fn bindgen_test_layout_core_output_filter_ctx() {
    assert_eq!(::std::mem::size_of::<core_output_filter_ctx>(), 16usize, concat!( "Size of: " , stringify ! ( core_output_filter_ctx ) ));
    assert_eq!(::std::mem::align_of::<core_output_filter_ctx>(), 8usize, concat!( "Alignment of " , stringify ! ( core_output_filter_ctx ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<core_output_filter_ctx>())).b as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( core_output_filter_ctx ) , "::" , stringify ! ( b ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<core_output_filter_ctx>())).deferred_write_pool as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( core_output_filter_ctx ) , "::" , stringify ! ( deferred_write_pool ) ));
}

pub type core_output_filter_ctx_t = core_output_filter_ctx;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct core_filter_ctx { pub b: *mut apr_bucket_brigade, pub tmpbb: *mut apr_bucket_brigade }

#[test]
fn bindgen_test_layout_core_filter_ctx() {
    assert_eq!(::std::mem::size_of::<core_filter_ctx>(), 16usize, concat!( "Size of: " , stringify ! ( core_filter_ctx ) ));
    assert_eq!(::std::mem::align_of::<core_filter_ctx>(), 8usize, concat!( "Alignment of " , stringify ! ( core_filter_ctx ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<core_filter_ctx>())).b as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( core_filter_ctx ) , "::" , stringify ! ( b ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<core_filter_ctx>())).tmpbb as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( core_filter_ctx ) , "::" , stringify ! ( tmpbb ) ));
}

pub type core_ctx_t = core_filter_ctx;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct core_net_rec {
    /// Connection to the client
    pub client_socket: *mut apr_socket_t,
    /// connection record
    pub c: *mut conn_rec,
    pub out_ctx: *mut core_output_filter_ctx_t,
    pub in_ctx: *mut core_ctx_t,
}

#[test]
fn bindgen_test_layout_core_net_rec() {
    assert_eq!(::std::mem::size_of::<core_net_rec>(), 32usize, concat!( "Size of: " , stringify ! ( core_net_rec ) ));
    assert_eq!(::std::mem::align_of::<core_net_rec>(), 8usize, concat!( "Alignment of " , stringify ! ( core_net_rec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<core_net_rec>())).client_socket as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( core_net_rec ) , "::" , stringify ! ( client_socket ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<core_net_rec>())).c as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( core_net_rec ) , "::" , stringify ! ( c ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<core_net_rec>())).out_ctx as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( core_net_rec ) , "::" , stringify ! ( out_ctx ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<core_net_rec>())).in_ctx as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( core_net_rec ) , "::" , stringify ! ( in_ctx ) ));
}

extern "C" {
    /// Examine a field value (such as a media-/content-type) string and return
/// it sans any parameters; e.g., strip off any ';charset=foo' and the like.
/// @param p Pool to allocate memory from
/// @param intype The field to examine
/// @return A copy of the field minus any parameters
    pub fn ap_field_noparam(p: *mut apr_pool_t, intype: *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Convert a time from an integer into a string in a specified format
/// @param p The pool to allocate memory from
/// @param t The time to convert
/// @param fmt The format to use for the conversion
/// @param gmt Convert the time for GMT?
/// @return The string that represents the specified time
    pub fn ap_ht_time(p: *mut apr_pool_t, t: apr_time_t, fmt: *const ::libc::c_char, gmt: ::libc::c_int) -> *mut ::libc::c_char;
}

extern "C" {
    /// Get the characters until the first occurance of a specified character
/// @param p The pool to allocate memory from
/// @param line The string to get the characters from
/// @param stop The character to stop at
/// @return A copy of the characters up to the first stop character
    pub fn ap_getword(p: *mut apr_pool_t, line: *mut *const ::libc::c_char, stop: ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Get the characters until the first occurance of a specified character
/// @param p The pool to allocate memory from
/// @param line The string to get the characters from
/// @param stop The character to stop at
/// @return A copy of the characters up to the first stop character
/// @note This is the same as ap_getword(), except it doesn't use const char **.
    pub fn ap_getword_nc(p: *mut apr_pool_t, line: *mut *mut ::libc::c_char, stop: ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Get the first word from a given string.  A word is defined as all characters
/// up to the first whitespace.
/// @param p The pool to allocate memory from
/// @param line The string to traverse
/// @return The first word in the line
    pub fn ap_getword_white(p: *mut apr_pool_t, line: *mut *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Get the first word from a given string.  A word is defined as all characters
/// up to the first whitespace.
/// @param p The pool to allocate memory from
/// @param line The string to traverse
/// @return The first word in the line
/// @note The same as ap_getword_white(), except it doesn't use const char**
    pub fn ap_getword_white_nc(p: *mut apr_pool_t, line: *mut *mut ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Get all characters from the first occurance of @a stop to the first "\0"
/// @param p The pool to allocate memory from
/// @param line The line to traverse
/// @param stop The character to start at
/// @return A copy of all caracters after the first occurance of the specified
/// character
    pub fn ap_getword_nulls(p: *mut apr_pool_t, line: *mut *const ::libc::c_char, stop: ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Get all characters from the first occurance of @a stop to the first "\0"
/// @param p The pool to allocate memory from
/// @param line The line to traverse
/// @param stop The character to start at
/// @return A copy of all caracters after the first occurance of the specified
/// character
/// @note The same as ap_getword_nulls(), except it doesn't use const char **.
    pub fn ap_getword_nulls_nc(p: *mut apr_pool_t, line: *mut *mut ::libc::c_char, stop: ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Get the second word in the string paying attention to quoting
/// @param p The pool to allocate from
/// @param line The line to traverse
/// @return A copy of the string
    pub fn ap_getword_conf(p: *mut apr_pool_t, line: *mut *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Get the second word in the string paying attention to quoting
/// @param p The pool to allocate from
/// @param line The line to traverse
/// @return A copy of the string
/// @note The same as ap_getword_conf(), except it doesn't use const char **.
    pub fn ap_getword_conf_nc(p: *mut apr_pool_t, line: *mut *mut ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Check a string for any ${ENV} environment variable construct and replace
/// each them by the value of that environment variable, if it exists. If the
/// environment value does not exist, leave the ${ENV} construct alone; it
/// means something else.
/// @param p The pool to allocate from
/// @param word The string to check
/// @return The string with the replaced environment variables
    pub fn ap_resolve_env(p: *mut apr_pool_t, word: *const ::libc::c_char) -> *const ::libc::c_char;
}

extern "C" {
    /// Size an HTTP header field list item, as separated by a comma.
/// @param field The field to size
/// @param len The length of the field
/// @return The return value is a pointer to the beginning of the non-empty
/// list item within the original string (or NULL if there is none) and the
/// address of field is shifted to the next non-comma, non-whitespace
/// character.  len is the length of the item excluding any beginning whitespace.
    pub fn ap_size_list_item(field: *mut *const ::libc::c_char, len: *mut ::libc::c_int) -> *const ::libc::c_char;
}

extern "C" {
    /// Retrieve an HTTP header field list item, as separated by a comma,
/// while stripping insignificant whitespace and lowercasing anything not in
/// a quoted string or comment.
/// @param p The pool to allocate from
/// @param field The field to retrieve
/// @return The return value is a new string containing the converted list
/// item (or NULL if none) and the address pointed to by field is
/// shifted to the next non-comma, non-whitespace.
    pub fn ap_get_list_item(p: *mut apr_pool_t, field: *mut *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Find an item in canonical form (lowercase, no extra spaces) within
/// an HTTP field value list.
/// @param p The pool to allocate from
/// @param line The field value list to search
/// @param tok The token to search for
/// @return 1 if found, 0 if not found.
    pub fn ap_find_list_item(p: *mut apr_pool_t, line: *const ::libc::c_char, tok: *const ::libc::c_char) -> ::libc::c_int;
}

extern "C" { pub fn ap_scan_http_field_content(ptr: *const ::libc::c_char) -> *const ::libc::c_char; }

extern "C" { pub fn ap_scan_http_token(ptr: *const ::libc::c_char) -> *const ::libc::c_char; }

extern "C" { pub fn ap_scan_vchar_obstext(ptr: *const ::libc::c_char) -> *const ::libc::c_char; }

extern "C" {
    /// Retrieve a token, spacing over it and adjusting the pointer to
/// the first non-white byte afterwards.  Note that these tokens
/// are delimited by semis and commas and can also be delimited
/// by whitespace at the caller's option.
/// @param p The pool to allocate from
/// @param accept_line The line to retrieve the token from (adjusted afterwards)
/// @param accept_white Is it delimited by whitespace
/// @return the token
    pub fn ap_get_token(p: *mut apr_pool_t, accept_line: *mut *const ::libc::c_char, accept_white: ::libc::c_int) -> *mut ::libc::c_char;
}

extern "C" {
    /// Find http tokens, see the definition of token from RFC2068
/// @param p The pool to allocate from
/// @param line The line to find the token
/// @param tok The token to find
/// @return 1 if the token is found, 0 otherwise
    pub fn ap_find_token(p: *mut apr_pool_t, line: *const ::libc::c_char, tok: *const ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// find http tokens from the end of the line
/// @param p The pool to allocate from
/// @param line The line to find the token
/// @param tok The token to find
/// @return 1 if the token is found, 0 otherwise
    pub fn ap_find_last_token(p: *mut apr_pool_t, line: *const ::libc::c_char, tok: *const ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Check for an Absolute URI syntax
/// @param u The string to check
/// @return 1 if URI, 0 otherwise
    pub fn ap_is_url(u: *const ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Unescape a URL
/// @param url The url to unescape
/// @return 0 on success, non-zero otherwise
    pub fn ap_unescape_url(url: *mut ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Unescape a URL, including encoded slashes.
/// @param url The url to unescape
/// @return 0 on success, non-zero otherwise
    pub fn ap_unescape_url_keep2f(url: *mut ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Unescape a URL, including encoded slashes.
/// @param url The url to unescape
/// @param decode_slashes Whether or not slashes should be decoded or not
/// @return 0 on success, non-zero otherwise
    pub fn ap_unescape_url_keep2f_ex(url: *mut ::libc::c_char, decode_slashes: ::libc::c_int) -> ::libc::c_int;
}

extern "C" {
    /// Convert all double slashes to single slashes
/// @param name The string to convert
    pub fn ap_no2slash(name: *mut ::libc::c_char);
}

extern "C" {
    /// Remove all ./ and xx/../ substrings from a file name. Also remove
/// any leading ../ or /../ substrings.
/// @param name the file name to parse
    pub fn ap_getparents(name: *mut ::libc::c_char);
}

extern "C" {
    /// Escape a path segment, as defined in RFC 1808
/// @param p The pool to allocate from
/// @param s The path to convert
/// @return The converted URL
    pub fn ap_escape_path_segment(p: *mut apr_pool_t, s: *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// convert an OS path to a URL in an OS dependant way.
/// @param p The pool to allocate from
/// @param path The path to convert
/// @param partial if set, assume that the path will be appended to something
/// with a '/' in it (and thus does not prefix "./")
/// @return The converted URL
    pub fn ap_os_escape_path(p: *mut apr_pool_t, path: *const ::libc::c_char, partial: ::libc::c_int) -> *mut ::libc::c_char;
}

extern "C" {
    /// Escape an html string
/// @param p The pool to allocate from
/// @param s The html to escape
/// @return The escaped string
    pub fn ap_escape_html(p: *mut apr_pool_t, s: *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Escape an html string
/// @param p The pool to allocate from
/// @param s The html to escape
/// @param toasc Whether to escape all non-ASCII chars to &#nnn;
/// @return The escaped string
    pub fn ap_escape_html2(p: *mut apr_pool_t, s: *const ::libc::c_char, toasc: ::libc::c_int) -> *mut ::libc::c_char;
}

extern "C" {
    /// Escape a string for logging
/// @param p The pool to allocate from
/// @param str The string to escape
/// @return The escaped string
    pub fn ap_escape_logitem(p: *mut apr_pool_t, str: *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Escape a string for logging into the error log (without a pool)
/// @param dest The buffer to write to
/// @param source The string to escape
/// @param buflen The buffer size for the escaped string (including "\0")
/// @return The len of the escaped string (always < maxlen)
    pub fn ap_escape_errorlog_item(dest: *mut ::libc::c_char, source: *const ::libc::c_char, buflen: apr_size_t) -> apr_size_t;
}

extern "C" {
    /// Construct a full hostname
/// @param p The pool to allocate from
/// @param hostname The hostname of the server
/// @param port The port the server is running on
/// @param r The current request
/// @return The server's hostname
    pub fn ap_construct_server(p: *mut apr_pool_t, hostname: *const ::libc::c_char, port: apr_port_t, r: *const request_rec) -> *mut ::libc::c_char;
}

extern "C" {
    /// Escape a shell command
/// @param p The pool to allocate from
/// @param s The command to escape
/// @return The escaped shell command
    pub fn ap_escape_shell_cmd(p: *mut apr_pool_t, s: *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Count the number of directories in a path
/// @param path The path to count
/// @return The number of directories
    pub fn ap_count_dirs(path: *const ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Copy at most @a n leading directories of @a s into @a d. @a d
/// should be at least as large as @a s plus 1 extra byte
///
/// @param d The location to copy to
/// @param s The location to copy from
/// @param n The number of directories to copy
/// @return value is the ever useful pointer to the trailing "\0" of d
/// @note on platforms with drive letters, n = 0 returns the "/" root,
/// whereas n = 1 returns the "d:/" root.  On all other platforms, n = 0
/// returns the empty string.
    pub fn ap_make_dirstr_prefix(d: *mut ::libc::c_char, s: *const ::libc::c_char, n: ::libc::c_int) -> *mut ::libc::c_char;
}

extern "C" {
    /// Return the parent directory name (including trailing /) of the file
/// @a s
/// @param p The pool to allocate from
/// @param s The file to get the parent of
/// @return A copy of the file's parent directory
    pub fn ap_make_dirstr_parent(p: *mut apr_pool_t, s: *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Given a directory and filename, create a single path from them.  This
/// function is smart enough to ensure that there is a single '/' between the
/// directory and file names
/// @param a The pool to allocate from
/// @param dir The directory name
/// @param f The filename
/// @return A copy of the full path
/// @note Never consider using this function if you are dealing with filesystem
/// names that need to remain canonical, unless you are merging an apr_dir_read
/// path and returned filename.  Otherwise, the result is not canonical.
    pub fn ap_make_full_path(a: *mut apr_pool_t, dir: *const ::libc::c_char, f: *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Test if the given path has an an absolute path.
/// @param p The pool to allocate from
/// @param dir The directory name
/// @note The converse is not necessarily true, some OS's (Win32/OS2/Netware) have
/// multiple forms of absolute paths.  This only reports if the path is absolute
/// in a canonical sense.
    pub fn ap_os_is_path_absolute(p: *mut apr_pool_t, dir: *const ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Does the provided string contain wildcard characters?  This is useful
/// for determining if the string should be passed to strcmp_match or to strcmp.
/// The only wildcard characters recognized are '?' and '*'
/// @param str The string to check
/// @return 1 if the string has wildcards, 0 otherwise
    pub fn ap_is_matchexp(str: *const ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Determine if a string matches a pattern containing the wildcards '?' or '*'
/// @param str The string to check
/// @param expected The pattern to match against
/// @return 1 if the two strings match, 0 otherwise
    pub fn ap_strcmp_match(str: *const ::libc::c_char, expected: *const ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Determine if a string matches a pattern containing the wildcards '?' or '*',
/// ignoring case
/// @param str The string to check
/// @param expected The pattern to match against
/// @return 1 if the two strings match, 0 otherwise
    pub fn ap_strcasecmp_match(str: *const ::libc::c_char, expected: *const ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Find the first occurrence of the substring s2 in s1, regardless of case
/// @param s1 The string to search
/// @param s2 The substring to search for
/// @return A pointer to the beginning of the substring
/// @remark See apr_strmatch() for a faster alternative
    pub fn ap_strcasestr(s1: *const ::libc::c_char, s2: *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Return a pointer to the location inside of bigstring immediately after prefix
/// @param bigstring The input string
/// @param prefix The prefix to strip away
/// @return A pointer relative to bigstring after prefix
    pub fn ap_stripprefix(bigstring: *const ::libc::c_char, prefix: *const ::libc::c_char) -> *const ::libc::c_char;
}

extern "C" {
    /// Decode a base64 encoded string into memory allocated from a pool
/// @param p The pool to allocate from
/// @param bufcoded The encoded string
/// @return The decoded string
    pub fn ap_pbase64decode(p: *mut apr_pool_t, bufcoded: *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Encode a string into memory allocated from a pool in base 64 format
/// @param p The pool to allocate from
/// @param string The plaintext string
/// @return The encoded string
    pub fn ap_pbase64encode(p: *mut apr_pool_t, string: *mut ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Compile a regular expression to be used later
/// @param p The pool to allocate from
/// @param pattern the regular expression to compile
/// @param cflags The bitwise or of one or more of the following:
/// @li REG_EXTENDED - Use POSIX extended Regular Expressions
/// @li REG_ICASE    - Ignore case
/// @li REG_NOSUB    - Support for substring addressing of matches
/// not required
/// @li REG_NEWLINE  - Match-any-character operators don't match new-line
/// @return The compiled regular expression
    pub fn ap_pregcomp(p: *mut apr_pool_t, pattern: *const ::libc::c_char, cflags: ::libc::c_int) -> *mut ap_regex_t;
}

extern "C" {
    /// Free the memory associated with a compiled regular expression
/// @param p The pool the regex was allocated from
/// @param reg The regular expression to free
    pub fn ap_pregfree(p: *mut apr_pool_t, reg: *mut ap_regex_t);
}

extern "C" {
    /// After performing a successful regex match, you may use this function to
/// perform a series of string substitutions based on subexpressions that were
/// matched during the call to ap_regexec
/// @param p The pool to allocate from
/// @param input An arbitrary string containing $1 through $9.  These are
/// replaced with the corresponding matched sub-expressions
/// @param source The string that was originally matched to the regex
/// @param nmatch the nmatch returned from ap_pregex
/// @param pmatch the pmatch array returned from ap_pregex
    pub fn ap_pregsub(p: *mut apr_pool_t, input: *const ::libc::c_char, source: *const ::libc::c_char, nmatch: usize, pmatch: *mut ap_regmatch_t) -> *mut ::libc::c_char;
}

extern "C" {
    /// After performing a successful regex match, you may use this function to
/// perform a series of string substitutions based on subexpressions that were
/// matched during the call to ap_regexec
/// @param p The pool to allocate from
/// @param result where to store the result, will be set to NULL on error
/// @param input An arbitrary string containing $1 through $9.  These are
/// replaced with the corresponding matched sub-expressions
/// @param source The string that was originally matched to the regex
/// @param nmatch the nmatch returned from ap_pregex
/// @param pmatch the pmatch array returned from ap_pregex
/// @param maxlen the maximum string length to return, 0 for unlimited
/// @return APR_SUCCESS if successful, APR_ENOMEM or other error code otherwise.
    pub fn ap_pregsub_ex(p: *mut apr_pool_t, result: *mut *mut ::libc::c_char, input: *const ::libc::c_char, source: *const ::libc::c_char, nmatch: apr_size_t, pmatch: *mut ap_regmatch_t, maxlen: apr_size_t) -> apr_status_t;
}

extern "C" {
    /// We want to downcase the type/subtype for comparison purposes
/// but nothing else because ;parameter=foo values are case sensitive.
/// @param s The content-type to convert to lowercase
    pub fn ap_content_type_tolower(s: *mut ::libc::c_char);
}

extern "C" {
    /// convert a string to all lowercase
/// @param s The string to convert to lowercase
    pub fn ap_str_tolower(s: *mut ::libc::c_char);
}

extern "C" {
    /// Search a string from left to right for the first occurrence of a
/// specific character
/// @param str The string to search
/// @param c The character to search for
/// @return The index of the first occurrence of c in str
    pub fn ap_ind(str: *const ::libc::c_char, c: ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Search a string from right to left for the first occurrence of a
/// specific character
/// @param str The string to search
/// @param c The character to search for
/// @return The index of the first occurrence of c in str
    pub fn ap_rind(str: *const ::libc::c_char, c: ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Given a string, replace any bare " with \" .
/// @param p The pool to allocate memory from
/// @param instring The string to search for "
/// @return A copy of the string with escaped quotes
    pub fn ap_escape_quotes(p: *mut apr_pool_t, instring: *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Given a string, append the PID deliminated by delim.
/// Usually used to create a pid-appended filepath name
/// (eg: /a/b/foo -> /a/b/foo.6726). A function, and not
/// a macro, to avoid unistd.h dependency
/// @param p The pool to allocate memory from
/// @param string The string to append the PID to
/// @param delim The string to use to deliminate the string from the PID
/// @return A copy of the string with the PID appended
    pub fn ap_append_pid(p: *mut apr_pool_t, string: *const ::libc::c_char, delim: *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Parse a given timeout parameter string into an apr_interval_time_t value.
/// The unit of the time interval is given as postfix string to the numeric
/// string. Currently the following units are understood:
///
/// ms    : milliseconds
/// s     : seconds
/// mi[n] : minutes
/// h     : hours
///
/// If no unit is contained in the given timeout parameter the default_time_unit
/// will be used instead.
/// @param timeout_parameter The string containing the timeout parameter.
/// @param timeout The timeout value to be returned.
/// @param default_time_unit The default time unit to use if none is specified
/// in timeout_parameter.
/// @return Status value indicating whether the parsing was successful or not.
    pub fn ap_timeout_parameter_parse(timeout_parameter: *const ::libc::c_char, timeout: *mut apr_interval_time_t, default_time_unit: *const ::libc::c_char) -> apr_status_t;
}

extern "C" {
    /// Given the name of an object in the file system determine if it is a directory
/// @param p The pool to allocate from
/// @param name The name of the object to check
/// @return 1 if it is a directory, 0 otherwise
    pub fn ap_is_rdirectory(p: *mut apr_pool_t, name: *const ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Given the name of an object in the file system determine if it is a directory - this version is symlink aware
/// @param p The pool to allocate from
/// @param name The name of the object to check
/// @return 1 if it is a directory, 0 otherwise
    pub fn ap_is_directory(p: *mut apr_pool_t, name: *const ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Determine the local host name for the current machine
/// @param p The pool to allocate from
/// @return A copy of the local host name
    pub fn ap_get_local_host(p: *mut apr_pool_t) -> *mut ::libc::c_char;
}

extern "C" {
    /// Log an assertion to the error log
/// @param szExp The assertion that failed
/// @param szFile The file the assertion is in
/// @param nLine The line the assertion is defined on
    pub fn ap_log_assert(szExp: *const ::libc::c_char, szFile: *const ::libc::c_char, nLine: ::libc::c_int);
}

extern "C" {
    /// @} */
/// /**
/// Get HTML describing the address and (optionally) admin of the server.
/// @param prefix Text which is prepended to the return value
/// @param r The request_rec
/// @return HTML describing the server, allocated in @a r's pool.
    pub fn ap_psignature(prefix: *const ::libc::c_char, r: *mut request_rec) -> *const ::libc::c_char;
}

extern "C" {
    /// Short function to execute a command and return the first line of
/// output minus \r \n. Useful for "obscuring" passwords via exec calls
/// @param p the pool to allocate from
/// @param cmd the command to execute
/// @param argv the arguments to pass to the cmd
/// @return ptr to characters or NULL on any error
    pub fn ap_get_exec_line(p: *mut apr_pool_t, cmd: *const ::libc::c_char, argv: *const *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" { pub fn ap_strchr(s: *mut ::libc::c_char, c: ::libc::c_int) -> *mut ::libc::c_char; }

extern "C" { pub fn ap_strchr_c(s: *const ::libc::c_char, c: ::libc::c_int) -> *const ::libc::c_char; }

extern "C" { pub fn ap_strrchr(s: *mut ::libc::c_char, c: ::libc::c_int) -> *mut ::libc::c_char; }

extern "C" { pub fn ap_strrchr_c(s: *const ::libc::c_char, c: ::libc::c_int) -> *const ::libc::c_char; }

extern "C" { pub fn ap_strstr(s: *mut ::libc::c_char, c: *const ::libc::c_char) -> *mut ::libc::c_char; }

extern "C" { pub fn ap_strstr_c(s: *const ::libc::c_char, c: *const ::libc::c_char) -> *const ::libc::c_char; }

/// @brief Structure used to build the config tree.
///
/// The config tree only stores
/// the directives that will be active in the running server.  Directives
/// that contain other directions, such as <Directory ...> cause a sub-level
/// to be created, where the included directives are stored.  The closing
/// directive (</Directory>) is not stored in the tree.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_directive_t {
    /// The current directive
    pub directive: *const ::libc::c_char,
    /// The arguments for the current directive, stored as a space
    /// separated list
    pub args: *const ::libc::c_char,
    /// The next directive node in the tree
    /// @defvar ap_directive_t *next
    pub next: *mut ap_directive_t,
    /// The first child node of this directive
    /// @defvar ap_directive_t *first_child
    pub first_child: *mut ap_directive_t,
    /// The parent node of this directive
    /// @defvar ap_directive_t *parent
    pub parent: *mut ap_directive_t,
    /// directive's module can store add'l data here
    pub data: *mut ::libc::c_void,
    /// The name of the file this directive was found in
    pub filename: *const ::libc::c_char,
    /// The line number the directive was on
    pub line_num: ::libc::c_int,
}

#[test]
fn bindgen_test_layout_ap_directive_t() {
    assert_eq!(::std::mem::size_of::<ap_directive_t>(), 64usize, concat!( "Size of: " , stringify ! ( ap_directive_t ) ));
    assert_eq!(::std::mem::align_of::<ap_directive_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_directive_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_directive_t>())).directive as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_directive_t ) , "::" , stringify ! ( directive ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_directive_t>())).args as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_directive_t ) , "::" , stringify ! ( args ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_directive_t>())).next as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_directive_t ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_directive_t>())).first_child as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_directive_t ) , "::" , stringify ! ( first_child ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_directive_t>())).parent as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_directive_t ) , "::" , stringify ! ( parent ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_directive_t>())).data as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( ap_directive_t ) , "::" , stringify ! ( data ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_directive_t>())).filename as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( ap_directive_t ) , "::" , stringify ! ( filename ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_directive_t>())).line_num as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( ap_directive_t ) , "::" , stringify ! ( line_num ) ));
}

extern "C" {
    #[link_name = "\u{1}ap_conftree"]
    pub static mut ap_conftree: *mut ap_directive_t;
}

extern "C" {
    /// Add a node to the configuration tree.
/// @param parent The current parent node.  If the added node is a first_child,
/// then this is changed to the current node
/// @param current The current node
/// @param toadd The node to add to the tree
/// @param child Is the node to add a child node
/// @return the added node
    pub fn ap_add_node(parent: *mut *mut ap_directive_t, current: *mut ap_directive_t, toadd: *mut ap_directive_t, child: ::libc::c_int) -> *mut ap_directive_t;
}

/// < cmd_func parses command line itself
pub const cmd_how_RAW_ARGS: cmd_how = 0;
/// < one argument only
pub const cmd_how_TAKE1: cmd_how = 1;
/// < two arguments only
pub const cmd_how_TAKE2: cmd_how = 2;
/// < one argument, occuring multiple times
/// (e.g., IndexIgnore)
pub const cmd_how_ITERATE: cmd_how = 3;
/// < two arguments, 2nd occurs multiple times
/// (e.g., AddIcon)
pub const cmd_how_ITERATE2: cmd_how = 4;
/// < One of 'On' or 'Off'
pub const cmd_how_FLAG: cmd_how = 5;
/// < No args at all, e.g. </Directory>
pub const cmd_how_NO_ARGS: cmd_how = 6;
/// < one or two arguments
pub const cmd_how_TAKE12: cmd_how = 7;
/// < three arguments only
pub const cmd_how_TAKE3: cmd_how = 8;
/// < two or three arguments
pub const cmd_how_TAKE23: cmd_how = 9;
/// < one, two or three arguments
pub const cmd_how_TAKE123: cmd_how = 10;
/// < one or three arguments
pub const cmd_how_TAKE13: cmd_how = 11;
/// < an argc and argv are passed
pub const cmd_how_TAKE_ARGV: cmd_how = 12;

/// How the directives arguments should be parsed.
/// @remark Note that for all of these except RAW_ARGS, the config routine is
/// passed a freshly allocated string which can be modified or stored
/// or whatever...
pub type cmd_how = u32;
/// This structure is passed to a command which is being invoked,
/// to carry a large variety of miscellaneous data which is all of
/// use to *somebody*...
pub type cmd_parms = cmd_parms_struct;

/// All the types of functions that can be used in directives
/// @internal
#[repr(C)]
#[derive(Copy, Clone)]
pub union cmd_func {
    /// function to call for a no-args
    pub no_args: ::std::option::Option<unsafe extern "C" fn(parms: *mut cmd_parms, mconfig: *mut ::libc::c_void) -> *const ::libc::c_char>,
    /// function to call for a raw-args
    pub raw_args: ::std::option::Option<unsafe extern "C" fn(parms: *mut cmd_parms, mconfig: *mut ::libc::c_void, args: *const ::libc::c_char) -> *const ::libc::c_char>,
    /// function to call for a argv/argc
    pub take_argv: ::std::option::Option<unsafe extern "C" fn(parms: *mut cmd_parms, mconfig: *mut ::libc::c_void, argc: ::libc::c_int, argv: *const *const ::libc::c_char) -> *const ::libc::c_char>,
    /// function to call for a take1
    pub take1: ::std::option::Option<unsafe extern "C" fn(parms: *mut cmd_parms, mconfig: *mut ::libc::c_void, w: *const ::libc::c_char) -> *const ::libc::c_char>,
    /// function to call for a take2
    pub take2: ::std::option::Option<unsafe extern "C" fn(parms: *mut cmd_parms, mconfig: *mut ::libc::c_void, w: *const ::libc::c_char, w2: *const ::libc::c_char) -> *const ::libc::c_char>,
    /// function to call for a take3
    pub take3: ::std::option::Option<unsafe extern "C" fn(parms: *mut cmd_parms, mconfig: *mut ::libc::c_void, w: *const ::libc::c_char, w2: *const ::libc::c_char, w3: *const ::libc::c_char) -> *const ::libc::c_char>,
    /// function to call for a flag
    pub flag: ::std::option::Option<unsafe extern "C" fn(parms: *mut cmd_parms, mconfig: *mut ::libc::c_void, on: ::libc::c_int) -> *const ::libc::c_char>,
    _bindgen_union_align: u64,
}

#[test]
fn bindgen_test_layout_cmd_func() {
    assert_eq!(::std::mem::size_of::<cmd_func>(), 8usize, concat!( "Size of: " , stringify ! ( cmd_func ) ));
    assert_eq!(::std::mem::align_of::<cmd_func>(), 8usize, concat!( "Alignment of " , stringify ! ( cmd_func ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_func>())).no_args as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( cmd_func ) , "::" , stringify ! ( no_args ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_func>())).raw_args as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( cmd_func ) , "::" , stringify ! ( raw_args ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_func>())).take_argv as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( cmd_func ) , "::" , stringify ! ( take_argv ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_func>())).take1 as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( cmd_func ) , "::" , stringify ! ( take1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_func>())).take2 as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( cmd_func ) , "::" , stringify ! ( take2 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_func>())).take3 as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( cmd_func ) , "::" , stringify ! ( take3 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_func>())).flag as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( cmd_func ) , "::" , stringify ! ( flag ) ));
}

/// The command record structure.  Each modules can define a table of these
/// to define the directives it will implement.
pub type command_rec = command_struct;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct command_struct {
    /// Name of this command
    pub name: *const ::libc::c_char,
    /// The function to be called when this directive is parsed
    pub func: cmd_func,
    /// Extra data, for functions which implement multiple commands...
    pub cmd_data: *mut ::libc::c_void,
    /// What overrides need to be allowed to enable this command.
    pub req_override: ::libc::c_int,
    /// What the command expects as arguments
    /// @defvar cmd_how args_how
    pub args_how: cmd_how,
    /// 'usage' message, in case of syntax errors
    pub errmsg: *const ::libc::c_char,
}

#[test]
fn bindgen_test_layout_command_struct() {
    assert_eq!(::std::mem::size_of::<command_struct>(), 40usize, concat!( "Size of: " , stringify ! ( command_struct ) ));
    assert_eq!(::std::mem::align_of::<command_struct>(), 8usize, concat!( "Alignment of " , stringify ! ( command_struct ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<command_struct>())).name as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( command_struct ) , "::" , stringify ! ( name ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<command_struct>())).func as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( command_struct ) , "::" , stringify ! ( func ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<command_struct>())).cmd_data as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( command_struct ) , "::" , stringify ! ( cmd_data ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<command_struct>())).req_override as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( command_struct ) , "::" , stringify ! ( req_override ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<command_struct>())).args_how as *const _ as usize }, 28usize, concat!( "Offset of field: " , stringify ! ( command_struct ) , "::" , stringify ! ( args_how ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<command_struct>())).errmsg as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( command_struct ) , "::" , stringify ! ( errmsg ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_configfile_t {
    /// < a getc()-like function
    pub getch: ::std::option::Option<unsafe extern "C" fn(param: *mut ::libc::c_void) -> ::libc::c_int>,
    pub getstr: ::std::option::Option<unsafe extern "C" fn(buf: *mut ::libc::c_void, bufsiz: usize, param: *mut ::libc::c_void) -> *mut ::libc::c_void>,
    /// < a close handler function
    pub close: ::std::option::Option<unsafe extern "C" fn(param: *mut ::libc::c_void) -> ::libc::c_int>,
    /// < the argument passed to getch/getstr/close
    pub param: *mut ::libc::c_void,
    /// < the filename / description
    pub name: *const ::libc::c_char,
    /// < current line number, starting at 1
    pub line_number: ::libc::c_uint,
}

#[test]
fn bindgen_test_layout_ap_configfile_t() {
    assert_eq!(::std::mem::size_of::<ap_configfile_t>(), 48usize, concat!( "Size of: " , stringify ! ( ap_configfile_t ) ));
    assert_eq!(::std::mem::align_of::<ap_configfile_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_configfile_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_configfile_t>())).getch as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_configfile_t ) , "::" , stringify ! ( getch ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_configfile_t>())).getstr as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_configfile_t ) , "::" , stringify ! ( getstr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_configfile_t>())).close as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_configfile_t ) , "::" , stringify ! ( close ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_configfile_t>())).param as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_configfile_t ) , "::" , stringify ! ( param ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_configfile_t>())).name as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_configfile_t ) , "::" , stringify ! ( name ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_configfile_t>())).line_number as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( ap_configfile_t ) , "::" , stringify ! ( line_number ) ));
}

/// This structure is passed to a command which is being invoked,
/// to carry a large variety of miscellaneous data which is all of
/// use to *somebody*...
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_parms_struct {
    /// Argument to command from cmd_table
    pub info: *mut ::libc::c_void,
    /// Which allow-override bits are set
    pub override_: ::libc::c_int,
    /// Which methods are <Limit>ed
    pub limited: apr_int64_t,
    /// methods which are limited
    pub limited_xmethods: *mut apr_array_header_t,
    /// methods which are xlimited
    pub xlimited: *mut ap_method_list_t,
    /// Config file structure.
    pub config_file: *mut ap_configfile_t,
    /// the directive specifying this command
    pub directive: *mut ap_directive_t,
    /// Pool to allocate new storage in
    pub pool: *mut apr_pool_t,
    /// Pool for scratch memory; persists during configuration, but
    /// wiped before the first request is served...
    pub temp_pool: *mut apr_pool_t,
    /// Server_rec being configured for
    pub server: *mut server_rec,
    /// If configuring for a directory, pathname of that directory.
    /// NOPE!  That's what it meant previous to the existance of <Files>,
    /// <Location> and regex matching.  Now the only usefulness that can be
    /// derived from this field is whether a command is being called in a
    /// server context (path == NULL) or being called in a dir context
    /// (path != NULL).
    pub path: *mut ::libc::c_char,
    /// configuration command
    pub cmd: *const command_rec,
    /// per_dir_config vector passed to handle_command
    pub context: *mut ap_conf_vector_t,
    /// directive with syntax error
    pub err_directive: *const ap_directive_t,
    /// Which allow-override-opts bits are set
    pub override_opts: ::libc::c_int,
}

#[test]
fn bindgen_test_layout_cmd_parms_struct() {
    assert_eq!(::std::mem::size_of::<cmd_parms_struct>(), 120usize, concat!( "Size of: " , stringify ! ( cmd_parms_struct ) ));
    assert_eq!(::std::mem::align_of::<cmd_parms_struct>(), 8usize, concat!( "Alignment of " , stringify ! ( cmd_parms_struct ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).info as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( info ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).override_ as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( override_ ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).limited as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( limited ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).limited_xmethods as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( limited_xmethods ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).xlimited as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( xlimited ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).config_file as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( config_file ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).directive as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( directive ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).pool as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).temp_pool as *const _ as usize }, 64usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( temp_pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).server as *const _ as usize }, 72usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( server ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).path as *const _ as usize }, 80usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( path ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).cmd as *const _ as usize }, 88usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( cmd ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).context as *const _ as usize }, 96usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( context ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).err_directive as *const _ as usize }, 104usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( err_directive ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).override_opts as *const _ as usize }, 112usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( override_opts ) ));
}

/// Module structures.  Just about everything is dispatched through
/// these, directly or indirectly (through the command and handler
/// tables).
pub type module = module_struct;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_struct {
    /// API version, *not* module version; check that module is
    /// compatible with this version of the server.
    pub version: ::libc::c_int,
    /// API minor version. Provides API feature milestones. Not checked
    /// during module init
    pub minor_version: ::libc::c_int,
    /// Index to this modules structures in config vectors.
    pub module_index: ::libc::c_int,
    /// The name of the module's C file
    pub name: *const ::libc::c_char,
    /// The handle for the DSO.  Internal use only
    pub dynamic_load_handle: *mut ::libc::c_void,
    /// A pointer to the next module in the list
    /// @defvar module_struct *next
    pub next: *mut module_struct,
    /// Magic Cookie to identify a module structure;  It's mainly
    /// important for the DSO facility (see also mod_so).
    pub magic: ::libc::c_ulong,
    /// Function to allow MPMs to re-write command line arguments.  This
    /// hook is only available to MPMs.
    /// @param The process that the server is running in.
    pub rewrite_args: ::std::option::Option<unsafe extern "C" fn(process: *mut process_rec)>,
    /// Function to allow all modules to create per directory configuration
    /// structures.
    /// @param p The pool to use for all allocations.
    /// @param dir The directory currently being processed.
    /// @return The per-directory structure created
    pub create_dir_config: ::std::option::Option<unsafe extern "C" fn(p: *mut apr_pool_t, dir: *mut ::libc::c_char) -> *mut ::libc::c_void>,
    /// Function to allow all modules to merge the per directory configuration
    /// structures for two directories.
    /// @param p The pool to use for all allocations.
    /// @param base_conf The directory structure created for the parent directory.
    /// @param new_conf The directory structure currently being processed.
    /// @return The new per-directory structure created
    pub merge_dir_config: ::std::option::Option<unsafe extern "C" fn(p: *mut apr_pool_t, base_conf: *mut ::libc::c_void, new_conf: *mut ::libc::c_void) -> *mut ::libc::c_void>,
    /// Function to allow all modules to create per server configuration
    /// structures.
    /// @param p The pool to use for all allocations.
    /// @param s The server currently being processed.
    /// @return The per-server structure created
    pub create_server_config: ::std::option::Option<unsafe extern "C" fn(p: *mut apr_pool_t, s: *mut server_rec) -> *mut ::libc::c_void>,
    /// Function to allow all modules to merge the per server configuration
    /// structures for two servers.
    /// @param p The pool to use for all allocations.
    /// @param base_conf The directory structure created for the parent directory.
    /// @param new_conf The directory structure currently being processed.
    /// @return The new per-directory structure created
    pub merge_server_config: ::std::option::Option<unsafe extern "C" fn(p: *mut apr_pool_t, base_conf: *mut ::libc::c_void, new_conf: *mut ::libc::c_void) -> *mut ::libc::c_void>,
    /// A command_rec table that describes all of the directives this module
    /// defines.
    pub cmds: *const command_rec,
    /// A hook to allow modules to hook other points in the request processing.
    /// In this function, modules should call the ap_hook_*() functions to
    /// register an interest in a specific step in processing the current
    /// request.
    /// @param p the pool to use for all allocations
    pub register_hooks: ::std::option::Option<unsafe extern "C" fn(p: *mut apr_pool_t)>,
}

#[test]
fn bindgen_test_layout_module_struct() {
    assert_eq!(::std::mem::size_of::<module_struct>(), 104usize, concat!( "Size of: " , stringify ! ( module_struct ) ));
    assert_eq!(::std::mem::align_of::<module_struct>(), 8usize, concat!( "Alignment of " , stringify ! ( module_struct ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).version as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( version ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).minor_version as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( minor_version ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).module_index as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( module_index ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).name as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( name ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).dynamic_load_handle as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( dynamic_load_handle ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).next as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).magic as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( magic ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).rewrite_args as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( rewrite_args ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).create_dir_config as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( create_dir_config ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).merge_dir_config as *const _ as usize }, 64usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( merge_dir_config ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).create_server_config as *const _ as usize }, 72usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( create_server_config ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).merge_server_config as *const _ as usize }, 80usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( merge_server_config ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).cmds as *const _ as usize }, 88usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( cmds ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).register_hooks as *const _ as usize }, 96usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( register_hooks ) ));
}

extern "C" {
    /// Generic accessors for other modules to get at their own module-specific
/// data
/// @param conf_vector The vector in which the modules configuration is stored.
/// usually r->per_dir_config or s->module_config
/// @param m The module to get the data for.
/// @return The module-specific data
    pub fn ap_get_module_config(cv: *const ap_conf_vector_t, m: *const module) -> *mut ::libc::c_void;
}

extern "C" {
    /// Generic accessors for other modules to set at their own module-specific
/// data
/// @param conf_vector The vector in which the modules configuration is stored.
/// usually r->per_dir_config or s->module_config
/// @param m The module to set the data for.
/// @param val The module-specific data to set
    pub fn ap_set_module_config(cv: *mut ap_conf_vector_t, m: *const module, val: *mut ::libc::c_void);
}

extern "C" {
    /// Generic command handling function for strings
/// @param cmd The command parameters for this directive
/// @param struct_ptr pointer into a given type
/// @param arg The argument to the directive
/// @return An error string or NULL on success
    pub fn ap_set_string_slot(cmd: *mut cmd_parms, struct_ptr: *mut ::libc::c_void, arg: *const ::libc::c_char) -> *const ::libc::c_char;
}

extern "C" {
    /// Generic command handling function for integers
/// @param cmd The command parameters for this directive
/// @param struct_ptr pointer into a given type
/// @param arg The argument to the directive
/// @return An error string or NULL on success
    pub fn ap_set_int_slot(cmd: *mut cmd_parms, struct_ptr: *mut ::libc::c_void, arg: *const ::libc::c_char) -> *const ::libc::c_char;
}

extern "C" {
    /// Return true if the specified method is limited by being listed in
/// a <Limit> container, or by *not* being listed in a <LimiteExcept>
/// container.
///
/// @param   method  Pointer to a string specifying the method to check.
/// @param   cmd     Pointer to the cmd_parms structure passed to the
/// directive handler.
/// @return  0 if the method is not limited in the current scope
    pub fn ap_method_is_limited(cmd: *mut cmd_parms, method: *const ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Generic command handling function for strings, always sets the value
/// to a lowercase string
/// @param cmd The command parameters for this directive
/// @param struct_ptr pointer into a given type
/// @param arg The argument to the directive
/// @return An error string or NULL on success
    pub fn ap_set_string_slot_lower(cmd: *mut cmd_parms, struct_ptr: *mut ::libc::c_void, arg: *const ::libc::c_char) -> *const ::libc::c_char;
}

extern "C" {
    /// Generic command handling function for flags
/// @param cmd The command parameters for this directive
/// @param struct_ptr pointer into a given type
/// @param arg The argument to the directive (either 1 or 0)
/// @return An error string or NULL on success
    pub fn ap_set_flag_slot(cmd: *mut cmd_parms, struct_ptr: *mut ::libc::c_void, arg: ::libc::c_int) -> *const ::libc::c_char;
}

extern "C" {
    /// Generic command handling function for files
/// @param cmd The command parameters for this directive
/// @param struct_ptr pointer into a given type
/// @param arg The argument to the directive
/// @return An error string or NULL on success
    pub fn ap_set_file_slot(cmd: *mut cmd_parms, struct_ptr: *mut ::libc::c_void, arg: *const ::libc::c_char) -> *const ::libc::c_char;
}

extern "C" {
    /// Generic command handling function to respond with cmd->help as an error
/// @param cmd The command parameters for this directive
/// @param struct_ptr pointer into a given type
/// @param arg The argument to the directive
/// @return The cmd->help value as the error string
/// @tip This allows simple declarations such as;
/// <pre>
/// AP_INIT_RAW_ARGS("Foo", ap_set_deprecated, NULL, OR_ALL,
/// "The Foo directive is no longer supported, use Bar"),
/// </pre>
    pub fn ap_set_deprecated(cmd: *mut cmd_parms, struct_ptr: *mut ::libc::c_void, arg: *const ::libc::c_char) -> *const ::libc::c_char;
}

extern "C" {
    /// For modules which need to read config files, open logs, etc. this returns
/// the canonical form of fname made absolute to ap_server_root.
/// @param p pool to allocate data from
/// @param fname The file name
    pub fn ap_server_root_relative(p: *mut apr_pool_t, fname: *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Add a module to the server
/// @param m The module structure of the module to add
/// @param p The pool of the same lifetime as the module
    pub fn ap_add_module(m: *mut module, p: *mut apr_pool_t) -> *const ::libc::c_char;
}

extern "C" {
    /// Remove a module from the server.  There are some caveats:
/// when the module is removed, its slot is lost so all the current
/// per-dir and per-server configurations are invalid. So we should
/// only ever call this function when you are invalidating almost
/// all our current data. I.e. when doing a restart.
/// @param m the module structure of the module to remove
    pub fn ap_remove_module(m: *mut module);
}

extern "C" {
    /// Add a module to the chained modules list and the list of loaded modules
/// @param m The module structure of the module to add
/// @param p The pool with the same lifetime as the module
    pub fn ap_add_loaded_module(mod_: *mut module, p: *mut apr_pool_t) -> *const ::libc::c_char;
}

extern "C" {
    /// Remove a module fromthe chained modules list and the list of loaded modules
/// @param m the module structure of the module to remove
    pub fn ap_remove_loaded_module(mod_: *mut module);
}

extern "C" {
    /// Find the name of the specified module
/// @param m The module to get the name for
/// @return the name of the module
    pub fn ap_find_module_name(m: *mut module) -> *const ::libc::c_char;
}

extern "C" {
    /// Find a module based on the name of the module
/// @param name the name of the module
/// @return the module structure if found, NULL otherwise
    pub fn ap_find_linked_module(name: *const ::libc::c_char) -> *mut module;
}

extern "C" {
    /// Open a ap_configfile_t as apr_file_t
/// @param ret_cfg open ap_configfile_t struct pointer
/// @param p The pool to allocate the structure from
/// @param name the name of the file to open
    pub fn ap_pcfg_openfile(ret_cfg: *mut *mut ap_configfile_t, p: *mut apr_pool_t, name: *const ::libc::c_char) -> apr_status_t;
}

extern "C" {
    /// Allocate a ap_configfile_t handle with user defined functions and params
/// @param p The pool to allocate from
/// @param descr The name of the file
/// @param param The argument passed to getch/getstr/close
/// @param getc_func The getch function
/// @param gets_func The getstr function
/// @param close_func The close function
    pub fn ap_pcfg_open_custom(p: *mut apr_pool_t, descr: *const ::libc::c_char, param: *mut ::libc::c_void, getc_func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void) -> ::libc::c_int>, gets_func: ::std::option::Option<unsafe extern "C" fn(buf: *mut ::libc::c_void, bufsiz: usize, param: *mut ::libc::c_void) -> *mut ::libc::c_void>, close_func: ::std::option::Option<unsafe extern "C" fn(param: *mut ::libc::c_void) -> ::libc::c_int>) -> *mut ap_configfile_t;
}

extern "C" {
    /// Read one line from open ap_configfile_t, strip LF, increase line number
/// @param buf place to store the line read
/// @param bufsize size of the buffer
/// @param cfp File to read from
/// @return 1 on success, 0 on failure
    pub fn ap_cfg_getline(buf: *mut ::libc::c_char, bufsize: usize, cfp: *mut ap_configfile_t) -> ::libc::c_int;
}

extern "C" {
    /// Read one char from open configfile_t, increase line number upon LF
/// @param cfp The file to read from
/// @return the character read
    pub fn ap_cfg_getc(cfp: *mut ap_configfile_t) -> ::libc::c_int;
}

extern "C" {
    /// Detach from open ap_configfile_t, calling the close handler
/// @param cfp The file to close
/// @return 1 on sucess, 0 on failure
    pub fn ap_cfg_closefile(cfp: *mut ap_configfile_t) -> ::libc::c_int;
}

extern "C" {
    /// Read all data between the current <foo> and the matching </foo>.  All
/// of this data is forgotten immediately.
/// @param cmd The cmd_parms to pass to the directives inside the container
/// @param directive The directive name to read until
/// @return Error string on failure, NULL on success
    pub fn ap_soak_end_container(cmd: *mut cmd_parms, directive: *mut ::libc::c_char) -> *const ::libc::c_char;
}

extern "C" {
    /// Read all data between the current <foo> and the matching </foo> and build
/// a config tree from it
/// @param p pool to allocate from
/// @param temp_pool Temporary pool to allocate from
/// @param parms The cmd_parms to pass to all directives read
/// @param current The current node in the tree
/// @param curr_parent The current parent node
/// @param orig_directive The directive to read until hit.
/// @return Error string on failure, NULL on success
    pub fn ap_build_cont_config(p: *mut apr_pool_t, temp_pool: *mut apr_pool_t, parms: *mut cmd_parms, current: *mut *mut ap_directive_t, curr_parent: *mut *mut ap_directive_t, orig_directive: *mut ::libc::c_char) -> *const ::libc::c_char;
}

extern "C" {
    /// Build a config tree from a config file
/// @param parms The cmd_parms to pass to all of the directives in the file
/// @param conf_pool The pconf pool
/// @param temp_pool The temporary pool
/// @param conftree Place to store the root node of the config tree
/// @return Error string on erro, NULL otherwise
    pub fn ap_build_config(parms: *mut cmd_parms, conf_pool: *mut apr_pool_t, temp_pool: *mut apr_pool_t, conftree: *mut *mut ap_directive_t) -> *const ::libc::c_char;
}

extern "C" {
    /// Walk a config tree and setup the server's internal structures
/// @param conftree The config tree to walk
/// @param parms The cmd_parms to pass to all functions
/// @param section_vector The per-section config vector.
/// @return Error string on error, NULL otherwise
    pub fn ap_walk_config(conftree: *mut ap_directive_t, parms: *mut cmd_parms, section_vector: *mut ap_conf_vector_t) -> *const ::libc::c_char;
}

extern "C" {
    /// @defgroup ap_check_cmd_context Check command context
/// @{
/// /
/// /**
/// Check the context a command is used in.
/// @param cmd The command to check
/// @param forbidden Where the command is forbidden.
/// @return Error string on error, NULL on success
    pub fn ap_check_cmd_context(cmd: *mut cmd_parms, forbidden: ::libc::c_uint) -> *const ::libc::c_char;
}

pub type ap_HOOK_header_parser_t = ::std::option::Option<unsafe extern "C" fn(r: *mut request_rec) -> ::libc::c_int>;

extern "C" { pub fn ap_hook_header_parser(pf: ap_HOOK_header_parser_t, aszPre: *const *const ::libc::c_char, aszSucc: *const *const ::libc::c_char, nOrder: ::libc::c_int); }

extern "C" { pub fn ap_run_header_parser(r: *mut request_rec) -> ::libc::c_int; }

extern "C" { pub fn ap_hook_get_header_parser() -> *mut apr_array_header_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_header_parser_t { pub pFunc: ap_HOOK_header_parser_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_header_parser_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_header_parser_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_header_parser_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_header_parser_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_header_parser_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_header_parser_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_header_parser_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_header_parser_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_header_parser_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_header_parser_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_header_parser_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_header_parser_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_header_parser_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_header_parser_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_header_parser_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_pre_config_t = ::std::option::Option<unsafe extern "C" fn(pconf: *mut apr_pool_t, plog: *mut apr_pool_t, ptemp: *mut apr_pool_t) -> ::libc::c_int>;

extern "C" { pub fn ap_hook_pre_config(pf: ap_HOOK_pre_config_t, aszPre: *const *const ::libc::c_char, aszSucc: *const *const ::libc::c_char, nOrder: ::libc::c_int); }

extern "C" { pub fn ap_run_pre_config(pconf: *mut apr_pool_t, plog: *mut apr_pool_t, ptemp: *mut apr_pool_t) -> ::libc::c_int; }

extern "C" { pub fn ap_hook_get_pre_config() -> *mut apr_array_header_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_pre_config_t { pub pFunc: ap_HOOK_pre_config_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_pre_config_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_pre_config_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_pre_config_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_pre_config_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_pre_config_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_pre_config_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_pre_config_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_pre_config_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_pre_config_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_pre_config_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_pre_config_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_pre_config_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_pre_config_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_pre_config_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_pre_config_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_test_config_t = ::std::option::Option<unsafe extern "C" fn(pconf: *mut apr_pool_t, s: *mut server_rec)>;

extern "C" { pub fn ap_hook_test_config(pf: ap_HOOK_test_config_t, aszPre: *const *const ::libc::c_char, aszSucc: *const *const ::libc::c_char, nOrder: ::libc::c_int); }

extern "C" { pub fn ap_run_test_config(pconf: *mut apr_pool_t, s: *mut server_rec); }

extern "C" { pub fn ap_hook_get_test_config() -> *mut apr_array_header_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_test_config_t { pub pFunc: ap_HOOK_test_config_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_test_config_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_test_config_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_test_config_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_test_config_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_test_config_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_test_config_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_test_config_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_test_config_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_test_config_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_test_config_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_test_config_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_test_config_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_test_config_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_test_config_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_test_config_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_post_config_t = ::std::option::Option<unsafe extern "C" fn(pconf: *mut apr_pool_t, plog: *mut apr_pool_t, ptemp: *mut apr_pool_t, s: *mut server_rec) -> ::libc::c_int>;

extern "C" { pub fn ap_hook_post_config(pf: ap_HOOK_post_config_t, aszPre: *const *const ::libc::c_char, aszSucc: *const *const ::libc::c_char, nOrder: ::libc::c_int); }

extern "C" { pub fn ap_run_post_config(pconf: *mut apr_pool_t, plog: *mut apr_pool_t, ptemp: *mut apr_pool_t, s: *mut server_rec) -> ::libc::c_int; }

extern "C" { pub fn ap_hook_get_post_config() -> *mut apr_array_header_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_post_config_t { pub pFunc: ap_HOOK_post_config_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_post_config_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_post_config_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_post_config_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_post_config_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_post_config_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_post_config_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_post_config_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_post_config_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_post_config_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_post_config_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_post_config_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_post_config_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_post_config_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_post_config_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_post_config_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_open_logs_t = ::std::option::Option<unsafe extern "C" fn(pconf: *mut apr_pool_t, plog: *mut apr_pool_t, ptemp: *mut apr_pool_t, s: *mut server_rec) -> ::libc::c_int>;

extern "C" { pub fn ap_hook_open_logs(pf: ap_HOOK_open_logs_t, aszPre: *const *const ::libc::c_char, aszSucc: *const *const ::libc::c_char, nOrder: ::libc::c_int); }

extern "C" { pub fn ap_run_open_logs(pconf: *mut apr_pool_t, plog: *mut apr_pool_t, ptemp: *mut apr_pool_t, s: *mut server_rec) -> ::libc::c_int; }

extern "C" { pub fn ap_hook_get_open_logs() -> *mut apr_array_header_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_open_logs_t { pub pFunc: ap_HOOK_open_logs_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_open_logs_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_open_logs_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_open_logs_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_open_logs_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_open_logs_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_open_logs_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_open_logs_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_open_logs_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_open_logs_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_open_logs_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_open_logs_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_open_logs_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_open_logs_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_open_logs_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_open_logs_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_child_init_t = ::std::option::Option<unsafe extern "C" fn(pchild: *mut apr_pool_t, s: *mut server_rec)>;

extern "C" { pub fn ap_hook_child_init(pf: ap_HOOK_child_init_t, aszPre: *const *const ::libc::c_char, aszSucc: *const *const ::libc::c_char, nOrder: ::libc::c_int); }

extern "C" { pub fn ap_run_child_init(pchild: *mut apr_pool_t, s: *mut server_rec); }

extern "C" { pub fn ap_hook_get_child_init() -> *mut apr_array_header_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_child_init_t { pub pFunc: ap_HOOK_child_init_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_child_init_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_child_init_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_child_init_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_child_init_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_child_init_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_child_init_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_child_init_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_child_init_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_child_init_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_child_init_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_child_init_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_child_init_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_child_init_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_child_init_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_child_init_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_handler_t = ::std::option::Option<unsafe extern "C" fn(r: *mut request_rec) -> ::libc::c_int>;

extern "C" { pub fn ap_hook_handler(pf: ap_HOOK_handler_t, aszPre: *const *const ::libc::c_char, aszSucc: *const *const ::libc::c_char, nOrder: ::libc::c_int); }

extern "C" { pub fn ap_run_handler(r: *mut request_rec) -> ::libc::c_int; }

extern "C" { pub fn ap_hook_get_handler() -> *mut apr_array_header_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_handler_t { pub pFunc: ap_HOOK_handler_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_handler_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_handler_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_handler_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_handler_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_handler_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_handler_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_handler_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_handler_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_handler_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_handler_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_handler_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_handler_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_handler_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_handler_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_handler_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_quick_handler_t = ::std::option::Option<unsafe extern "C" fn(r: *mut request_rec, lookup_uri: ::libc::c_int) -> ::libc::c_int>;

extern "C" { pub fn ap_hook_quick_handler(pf: ap_HOOK_quick_handler_t, aszPre: *const *const ::libc::c_char, aszSucc: *const *const ::libc::c_char, nOrder: ::libc::c_int); }

extern "C" { pub fn ap_run_quick_handler(r: *mut request_rec, lookup_uri: ::libc::c_int) -> ::libc::c_int; }

extern "C" { pub fn ap_hook_get_quick_handler() -> *mut apr_array_header_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_quick_handler_t { pub pFunc: ap_HOOK_quick_handler_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_quick_handler_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_quick_handler_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_quick_handler_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_quick_handler_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_quick_handler_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_quick_handler_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_quick_handler_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_quick_handler_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_quick_handler_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_quick_handler_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_quick_handler_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_quick_handler_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_quick_handler_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_quick_handler_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_quick_handler_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_optional_fn_retrieve_t = ::std::option::Option<unsafe extern "C" fn()>;

extern "C" { pub fn ap_hook_optional_fn_retrieve(pf: ap_HOOK_optional_fn_retrieve_t, aszPre: *const *const ::libc::c_char, aszSucc: *const *const ::libc::c_char, nOrder: ::libc::c_int); }

extern "C" { pub fn ap_run_optional_fn_retrieve(); }

extern "C" { pub fn ap_hook_get_optional_fn_retrieve() -> *mut apr_array_header_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_optional_fn_retrieve_t { pub pFunc: ap_HOOK_optional_fn_retrieve_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_optional_fn_retrieve_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_optional_fn_retrieve_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_optional_fn_retrieve_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_optional_fn_retrieve_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_optional_fn_retrieve_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_optional_fn_retrieve_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_optional_fn_retrieve_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_optional_fn_retrieve_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_optional_fn_retrieve_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_optional_fn_retrieve_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_optional_fn_retrieve_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_optional_fn_retrieve_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_optional_fn_retrieve_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_optional_fn_retrieve_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_optional_fn_retrieve_t ) , "::" , stringify ! ( nOrder ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data { pub _address: u8 }

pub type __builtin_va_list = [__va_list_tag; 1usize];

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag { pub gp_offset: ::libc::c_uint, pub fp_offset: ::libc::c_uint, pub overflow_arg_area: *mut ::libc::c_void, pub reg_save_area: *mut ::libc::c_void }

#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>(), 24usize, concat!( "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq!(::std::mem::align_of::<__va_list_tag>(), 8usize, concat!( "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( gp_offset ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( fp_offset ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( overflow_arg_area ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( reg_save_area ) ));
}

/// The file's handle, if accessed (can be submitted to apr_duphandle)
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_file_t { pub _address: u8 }

/// the configuration directives
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_conf_vector_t { pub _address: u8 }

/// structure returned from gethostbyname()
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent { pub _address: u8 }

/////////////////////////////////////////

/// The filter should return at most readbytes data.
pub const ap_input_mode_t_AP_MODE_READBYTES: ap_input_mode_t = 0;
/// The filter should return at most one line of CRLF data.
/// (If a potential line is too long or no CRLF is found, the
/// filter may return partial data).
pub const ap_input_mode_t_AP_MODE_GETLINE: ap_input_mode_t = 1;
/// The filter should implicitly eat any CRLF pairs that it sees.
pub const ap_input_mode_t_AP_MODE_EATCRLF: ap_input_mode_t = 2;
/// The filter read should be treated as speculative and any returned
/// data should be stored for later retrieval in another mode.
pub const ap_input_mode_t_AP_MODE_SPECULATIVE: ap_input_mode_t = 3;
/// The filter read should be exhaustive and read until it can not
/// read any more.
/// Use this mode with extreme caution.
pub const ap_input_mode_t_AP_MODE_EXHAUSTIVE: ap_input_mode_t = 4;
/// The filter should initialize the connection if needed,
/// NNTP or FTP over SSL for example.
pub const ap_input_mode_t_AP_MODE_INIT: ap_input_mode_t = 5;

/// @brief input filtering modes
pub type ap_input_mode_t = u32;
/// @name Filter callbacks
///
/// This function type is used for filter callbacks. It will be passed a
/// pointer to "this" filter, and a "bucket" containing the content to be
/// filtered.
///
/// In filter->ctx, the callback will find its context. This context is
/// provided here, so that a filter may be installed multiple times, each
/// receiving its own per-install context pointer.
///
/// Callbacks are associated with a filter definition, which is specified
/// by name. See ap_register_input_filter() and ap_register_output_filter()
/// for setting the association between a name for a filter and its
/// associated callback (and other information).
///
/// If the initialization function argument passed to the registration
/// functions is non-NULL, it will be called iff the filter is in the input
/// or output filter chains and before any data is generated to allow the
/// filter to prepare for processing.
///
/// The *bucket structure (and all those referenced by ->next and ->prev)
/// should be considered "const". The filter is allowed to modify the
/// next/prev to insert/remove/replace elements in the bucket list, but
/// the types and values of the individual buckets should not be altered.
///
/// For the input and output filters, the return value of a filter should be
/// an APR status value.  For the init function, the return value should
/// be an HTTP error code or OK if it was successful.
///
/// @ingroup filter
/// @{
pub type ap_out_filter_func = ::std::option::Option<unsafe extern "C" fn(f: *mut ap_filter_t, b: *mut apr_bucket_brigade) -> apr_status_t>;
pub type ap_in_filter_func = ::std::option::Option<unsafe extern "C" fn(f: *mut ap_filter_t, b: *mut apr_bucket_brigade, mode: ap_input_mode_t, block: apr_read_type_e, readbytes: apr_off_t) -> apr_status_t>;
pub type ap_init_filter_func = ::std::option::Option<unsafe extern "C" fn(f: *mut ap_filter_t) -> ::libc::c_int>;

#[repr(C)]
#[derive(Copy, Clone)]
pub union ap_filter_func { pub out_func: ap_out_filter_func, pub in_func: ap_in_filter_func, _bindgen_union_align: u64 }

#[test]
fn bindgen_test_layout_ap_filter_func() {
    assert_eq!(::std::mem::size_of::<ap_filter_func>(), 8usize, concat!( "Size of: " , stringify ! ( ap_filter_func ) ));
    assert_eq!(::std::mem::align_of::<ap_filter_func>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_filter_func ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_func>())).out_func as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_filter_func ) , "::" , stringify ! ( out_func ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_func>())).in_func as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_filter_func ) , "::" , stringify ! ( in_func ) ));
}

/// These filters are used to alter the content that is passed through
/// them. Examples are SSI or PHP.
pub const ap_filter_type_AP_FTYPE_RESOURCE: ap_filter_type = 10;
/// These filters are used to alter the content as a whole, but after all
/// AP_FTYPE_RESOURCE filters are executed.  These filters should not
/// change the content-type.  An example is deflate.
pub const ap_filter_type_AP_FTYPE_CONTENT_SET: ap_filter_type = 20;
/// These filters are used to handle the protocol between server and
/// client.  Examples are HTTP and POP.
pub const ap_filter_type_AP_FTYPE_PROTOCOL: ap_filter_type = 30;
/// These filters implement transport encodings (e.g., chunking).
pub const ap_filter_type_AP_FTYPE_TRANSCODE: ap_filter_type = 40;
/// These filters will alter the content, but in ways that are
/// more strongly associated with the connection.  Examples are
/// splitting an HTTP connection into multiple requests and
/// buffering HTTP responses across multiple requests.
///
/// It is important to note that these types of filters are not
/// allowed in a sub-request. A sub-request's output can certainly
/// be filtered by ::AP_FTYPE_RESOURCE filters, but all of the "final
/// processing" is determined by the main request.
pub const ap_filter_type_AP_FTYPE_CONNECTION: ap_filter_type = 50;
/// These filters don't alter the content.  They are responsible for
/// sending/receiving data to/from the client.
pub const ap_filter_type_AP_FTYPE_NETWORK: ap_filter_type = 60;

/// Filters have different types/classifications. These are used to group
/// and sort the filters to properly sequence their operation.
///
/// The types have a particular sort order, which allows us to insert them
/// into the filter chain in a determistic order. Within a particular grouping,
/// the ordering is equivalent to the order of calls to ap_add_*_filter().
pub type ap_filter_type = u32;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_filter_provider_t { _unused: [u8; 0] }

/// @brief This structure is used for recording information about the
/// registered filters. It associates a name with the filter's callback
/// and filter type.
///
/// At the moment, these are simply linked in a chain, so a ->next pointer
/// is available.
///
/// It is used for any filter that can be inserted in the filter chain.
/// This may be either a httpd-2.0 filter or a mod_filter harness.
/// In the latter case it contains dispatch, provider and protocol information.
/// In the former case, the new fields (from dispatch) are ignored.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ap_filter_rec_t {
    /// The registered name for this filter
    pub name: *const ::libc::c_char,
    /// The function to call when this filter is invoked.
    pub filter_func: ap_filter_func,
    /// The function to call directly before the handlers are invoked
    /// for a request.  The init function is called once directly
    /// before running the handlers for a request or subrequest.  The
    /// init function is never called for a connection filter (with
    /// ftype >= AP_FTYPE_CONNECTION).  Any use of this function for
    /// filters for protocols other than HTTP is specified by the
    /// module supported that protocol.
    pub filter_init_func: ap_init_filter_func,
    /// The type of filter, either AP_FTYPE_CONTENT or AP_FTYPE_CONNECTION.
    /// An AP_FTYPE_CONTENT filter modifies the data based on information
    /// found in the content.  An AP_FTYPE_CONNECTION filter modifies the
    /// data based on the type of connection.
    pub ftype: ap_filter_type,
    /// The next filter_rec in the list
    pub next: *mut ap_filter_rec_t,
    /// Providers for this filter
    pub providers: *mut ap_filter_provider_t,
    /// Trace level for this filter
    pub debug: ::libc::c_int,
    /// Protocol flags for this filter
    pub proto_flags: ::libc::c_uint,
}

#[test]
fn bindgen_test_layout_ap_filter_rec_t() {
    assert_eq!(::std::mem::size_of::<ap_filter_rec_t>(), 56usize, concat!( "Size of: " , stringify ! ( ap_filter_rec_t ) ));
    assert_eq!(::std::mem::align_of::<ap_filter_rec_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_filter_rec_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_rec_t>())).name as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_filter_rec_t ) , "::" , stringify ! ( name ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_rec_t>())).filter_func as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_filter_rec_t ) , "::" , stringify ! ( filter_func ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_rec_t>())).filter_init_func as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_filter_rec_t ) , "::" , stringify ! ( filter_init_func ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_rec_t>())).ftype as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_filter_rec_t ) , "::" , stringify ! ( ftype ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_rec_t>())).next as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_filter_rec_t ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_rec_t>())).providers as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( ap_filter_rec_t ) , "::" , stringify ! ( providers ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_rec_t>())).debug as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( ap_filter_rec_t ) , "::" , stringify ! ( debug ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_rec_t>())).proto_flags as *const _ as usize }, 52usize, concat!( "Offset of field: " , stringify ! ( ap_filter_rec_t ) , "::" , stringify ! ( proto_flags ) ));
}

/// @brief The representation of a filter chain.
///
/// Each request has a list
/// of these structures which are called in turn to filter the data.  Sub
/// requests get an exact copy of the main requests filter chain.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_filter_t {
    /// The internal representation of this filter.  This includes
    /// the filter's name, type, and the actual function pointer.
    pub frec: *mut ap_filter_rec_t,
    /// A place to store any data associated with the current filter
    pub ctx: *mut ::libc::c_void,
    /// The next filter in the chain
    pub next: *mut ap_filter_t,
    /// The request_rec associated with the current filter.  If a sub-request
    /// adds filters, then the sub-request is the request associated with the
    /// filter.
    pub r: *mut request_rec,
    /// The conn_rec associated with the current filter.  This is analogous
    /// to the request_rec, except that it is used for input filtering.
    pub c: *mut conn_rec,
}

#[test]
fn bindgen_test_layout_ap_filter_t() {
    assert_eq!(::std::mem::size_of::<ap_filter_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_filter_t ) ));
    assert_eq!(::std::mem::align_of::<ap_filter_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_filter_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_t>())).frec as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_filter_t ) , "::" , stringify ! ( frec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_t>())).ctx as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_filter_t ) , "::" , stringify ! ( ctx ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_t>())).next as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_filter_t ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_t>())).r as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_filter_t ) , "::" , stringify ! ( r ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_t>())).c as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_filter_t ) , "::" , stringify ! ( c ) ));
}


// didn't get converted
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_thread_t { _unused: [u8; 0] }
