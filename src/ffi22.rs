#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(dead_code)]

use ffi;

pub const MODULE_MAGIC_COOKIE: ::libc::c_ulong = 0x41503232u64; /* "AP22" */
pub const MODULE_MAGIC_NUMBER_MAJOR: ::libc::c_int = 20051115;
pub const MODULE_MAGIC_NUMBER_MINOR: ::libc::c_int = 43;

/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self {
            storage,
            align: [],
        }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                val |= 1 << i;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            self.set_bit(i + bit_offset, val_bit_is_set);
        }
    }
}

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T> (::std::marker::PhantomData<T>);

impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self { __IncompleteArrayField(::std::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T { ::std::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] { ::std::slice::from_raw_parts(self.as_ptr(), len) }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] { ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len) }
}

impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> { fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result { fmt.write_str("__IncompleteArrayField") } }

impl<T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}

impl<T> ::std::marker::Copy for __IncompleteArrayField<T> {}

pub const APEXIT_CHILDFATAL: u32 = 15;
pub const APEXIT_CHILDINIT: u32 = 3;
pub const APEXIT_CHILDSICK: u32 = 7;
pub const APEXIT_INIT: u32 = 2;
pub const APEXIT_OK: u32 = 0;
pub const APRMAXHOSTLEN: u32 = 256;
pub const APR_ALLOCATOR_MAX_FREE_UNLIMITED: u32 = 0;
pub const APR_ANONYMOUS: u32 = 70019;
pub const APR_ANYADDR: &'static [u8; 8usize] = b"0.0.0.0\0";
pub const APR_APPEND: u32 = 8;
pub const APR_ASCII_BLANK: u8 = 32u8;
pub const APR_ASCII_CR: u8 = 13u8;
pub const APR_ASCII_LF: u8 = 10u8;
pub const APR_ASCII_TAB: u8 = 9u8;
pub const APR_BADARG: u32 = 70013;
pub const APR_BADCH: u32 = 70012;
pub const APR_BINARY: u32 = 32;
pub const APR_BUCKET_BUFF_SIZE: u32 = 8000;
pub const APR_BUFFERED: u32 = 128;
pub const APR_CHARSET_EBCDIC: u32 = 0;
pub const APR_CHILD_DONE: u32 = 70005;
pub const APR_CHILD_NOTDONE: u32 = 70006;
pub const APR_CREATE: u32 = 4;
pub const APR_CTIME_LEN: u32 = 25;
pub const APR_CUR: u32 = 1;
pub const APR_DELONCLOSE: u32 = 256;
pub const APR_DETACH: u32 = 70003;
pub const APR_DSOPATH: &'static [u8; 16usize] = b"LD_LIBRARY_PATH\0";
pub const APR_EABOVEROOT: u32 = 20023;
pub const APR_EABSOLUTE: u32 = 20020;
pub const APR_EACCES: u32 = 13;
pub const APR_EAFNOSUPPORT: u32 = 97;
pub const APR_EAGAIN: u32 = 11;
pub const APR_EBADDATE: u32 = 20004;
pub const APR_EBADF: u32 = 9;
pub const APR_EBADIP: u32 = 20016;
pub const APR_EBADMASK: u32 = 20017;
pub const APR_EBADPATH: u32 = 20024;
pub const APR_EBUSY: u32 = 70025;
pub const APR_ECONNABORTED: u32 = 103;
pub const APR_ECONNREFUSED: u32 = 111;
pub const APR_ECONNRESET: u32 = 104;
pub const APR_EDSOOPEN: u32 = 20019;
pub const APR_EEXIST: u32 = 17;
pub const APR_EFTYPE: u32 = 620023;
pub const APR_EGENERAL: u32 = 20014;
pub const APR_EHOSTUNREACH: u32 = 113;
pub const APR_EINCOMPLETE: u32 = 20022;
pub const APR_EINIT: u32 = 70022;
pub const APR_EINPROGRESS: u32 = 115;
pub const APR_EINTR: u32 = 4;
pub const APR_EINVAL: u32 = 22;
pub const APR_EINVALSOCK: u32 = 20005;
pub const APR_EMFILE: u32 = 24;
pub const APR_EMISMATCH: u32 = 70024;
pub const APR_ENAMETOOLONG: u32 = 36;
pub const APR_END: u32 = 2;
pub const APR_ENETUNREACH: u32 = 101;
pub const APR_ENFILE: u32 = 23;
pub const APR_ENODIR: u32 = 20008;
pub const APR_ENOENT: u32 = 2;
pub const APR_ENOLOCK: u32 = 20009;
pub const APR_ENOMEM: u32 = 12;
pub const APR_ENOPOLL: u32 = 20010;
pub const APR_ENOPOOL: u32 = 20002;
pub const APR_ENOPROC: u32 = 20006;
pub const APR_ENOSHMAVAIL: u32 = 20015;
pub const APR_ENOSOCKET: u32 = 20011;
pub const APR_ENOSPC: u32 = 28;
pub const APR_ENOSTAT: u32 = 20001;
pub const APR_ENOTDIR: u32 = 20;
pub const APR_ENOTEMPTY: u32 = 39;
pub const APR_ENOTENOUGHENTROPY: u32 = 20028;
pub const APR_ENOTHDKEY: u32 = 20013;
pub const APR_ENOTHREAD: u32 = 20012;
pub const APR_ENOTIME: u32 = 20007;
pub const APR_ENOTIMPL: u32 = 70023;
pub const APR_ENOTSOCK: u32 = 88;
pub const APR_EOF: u32 = 70014;
pub const APR_EOL_STR: &'static [u8; 2usize] = b"\n\0";
pub const APR_EPATHWILD: u32 = 20025;
pub const APR_EPIPE: u32 = 32;
pub const APR_EPROC_UNKNOWN: u32 = 20027;
pub const APR_ERELATIVE: u32 = 20021;
pub const APR_ESPIPE: u32 = 29;
pub const APR_ESYMNOTFOUND: u32 = 20026;
pub const APR_ETIMEDOUT: u32 = 110;
pub const APR_EXCL: u32 = 64;
pub const APR_EXDEV: u32 = 18;
pub const APR_FILEBASED: u32 = 70020;
pub const APR_FILEPATH_ENCODING_LOCALE: u32 = 1;
pub const APR_FILEPATH_ENCODING_UNKNOWN: u32 = 0;
pub const APR_FILEPATH_ENCODING_UTF8: u32 = 2;
pub const APR_FILEPATH_NATIVE: u32 = 16;
pub const APR_FILEPATH_NOTABOVEROOT: u32 = 1;
pub const APR_FILEPATH_NOTABSOLUTE: u32 = 8;
pub const APR_FILEPATH_NOTRELATIVE: u32 = 4;
pub const APR_FILEPATH_SECUREROOT: u32 = 3;
pub const APR_FILEPATH_SECUREROOTTEST: u32 = 2;
pub const APR_FILEPATH_TRUENAME: u32 = 32;
pub const APR_FILES_AS_SOCKETS: u32 = 1;
pub const APR_FILE_ATTR_EXECUTABLE: u32 = 2;
pub const APR_FILE_ATTR_HIDDEN: u32 = 4;
pub const APR_FILE_ATTR_READONLY: u32 = 1;
pub const APR_FILE_NOCLEANUP: u32 = 2048;
pub const APR_FILE_SOURCE_PERMS: u32 = 4096;
pub const APR_FINFO_ATIME: u32 = 64;
pub const APR_FINFO_CSIZE: u32 = 512;
pub const APR_FINFO_CTIME: u32 = 32;
pub const APR_FINFO_DEV: u32 = 4096;
pub const APR_FINFO_DIRENT: u32 = 33554432;
pub const APR_FINFO_GPROT: u32 = 2097152;
pub const APR_FINFO_GROUP: u32 = 131072;
pub const APR_FINFO_ICASE: u32 = 16777216;
pub const APR_FINFO_IDENT: u32 = 12288;
pub const APR_FINFO_INODE: u32 = 8192;
pub const APR_FINFO_LINK: u32 = 1;
pub const APR_FINFO_MIN: u32 = 33136;
pub const APR_FINFO_MTIME: u32 = 16;
pub const APR_FINFO_NAME: u32 = 33554432;
pub const APR_FINFO_NLINK: u32 = 16384;
pub const APR_FINFO_NORM: u32 = 7582064;
pub const APR_FINFO_OWNER: u32 = 196608;
pub const APR_FINFO_PROT: u32 = 7340032;
pub const APR_FINFO_SIZE: u32 = 256;
pub const APR_FINFO_TYPE: u32 = 32768;
pub const APR_FINFO_UPROT: u32 = 1048576;
pub const APR_FINFO_USER: u32 = 65536;
pub const APR_FINFO_WPROT: u32 = 4194304;
pub const APR_FLOCK_EXCLUSIVE: u32 = 2;
pub const APR_FLOCK_NONBLOCK: u32 = 16;
pub const APR_FLOCK_SHARED: u32 = 1;
pub const APR_FLOCK_TYPEMASK: u32 = 15;
pub const APR_FOPEN_APPEND: u32 = 8;
pub const APR_FOPEN_BINARY: u32 = 32;
pub const APR_FOPEN_BUFFERED: u32 = 128;
pub const APR_FOPEN_CREATE: u32 = 4;
pub const APR_FOPEN_DELONCLOSE: u32 = 256;
pub const APR_FOPEN_EXCL: u32 = 64;
pub const APR_FOPEN_LARGEFILE: u32 = 16384;
pub const APR_FOPEN_NOCLEANUP: u32 = 2048;
pub const APR_FOPEN_NONBLOCK: u32 = 262144;
pub const APR_FOPEN_READ: u32 = 1;
pub const APR_FOPEN_SENDFILE_ENABLED: u32 = 4096;
pub const APR_FOPEN_SHARELOCK: u32 = 1024;
pub const APR_FOPEN_SPARSE: u32 = 32768;
pub const APR_FOPEN_TRUNCATE: u32 = 16;
pub const APR_FOPEN_WRITE: u32 = 2;
pub const APR_FOPEN_XTHREAD: u32 = 512;
pub const APR_FPROT_FILE_SOURCE_PERMS: u32 = 4096;
pub const APR_FPROT_GEXECUTE: u32 = 16;
pub const APR_FPROT_GREAD: u32 = 64;
pub const APR_FPROT_GSETID: u32 = 16384;
pub const APR_FPROT_GWRITE: u32 = 32;
pub const APR_FPROT_OS_DEFAULT: u32 = 4095;
pub const APR_FPROT_UEXECUTE: u32 = 256;
pub const APR_FPROT_UREAD: u32 = 1024;
pub const APR_FPROT_USETID: u32 = 32768;
pub const APR_FPROT_UWRITE: u32 = 512;
pub const APR_FPROT_WEXECUTE: u32 = 1;
pub const APR_FPROT_WREAD: u32 = 4;
pub const APR_FPROT_WSTICKY: u32 = 8192;
pub const APR_FPROT_WWRITE: u32 = 2;
pub const APR_GEXECUTE: u32 = 16;
pub const APR_GREAD: u32 = 64;
pub const APR_GSETID: u32 = 16384;
pub const APR_GWRITE: u32 = 32;
pub const APR_HOOK_FIRST: u32 = 0;
pub const APR_HOOK_LAST: u32 = 20;
pub const APR_HOOK_MIDDLE: u32 = 10;
pub const APR_HOOK_REALLY_FIRST: i32 = -10;
pub const APR_HOOK_REALLY_LAST: u32 = 30;
pub const APR_INCHILD: u32 = 70001;
pub const APR_INCOMPLETE: u32 = 70008;
pub const APR_INCOMPLETE_READ: u32 = 4096;
pub const APR_INCOMPLETE_WRITE: u32 = 8192;
pub const APR_INET6: u32 = 10;
pub const APR_INET: u32 = 2;
pub const APR_INPARENT: u32 = 70002;
pub const APR_INT16_MAX: u32 = 32767;
pub const APR_INT16_MIN: i32 = -32768;
pub const APR_INT32_MAX: u32 = 2147483647;
pub const APR_INT32_MIN: i32 = -2147483648;
pub const APR_INT64_T_FMT: &'static [u8; 3usize] = b"ld\0";
pub const APR_IPV4_ADDR_OK: u32 = 1;
pub const APR_IPV6_ADDR_OK: u32 = 2;
pub const APR_IPV6_V6ONLY: u32 = 16384;
pub const APR_IS_BIGENDIAN: u32 = 0;
pub const APR_KEYBASED: u32 = 70021;
pub const APR_LARGEFILE: u32 = 16384;
pub const APR_MAX_IOVEC_SIZE: u32 = 1024;
pub const APR_MAX_SECS_TO_LINGER: u32 = 30;
pub const APR_MMAP_LIMIT: u32 = 4194304;
pub const APR_MMAP_READ: u32 = 1;
pub const APR_MMAP_THRESHOLD: u32 = 1;
pub const APR_MMAP_WRITE: u32 = 2;
pub const APR_NOTDETACH: u32 = 70004;
pub const APR_NOTFOUND: u32 = 70015;
pub const APR_OFF_T_FMT: &'static [u8; 3usize] = b"ld\0";
pub const APR_OS_DEFAULT: u32 = 4095;
pub const APR_OS_ERRSPACE_SIZE: u32 = 50000;
pub const APR_OS_START_CANONERR: u32 = 620000;
pub const APR_OS_START_EAIERR: u32 = 670000;
pub const APR_OS_START_ERROR: u32 = 20000;
pub const APR_OS_START_STATUS: u32 = 70000;
pub const APR_OS_START_SYSERR: u32 = 720000;
pub const APR_OS_START_USEERR: u32 = 120000;
pub const APR_OS_START_USERERR: u32 = 120000;
pub const APR_OVERLAP_TABLES_MERGE: u32 = 1;
pub const APR_OVERLAP_TABLES_SET: u32 = 0;
pub const APR_O_NONBLOCK_INHERITED: u32 = 0;
pub const APR_PATH_MAX: u32 = 4096;
pub const APR_PID_T_FMT: &'static [u8; 2usize] = b"d\0";
pub const APR_POLLERR: u32 = 16;
pub const APR_POLLHUP: u32 = 32;
pub const APR_POLLIN: u32 = 1;
pub const APR_POLLNVAL: u32 = 64;
pub const APR_POLLOUT: u32 = 4;
pub const APR_POLLPRI: u32 = 2;
pub const APR_POLLSET_NOCOPY: u32 = 2;
pub const APR_POLLSET_NODEFAULT: u32 = 16;
pub const APR_POLLSET_THREADSAFE: u32 = 1;
pub const APR_POLLSET_WAKEABLE: u32 = 4;
pub const APR_POOL_DEBUG: u32 = 0;
pub const APR_PROCATTR_USER_SET_REQUIRES_PASSWORD: u32 = 0;
pub const APR_PROCESS_LOCK_IS_GLOBAL: u32 = 0;
pub const APR_PROC_MUTEX_IS_GLOBAL: u32 = 0;
pub const APR_PROTO_SCTP: u32 = 132;
pub const APR_PROTO_TCP: u32 = 6;
pub const APR_PROTO_UDP: u32 = 17;
pub const APR_READ: u32 = 1;
pub const APR_RESET_NODELAY: u32 = 2048;
pub const APR_RFC822_DATE_LEN: u32 = 30;
pub const APR_SENDFILE_DISCONNECT_SOCKET: u32 = 1;
pub const APR_SENDFILE_ENABLED: u32 = 4096;
pub const APR_SET: u32 = 0;
pub const APR_SHARELOCK: u32 = 1024;
pub const APR_SIZEOF_VOIDP: u32 = 8;
pub const APR_SIZE_T_FMT: &'static [u8; 3usize] = b"lu\0";
pub const APR_SO_BROADCAST: u32 = 65536;
pub const APR_SO_DEBUG: u32 = 4;
pub const APR_SO_DISCONNECTED: u32 = 256;
pub const APR_SO_KEEPALIVE: u32 = 2;
pub const APR_SO_LINGER: u32 = 1;
pub const APR_SO_NONBLOCK: u32 = 8;
pub const APR_SO_RCVBUF: u32 = 128;
pub const APR_SO_REUSEADDR: u32 = 16;
pub const APR_SO_SNDBUF: u32 = 64;
pub const APR_SSIZE_T_FMT: &'static [u8; 3usize] = b"ld\0";
pub const APR_SUCCESS: ::libc::c_int = 0;
pub const APR_TCP_DEFER_ACCEPT: u32 = 32768;
pub const APR_TCP_NODELAY: u32 = 512;
pub const APR_TCP_NODELAY_INHERITED: u32 = 1;
pub const APR_TCP_NOPUSH: u32 = 1024;
pub const APR_THREAD_MUTEX_DEFAULT: u32 = 0;
pub const APR_THREAD_MUTEX_NESTED: u32 = 1;
pub const APR_THREAD_MUTEX_UNNESTED: u32 = 2;
pub const APR_TIMEUP: u32 = 70007;
pub const APR_TIME_T_FMT: &'static [u8; 3usize] = b"ld\0";
pub const APR_TRUNCATE: u32 = 16;
pub const APR_UEXECUTE: u32 = 256;
pub const APR_UINT16_MAX: u32 = 65535;
pub const APR_UINT32_MAX: u32 = 4294967295;
pub const APR_UINT64_T_FMT: &'static [u8; 3usize] = b"lu\0";
pub const APR_UINT64_T_HEX_FMT: &'static [u8; 3usize] = b"lx\0";
pub const APR_UNSPEC: u32 = 0;
pub const APR_UREAD: u32 = 1024;
pub const APR_URI_ACAP_DEFAULT_PORT: u32 = 674;
pub const APR_URI_FTP_DEFAULT_PORT: u32 = 21;
pub const APR_URI_GOPHER_DEFAULT_PORT: u32 = 70;
pub const APR_URI_HTTPS_DEFAULT_PORT: u32 = 443;
pub const APR_URI_HTTP_DEFAULT_PORT: u32 = 80;
pub const APR_URI_IMAP_DEFAULT_PORT: u32 = 143;
pub const APR_URI_LDAP_DEFAULT_PORT: u32 = 389;
pub const APR_URI_NFS_DEFAULT_PORT: u32 = 2049;
pub const APR_URI_NNTP_DEFAULT_PORT: u32 = 119;
pub const APR_URI_POP_DEFAULT_PORT: u32 = 110;
pub const APR_URI_PROSPERO_DEFAULT_PORT: u32 = 191;
pub const APR_URI_RTSP_DEFAULT_PORT: u32 = 554;
pub const APR_URI_SIP_DEFAULT_PORT: u32 = 5060;
pub const APR_URI_SNEWS_DEFAULT_PORT: u32 = 563;
pub const APR_URI_SSH_DEFAULT_PORT: u32 = 22;
pub const APR_URI_TELNET_DEFAULT_PORT: u32 = 23;
pub const APR_URI_TIP_DEFAULT_PORT: u32 = 3372;
pub const APR_URI_UNP_OMITPASSWORD: u32 = 4;
pub const APR_URI_UNP_OMITPATHINFO: u32 = 16;
pub const APR_URI_UNP_OMITQUERY: u32 = 32;
pub const APR_URI_UNP_OMITSITEPART: u32 = 1;
pub const APR_URI_UNP_OMITUSER: u32 = 2;
pub const APR_URI_UNP_OMITUSERINFO: u32 = 6;
pub const APR_URI_UNP_REVEALPASSWORD: u32 = 8;
pub const APR_URI_WAIS_DEFAULT_PORT: u32 = 210;
pub const APR_USETID: u32 = 32768;
pub const APR_USE_SYSVSEM_SERIALIZE: u32 = 1;
pub const APR_UTIL_ERRSPACE_SIZE: u32 = 20000;
pub const APR_UTIL_START_STATUS: u32 = 100000;
pub const APR_UWRITE: u32 = 512;
pub const APR_WEXECUTE: u32 = 1;
pub const APR_WREAD: u32 = 4;
pub const APR_WRITE: u32 = 2;
pub const APR_WSTICKY: u32 = 8192;
pub const APR_WWRITE: u32 = 2;
pub const APR_XTHREAD: u32 = 512;
pub const AP_DEFAULT_INDEX: &'static [u8; 11usize] = b"index.html\0";
pub const AP_ENABLE_V4_MAPPED: u32 = 1;
pub const AP_IOBUFSIZE: u32 = 8192;
pub const AP_MAX_REG_MATCH: u32 = 10;
pub const AP_MAX_SENDFILE: u32 = 16777216;
pub const AP_NEED_SET_MUTEX_PERMS: u32 = 1;
pub const AP_NONBLOCK_WHEN_MULTI_LISTEN: u32 = 1;
pub const AP_REG_EXTENDED: u32 = 0;
pub const AP_REG_ICASE: u32 = 1;
pub const AP_REG_NEWLINE: u32 = 2;
pub const AP_REG_NOSUB: u32 = 0;
pub const AP_REG_NOTBOL: u32 = 4;
pub const AP_REG_NOTEOL: u32 = 8;
pub const AP_REQ_ACCEPT_PATH_INFO: u32 = 0;
pub const AP_REQ_DEFAULT_PATH_INFO: u32 = 2;
pub const AP_REQ_REJECT_PATH_INFO: u32 = 1;
pub const AP_SERVER_PROTOCOL: &'static [u8; 9usize] = b"HTTP/1.1\0";
pub const AP_TYPES_CONFIG_FILE: &'static [u8; 16usize] = b"conf/mime.types\0";
pub const AP_USING_AUTOCONF: u32 = 1;
pub const AP_FILTER_ERROR: i32 = -3;
pub const CR: u32 = 13;
pub const CRLF: &'static [u8; 3usize] = b"\r\n\0";
pub const CRLF_ASCII: &'static [u8; 3usize] = b"\r\n\0";
pub const DECLINED: i32 = -1;
pub const HOST_NAME_MAX: u32 = 64;
pub const HTTP_ACCEPTED: u32 = 202;
pub const HTTP_BAD_GATEWAY: u32 = 502;
pub const HTTP_BAD_REQUEST: u32 = 400;
pub const HTTP_CONFLICT: u32 = 409;
pub const HTTP_CONTINUE: u32 = 100;
pub const HTTP_CREATED: u32 = 201;
pub const HTTP_EXPECTATION_FAILED: u32 = 417;
pub const HTTP_FAILED_DEPENDENCY: u32 = 424;
pub const HTTP_FORBIDDEN: u32 = 403;
pub const HTTP_GATEWAY_TIME_OUT: u32 = 504;
pub const HTTP_GONE: u32 = 410;
pub const HTTP_INSUFFICIENT_STORAGE: u32 = 507;
pub const HTTP_INTERNAL_SERVER_ERROR: u32 = 500;
pub const HTTP_LENGTH_REQUIRED: u32 = 411;
pub const HTTP_LOCKED: u32 = 423;
pub const HTTP_METHOD_NOT_ALLOWED: u32 = 405;
pub const HTTP_MOVED_PERMANENTLY: u32 = 301;
pub const HTTP_MOVED_TEMPORARILY: u32 = 302;
pub const HTTP_MULTIPLE_CHOICES: u32 = 300;
pub const HTTP_MULTI_STATUS: u32 = 207;
pub const HTTP_NON_AUTHORITATIVE: u32 = 203;
pub const HTTP_NOT_ACCEPTABLE: u32 = 406;
pub const HTTP_NOT_EXTENDED: u32 = 510;
pub const HTTP_NOT_FOUND: u32 = 404;
pub const HTTP_NOT_IMPLEMENTED: u32 = 501;
pub const HTTP_NOT_MODIFIED: u32 = 304;
pub const HTTP_NO_CONTENT: u32 = 204;
pub const HTTP_OK: u32 = 200;
pub const HTTP_PARTIAL_CONTENT: u32 = 206;
pub const HTTP_PAYMENT_REQUIRED: u32 = 402;
pub const HTTP_PRECONDITION_FAILED: u32 = 412;
pub const HTTP_PROCESSING: u32 = 102;
pub const HTTP_PROXY_AUTHENTICATION_REQUIRED: u32 = 407;
pub const HTTP_RANGE_NOT_SATISFIABLE: u32 = 416;
pub const HTTP_REQUEST_ENTITY_TOO_LARGE: u32 = 413;
pub const HTTP_REQUEST_TIME_OUT: u32 = 408;
pub const HTTP_REQUEST_URI_TOO_LARGE: u32 = 414;
pub const HTTP_RESET_CONTENT: u32 = 205;
pub const HTTP_SEE_OTHER: u32 = 303;
pub const HTTP_SERVICE_UNAVAILABLE: u32 = 503;
pub const HTTP_SWITCHING_PROTOCOLS: u32 = 101;
pub const HTTP_TEMPORARY_REDIRECT: u32 = 307;
pub const HTTP_UNAUTHORIZED: u32 = 401;
pub const HTTP_UNPROCESSABLE_ENTITY: u32 = 422;
pub const HTTP_UNSUPPORTED_MEDIA_TYPE: u32 = 415;
pub const HTTP_UPGRADE_REQUIRED: u32 = 426;
pub const HTTP_USE_PROXY: u32 = 305;
pub const HTTP_VARIANT_ALSO_VARIES: u32 = 506;
pub const HTTP_VERSION_NOT_SUPPORTED: u32 = 505;
pub const HUGE_STRING_LEN: u32 = 8192;
pub const OK: u32 = 0;


pub type apr_byte_t = ::libc::c_uchar;
pub type apr_int16_t = ::libc::c_short;
pub type apr_uint16_t = ::libc::c_ushort;
pub type apr_int32_t = ::libc::c_int;
pub type apr_uint32_t = ::libc::c_uint;
pub type apr_int64_t = ::libc::c_long;
pub type apr_uint64_t = ::libc::c_ulong;
pub type apr_size_t = usize;
pub type apr_ssize_t = isize;
pub type apr_off_t = ::libc::off_t;
pub type apr_socklen_t = ::libc::socklen_t;
pub type apr_ino_t = ::libc::ino_t;
pub type apr_uintptr_t = apr_uint64_t;
/// Type for specifying an error or status code.
pub type apr_status_t = ::libc::c_int;
/// signal numbers typedef
pub type apr_signum_t = ::libc::c_int;


#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_pool_t { _unused: [u8; 0] }

/// A function that is called when allocation fails.
pub type apr_abortfunc_t = ::std::option::Option<unsafe extern "C" fn(retcode: ::libc::c_int) -> ::libc::c_int>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_allocator_t { _unused: [u8; 0] }

/// basic memory node structure
/// @note The next, ref and first_avail fields are available for use by the
/// caller of apr_allocator_alloc(), the remaining fields are read-only.
/// The next field has to be used with caution and sensibly set when the
/// memnode is passed back to apr_allocator_free().  See apr_allocator_free()
/// for details.
/// The ref and first_avail fields will be properly restored by
/// apr_allocator_free().
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_memnode_t {
    /// < next memnode
    pub next: *mut apr_memnode_t,
    /// < reference to self
    pub ref_: *mut *mut apr_memnode_t,
    /// < size
    pub index: apr_uint32_t,
    /// < how much free
    pub free_index: apr_uint32_t,
    /// < pointer to first free memory
    pub first_avail: *mut ::libc::c_char,
    /// < pointer to end of free memory
    pub endp: *mut ::libc::c_char,
}

#[test]
fn bindgen_test_layout_apr_memnode_t() {
    assert_eq!(::std::mem::size_of::<apr_memnode_t>(), 40usize, concat!( "Size of: " , stringify ! ( apr_memnode_t ) ));
    assert_eq!(::std::mem::align_of::<apr_memnode_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_memnode_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_memnode_t>())).next as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_memnode_t ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_memnode_t>())).ref_ as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_memnode_t ) , "::" , stringify ! ( ref_ ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_memnode_t>())).index as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_memnode_t ) , "::" , stringify ! ( index ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_memnode_t>())).free_index as *const _ as usize }, 20usize, concat!( "Offset of field: " , stringify ! ( apr_memnode_t ) , "::" , stringify ! ( free_index ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_memnode_t>())).first_avail as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_memnode_t ) , "::" , stringify ! ( first_avail ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_memnode_t>())).endp as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( apr_memnode_t ) , "::" , stringify ! ( endp ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_thread_mutex_t { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_table_t { _unused: [u8; 0] }

/// An opaque array type
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_array_header_t {
    /// The pool the array is allocated out of
    pub pool: *mut apr_pool_t,
    /// The amount of memory allocated for each element of the array
    pub elt_size: ::libc::c_int,
    /// The number of active elements in the array
    pub nelts: ::libc::c_int,
    /// The number of elements allocated in the array
    pub nalloc: ::libc::c_int,
    /// The elements in the array
    pub elts: *mut ::libc::c_char,
}

#[test]
fn bindgen_test_layout_apr_array_header_t() {
    assert_eq!(::std::mem::size_of::<apr_array_header_t>(), 32usize, concat!( "Size of: " , stringify ! ( apr_array_header_t ) ));
    assert_eq!(::std::mem::align_of::<apr_array_header_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_array_header_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_array_header_t>())).pool as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_array_header_t ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_array_header_t>())).elt_size as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_array_header_t ) , "::" , stringify ! ( elt_size ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_array_header_t>())).nelts as *const _ as usize }, 12usize, concat!( "Offset of field: " , stringify ! ( apr_array_header_t ) , "::" , stringify ! ( nelts ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_array_header_t>())).nalloc as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_array_header_t ) , "::" , stringify ! ( nalloc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_array_header_t>())).elts as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_array_header_t ) , "::" , stringify ! ( elts ) ));
}

/// The type for each entry in a string-content table
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_table_entry_t {
    /// The key for the current table entry
    pub key: *mut ::libc::c_char,
    /// The value for the current table entry
    pub val: *mut ::libc::c_char,
    /// A checksum for the key, for use by the apr_table internals
    pub key_checksum: apr_uint32_t,
}

#[test]
fn bindgen_test_layout_apr_table_entry_t() {
    assert_eq!(::std::mem::size_of::<apr_table_entry_t>(), 24usize, concat!( "Size of: " , stringify ! ( apr_table_entry_t ) ));
    assert_eq!(::std::mem::align_of::<apr_table_entry_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_table_entry_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_table_entry_t>())).key as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_table_entry_t ) , "::" , stringify ! ( key ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_table_entry_t>())).val as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_table_entry_t ) , "::" , stringify ! ( val ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_table_entry_t>())).key_checksum as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_table_entry_t ) , "::" , stringify ! ( key_checksum ) ));
}

/// Declaration prototype for the iterator callback function of apr_table_do()
/// and apr_table_vdo().
/// @param rec The data passed as the first argument to apr_table_[v]do()
/// @param key The key from this iteration of the table
/// @param value The value from this iteration of the table
/// @remark Iteration continues while this callback function returns non-zero.
/// To export the callback function for apr_table_[v]do() it must be declared
/// in the _NONSTD convention.
pub type apr_table_do_callback_fn_t = ::std::option::Option<unsafe extern "C" fn(rec: *mut ::libc::c_void, key: *const ::libc::c_char, value: *const ::libc::c_char) -> ::libc::c_int>;

extern "C" {
    #[link_name = "\u{1}apr_hook_global_pool"]
    pub static mut apr_hook_global_pool: *mut apr_pool_t;
}

extern "C" {
    #[link_name = "\u{1}apr_hook_debug_enabled"]
    pub static mut apr_hook_debug_enabled: ::libc::c_int;
}

extern "C" {
    #[link_name = "\u{1}apr_hook_debug_current"]
    pub static mut apr_hook_debug_current: *const ::libc::c_char;
}

extern "C" {
    #[link_name = "\u{1}apr_month_snames"]
    pub static mut apr_month_snames: [[::libc::c_char; 4usize]; 12usize];
}

extern "C" {
    #[link_name = "\u{1}apr_day_snames"]
    pub static mut apr_day_snames: [[::libc::c_char; 4usize]; 7usize];
}

/// number of microseconds since 00:00:00 january 1, 1970 UTC
pub type apr_time_t = apr_int64_t;
/// intervals for I/O timeouts, in microseconds
pub type apr_interval_time_t = apr_int64_t;
/// short interval for I/O timeouts, in microseconds
pub type apr_short_interval_time_t = apr_int32_t;

/// a structure similar to ANSI struct tm with the following differences:
/// - tm_usec isn't an ANSI field
/// - tm_gmtoff isn't an ANSI field (it's a bsdism)
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_time_exp_t {
    /// microseconds past tm_sec
    pub tm_usec: apr_int32_t,
    /// (0-61) seconds past tm_min
    pub tm_sec: apr_int32_t,
    /// (0-59) minutes past tm_hour
    pub tm_min: apr_int32_t,
    /// (0-23) hours past midnight
    pub tm_hour: apr_int32_t,
    /// (1-31) day of the month
    pub tm_mday: apr_int32_t,
    /// (0-11) month of the year
    pub tm_mon: apr_int32_t,
    /// year since 1900
    pub tm_year: apr_int32_t,
    /// (0-6) days since sunday
    pub tm_wday: apr_int32_t,
    /// (0-365) days since jan 1
    pub tm_yday: apr_int32_t,
    /// daylight saving time
    pub tm_isdst: apr_int32_t,
    /// seconds east of UTC
    pub tm_gmtoff: apr_int32_t,
}

#[test]
fn bindgen_test_layout_apr_time_exp_t() {
    assert_eq!(::std::mem::size_of::<apr_time_exp_t>(), 44usize, concat!( "Size of: " , stringify ! ( apr_time_exp_t ) ));
    assert_eq!(::std::mem::align_of::<apr_time_exp_t>(), 4usize, concat!( "Alignment of " , stringify ! ( apr_time_exp_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_usec as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_usec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_sec as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_sec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_min as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_min ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_hour as *const _ as usize }, 12usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_hour ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_mday as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_mday ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_mon as *const _ as usize }, 20usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_mon ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_year as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_year ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_wday as *const _ as usize }, 28usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_wday ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_yday as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_yday ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_isdst as *const _ as usize }, 36usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_isdst ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_time_exp_t>())).tm_gmtoff as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( apr_time_exp_t ) , "::" , stringify ! ( tm_gmtoff ) ));
}

pub type apr_uid_t = ::libc::uid_t;
pub type apr_gid_t = ::libc::gid_t;

/// < no file type determined
pub const apr_filetype_e_APR_NOFILE: apr_filetype_e = 0;
/// < a regular file
pub const apr_filetype_e_APR_REG: apr_filetype_e = 1;
/// < a directory
pub const apr_filetype_e_APR_DIR: apr_filetype_e = 2;
/// < a character device
pub const apr_filetype_e_APR_CHR: apr_filetype_e = 3;
/// < a block device
pub const apr_filetype_e_APR_BLK: apr_filetype_e = 4;
/// < a FIFO / pipe
pub const apr_filetype_e_APR_PIPE: apr_filetype_e = 5;
/// < a symbolic link
pub const apr_filetype_e_APR_LNK: apr_filetype_e = 6;
/// < a [unix domain] socket
pub const apr_filetype_e_APR_SOCK: apr_filetype_e = 7;
/// < a file of some other unknown type
pub const apr_filetype_e_APR_UNKFILE: apr_filetype_e = 127;

/// apr_filetype_e values for the filetype member of the
/// apr_file_info_t structure
/// @warning: Not all of the filetypes below can be determined.
/// For example, a given platform might not correctly report
/// a socket descriptor as APR_SOCK if that type isn't
/// well-identified on that platform.  In such cases where
/// a filetype exists but cannot be described by the recognized
/// flags below, the filetype will be APR_UNKFILE.  If the
/// filetype member is not determined, the type will be APR_NOFILE.
pub type apr_filetype_e = u32;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_dir_t { _unused: [u8; 0] }

/// Structure for determining file permissions.
pub type apr_fileperms_t = apr_int32_t;
/// Structure for determining the device the file is on.
pub type apr_dev_t = ::libc::dev_t;

/// The file information structure.  This is analogous to the POSIX
/// stat structure.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_finfo_t {
    /// Allocates memory and closes lingering handles in the specified pool
    pub pool: *mut apr_pool_t,
    /// The bitmask describing valid fields of this apr_finfo_t structure
    /// including all available 'wanted' fields and potentially more
    pub valid: apr_int32_t,
    /// The access permissions of the file.  Mimics Unix access rights.
    pub protection: apr_fileperms_t,
    /// The type of file.  One of APR_REG, APR_DIR, APR_CHR, APR_BLK, APR_PIPE,
    /// APR_LNK or APR_SOCK.  If the type is undetermined, the value is APR_NOFILE.
    /// If the type cannot be determined, the value is APR_UNKFILE.
    pub filetype: apr_filetype_e,
    /// The user id that owns the file
    pub user: apr_uid_t,
    /// The group id that owns the file
    pub group: apr_gid_t,
    /// The inode of the file.
    pub inode: apr_ino_t,
    /// The id of the device the file is on.
    pub device: apr_dev_t,
    /// The number of hard links to the file.
    pub nlink: apr_int32_t,
    /// The size of the file
    pub size: apr_off_t,
    /// The storage size consumed by the file
    pub csize: apr_off_t,
    /// The time the file was last accessed
    pub atime: apr_time_t,
    /// The time the file was last modified
    pub mtime: apr_time_t,
    /// The time the file was created, or the inode was last changed
    pub ctime: apr_time_t,
    /// The pathname of the file (possibly unrooted)
    pub fname: *const ::libc::c_char,
    /// The file's name (no path) in filesystem case
    pub name: *const ::libc::c_char,
    /// The file's handle, if accessed (can be submitted to apr_duphandle)
    pub filehand: *mut ffi::apr_file_t,
}

#[test]
fn bindgen_test_layout_apr_finfo_t() {
    assert_eq!(::std::mem::size_of::<apr_finfo_t>(), 120usize, concat!( "Size of: " , stringify ! ( apr_finfo_t ) ));
    assert_eq!(::std::mem::align_of::<apr_finfo_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_finfo_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).pool as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).valid as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( valid ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).protection as *const _ as usize }, 12usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( protection ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).filetype as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( filetype ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).user as *const _ as usize }, 20usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( user ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).group as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( group ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).inode as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( inode ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).device as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( device ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).nlink as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( nlink ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).size as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( size ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).csize as *const _ as usize }, 64usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( csize ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).atime as *const _ as usize }, 72usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( atime ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).mtime as *const _ as usize }, 80usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( mtime ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).ctime as *const _ as usize }, 88usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( ctime ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).fname as *const _ as usize }, 96usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( fname ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).name as *const _ as usize }, 104usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( name ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_finfo_t>())).filehand as *const _ as usize }, 112usize, concat!( "Offset of field: " , stringify ! ( apr_finfo_t ) , "::" , stringify ! ( filehand ) ));
}


/// File attributes
pub type apr_fileattrs_t = apr_uint32_t;
/// Type to pass as whence argument to apr_file_seek.
pub type apr_seek_where_t = ::libc::c_int;

/// < no longer allow read request
pub const apr_shutdown_how_e_APR_SHUTDOWN_READ: apr_shutdown_how_e = 0;
/// < no longer allow write requests
pub const apr_shutdown_how_e_APR_SHUTDOWN_WRITE: apr_shutdown_how_e = 1;
/// < no longer allow read or write requests
pub const apr_shutdown_how_e_APR_SHUTDOWN_READWRITE: apr_shutdown_how_e = 2;

/// Define what type of socket shutdown should occur.
pub type apr_shutdown_how_e = u32;

/// < Socket information for local end of connection
pub const apr_interface_e_APR_LOCAL: apr_interface_e = 0;
/// < Socket information for remote end of connection
pub const apr_interface_e_APR_REMOTE: apr_interface_e = 1;

/// Enum used to denote either the local and remote endpoint of a
/// connection.
pub type apr_interface_e = u32;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_socket_t { _unused: [u8; 0] }

/// A structure to represent in_addr
pub type apr_in_addr_t = ::libc::in_addr;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_ipsubnet_t { _unused: [u8; 0] }

/// @remark use apr_uint16_t just in case some system has a short that isn't 16 bits...
pub type apr_port_t = apr_uint16_t;

/// APRs socket address type, used to ensure protocol independence
#[repr(C)]
#[derive(Copy, Clone)]
pub struct apr_sockaddr_t {
    /// The pool to use...
    pub pool: *mut apr_pool_t,
    /// The hostname
    pub hostname: *mut ::libc::c_char,
    /// Either a string of the port number or the service name for the port
    pub servname: *mut ::libc::c_char,
    /// The numeric port
    pub port: apr_port_t,
    /// The family
    pub family: apr_int32_t,
    /// How big is the sockaddr we're using?
    pub salen: apr_socklen_t,
    /// How big is the ip address structure we're using?
    pub ipaddr_len: ::libc::c_int,
    /// How big should the address buffer be?  16 for v4 or 46 for v6
    /// used in inet_ntop...
    pub addr_str_len: ::libc::c_int,
    /// This points to the IP address structure within the appropriate
    /// sockaddr structure.
    pub ipaddr_ptr: *mut ::libc::c_void,
    /// If multiple addresses were found by apr_sockaddr_info_get(), this
    /// points to a representation of the next address.
    pub next: *mut apr_sockaddr_t,
    pub sa: apr_sockaddr_sa_t,
}

/// Union of either IPv4 or IPv6 sockaddr.
#[repr(C)]
#[derive(Copy, Clone)]
pub union apr_sockaddr_sa_t {
    /// IPv4 sockaddr structure
    pub sin: ::libc::sockaddr_in,
    /// IPv6 sockaddr structure
    pub sin6: ::libc::sockaddr_in6,
    /// Placeholder to ensure that the size of this union is not
    /// dependent on whether APR_HAVE_IPV6 is defined.
    pub sas: ::libc::sockaddr_storage,
    _bindgen_union_align: [u64; 16usize],
}

#[test]
fn bindgen_test_layout_apr_sockaddr_sa_t() {
    assert_eq!(::std::mem::size_of::<apr_sockaddr_sa_t>(), 128usize, concat!( "Size of: " , stringify ! ( apr_sockaddr_t__bindgen_ty_1 ) ));
    assert_eq!(::std::mem::align_of::<apr_sockaddr_sa_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_sockaddr_t__bindgen_ty_1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_sa_t>())).sin as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t__bindgen_ty_1 ) , "::" , stringify ! ( sin ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_sa_t>())).sin6 as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t__bindgen_ty_1 ) , "::" , stringify ! ( sin6 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_sa_t>())).sas as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t__bindgen_ty_1 ) , "::" , stringify ! ( sas ) ));
}

#[test]
fn bindgen_test_layout_apr_sockaddr_t() {
    assert_eq!(::std::mem::size_of::<apr_sockaddr_t>(), 192usize, concat!( "Size of: " , stringify ! ( apr_sockaddr_t ) ));
    assert_eq!(::std::mem::align_of::<apr_sockaddr_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_sockaddr_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).pool as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).hostname as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( hostname ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).servname as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( servname ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).port as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( port ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).family as *const _ as usize }, 28usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( family ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).salen as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( salen ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).ipaddr_len as *const _ as usize }, 36usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( ipaddr_len ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).addr_str_len as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( addr_str_len ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).ipaddr_ptr as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( ipaddr_ptr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).next as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_sockaddr_t>())).sa as *const _ as usize }, 64usize, concat!( "Offset of field: " , stringify ! ( apr_sockaddr_t ) , "::" , stringify ! ( sa ) ));
}

/// A structure to encapsulate headers and trailers for apr_socket_sendfile
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_hdtr_t {
    /// An iovec to store the headers sent before the file.
    pub headers: *mut ::libc::iovec,
    /// number of headers in the iovec
    pub numheaders: ::libc::c_int,
    /// An iovec to store the trailers sent after the file.
    pub trailers: *mut ::libc::iovec,
    /// number of trailers in the iovec
    pub numtrailers: ::libc::c_int,
}

#[test]
fn bindgen_test_layout_apr_hdtr_t() {
    assert_eq!(::std::mem::size_of::<apr_hdtr_t>(), 32usize, concat!( "Size of: " , stringify ! ( apr_hdtr_t ) ));
    assert_eq!(::std::mem::align_of::<apr_hdtr_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_hdtr_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_hdtr_t>())).headers as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_hdtr_t ) , "::" , stringify ! ( headers ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_hdtr_t>())).numheaders as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_hdtr_t ) , "::" , stringify ! ( numheaders ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_hdtr_t>())).trailers as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_hdtr_t ) , "::" , stringify ! ( trailers ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_hdtr_t>())).numtrailers as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_hdtr_t ) , "::" , stringify ! ( numtrailers ) ));
}

/// @remark
/// As far as I can tell the only really sane way to store an MMAP is as a
/// void * and a length.  BeOS requires this area_id, but that's just a little
/// something extra.  I am exposing this type, because it doesn't make much
/// sense to keep it private, and opening it up makes some stuff easier in
/// Apache.
/// /
/// /** The MMAP structure
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_mmap_t {
    /// The pool the mmap structure was allocated out of.
    pub cntxt: *mut apr_pool_t,
    /// The start of the memory mapped area
    pub mm: *mut ::libc::c_void,
    /// The amount of data in the mmap
    pub size: apr_size_t,
    /// ring of apr_mmap_t's that reference the same
    /// mmap'ed region; acts in place of a reference count
    pub link: apr_mmap_t__bindgen_ty_1,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_mmap_t__bindgen_ty_1 { pub next: *mut apr_mmap_t, pub prev: *mut apr_mmap_t }

#[test]
fn bindgen_test_layout_apr_mmap_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<apr_mmap_t__bindgen_ty_1>(), 16usize, concat!( "Size of: " , stringify ! ( apr_mmap_t__bindgen_ty_1 ) ));
    assert_eq!(::std::mem::align_of::<apr_mmap_t__bindgen_ty_1>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_mmap_t__bindgen_ty_1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_mmap_t__bindgen_ty_1>())).next as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_mmap_t__bindgen_ty_1 ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_mmap_t__bindgen_ty_1>())).prev as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_mmap_t__bindgen_ty_1 ) , "::" , stringify ! ( prev ) ));
}

#[test]
fn bindgen_test_layout_apr_mmap_t() {
    assert_eq!(::std::mem::size_of::<apr_mmap_t>(), 40usize, concat!( "Size of: " , stringify ! ( apr_mmap_t ) ));
    assert_eq!(::std::mem::align_of::<apr_mmap_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_mmap_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_mmap_t>())).cntxt as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_mmap_t ) , "::" , stringify ! ( cntxt ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_mmap_t>())).mm as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_mmap_t ) , "::" , stringify ! ( mm ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_mmap_t>())).size as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_mmap_t ) , "::" , stringify ! ( size ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_mmap_t>())).link as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_mmap_t ) , "::" , stringify ! ( link ) ));
}

/// < block until data becomes available
pub const apr_read_type_e_APR_BLOCK_READ: apr_read_type_e = 0;
/// < return immediately if no data is available
pub const apr_read_type_e_APR_NONBLOCK_READ: apr_read_type_e = 1;

/// Determines how a bucket or brigade should be read
pub type apr_read_type_e = u32;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_alloc_t { _unused: [u8; 0] }

/// Basic bucket type
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_type_t {
    /// The name of the bucket type
    pub name: *const ::libc::c_char,
    /// The number of functions this bucket understands.  Can not be less than
    /// five.
    pub num_func: ::libc::c_int,
    pub is_metadata: apr_bucket_type_t__bindgen_ty_1,
    /// Free the private data and any resources used by the bucket (if they
    /// aren't shared with another bucket).  This function is required to be
    /// implemented for all bucket types, though it might be a no-op on some
    /// of them (namely ones that never allocate any private data structures).
    /// @param data The private data pointer from the bucket to be destroyed
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::libc::c_void)>,
    /// Read the data from the bucket. This is required to be implemented
    /// for all bucket types.
    /// @param b The bucket to read from
    /// @param str A place to store the data read.  Allocation should only be
    /// done if absolutely necessary.
    /// @param len The amount of data read.
    /// @param block Should this read function block if there is more data that
    /// cannot be read immediately.
    pub read: ::std::option::Option<unsafe extern "C" fn(b: *mut apr_bucket, str: *mut *const ::libc::c_char, len: *mut apr_size_t, block: apr_read_type_e) -> apr_status_t>,
    /// Make it possible to set aside the data for at least as long as the
    /// given pool. Buckets containing data that could potentially die before
    /// this pool (e.g. the data resides on the stack, in a child pool of
    /// the given pool, or in a disjoint pool) must somehow copy, shift, or
    /// transform the data to have the proper lifetime.
    /// @param e The bucket to convert
    /// @remark Some bucket types contain data that will always outlive the
    /// bucket itself. For example no data (EOS and FLUSH), or the data
    /// resides in global, constant memory (IMMORTAL), or the data is on
    /// the heap (HEAP). For these buckets, apr_bucket_setaside_noop can
    /// be used.
    pub setaside: ::std::option::Option<unsafe extern "C" fn(e: *mut apr_bucket, pool: *mut apr_pool_t) -> apr_status_t>,
    /// Split one bucket in two at the specified position by duplicating
    /// the bucket structure (not the data) and modifying any necessary
    /// start/end/offset information.  If it's not possible to do this
    /// for the bucket type (perhaps the length of the data is indeterminate,
    /// as with pipe and socket buckets), then APR_ENOTIMPL is returned.
    /// @param e The bucket to split
    /// @param point The offset of the first byte in the new bucket
    pub split: ::std::option::Option<unsafe extern "C" fn(e: *mut apr_bucket, point: apr_size_t) -> apr_status_t>,
    /// Copy the bucket structure (not the data), assuming that this is
    /// possible for the bucket type. If it's not, APR_ENOTIMPL is returned.
    /// @param e The bucket to copy
    /// @param c Returns a pointer to the new bucket
    pub copy: ::std::option::Option<unsafe extern "C" fn(e: *mut apr_bucket, c: *mut *mut apr_bucket) -> apr_status_t>,
}

/// This bucket type represents actual data to send to the client.
pub const apr_bucket_type_t_APR_BUCKET_DATA: apr_bucket_type_t__bindgen_ty_1 = 0;
/// This bucket type represents metadata.
pub const apr_bucket_type_t_APR_BUCKET_METADATA: apr_bucket_type_t__bindgen_ty_1 = 1;

/// Whether the bucket contains metadata (ie, information that
/// describes the regular contents of the brigade).  The metadata
/// is not returned by apr_bucket_read() and is not indicated by
/// the ->length of the apr_bucket itself.  In other words, an
/// empty bucket is safe to arbitrarily remove if and only if it
/// contains no metadata.  In this sense, "data" is just raw bytes
/// that are the "content" of the brigade and "metadata" describes
/// that data but is not a proper part of it.
pub type apr_bucket_type_t__bindgen_ty_1 = u32;

#[test]
fn bindgen_test_layout_apr_bucket_type_t() {
    assert_eq!(::std::mem::size_of::<apr_bucket_type_t>(), 56usize, concat!( "Size of: " , stringify ! ( apr_bucket_type_t ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_type_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket_type_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_type_t>())).name as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_type_t ) , "::" , stringify ! ( name ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_type_t>())).num_func as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_type_t ) , "::" , stringify ! ( num_func ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_type_t>())).is_metadata as *const _ as usize }, 12usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_type_t ) , "::" , stringify ! ( is_metadata ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_type_t>())).destroy as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_type_t ) , "::" , stringify ! ( destroy ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_type_t>())).read as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_type_t ) , "::" , stringify ! ( read ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_type_t>())).setaside as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_type_t ) , "::" , stringify ! ( setaside ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_type_t>())).split as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_type_t ) , "::" , stringify ! ( split ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_type_t>())).copy as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_type_t ) , "::" , stringify ! ( copy ) ));
}

/// apr_bucket structures are allocated on the malloc() heap and
/// their lifetime is controlled by the parent apr_bucket_brigade
/// structure. Buckets can move from one brigade to another e.g. by
/// calling APR_BRIGADE_CONCAT(). In general the data in a bucket has
/// the same lifetime as the bucket and is freed when the bucket is
/// destroyed; if the data is shared by more than one bucket (e.g.
/// after a split) the data is freed when the last bucket goes away.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket {
    /// Links to the rest of the brigade
    pub link: apr_bucket__bindgen_ty_1,
    /// The type of bucket.
    pub type_: *const apr_bucket_type_t,
    /// The length of the data in the bucket.  This could have been implemented
    /// with a function, but this is an optimization, because the most
    /// common thing to do will be to get the length.  If the length is unknown,
    /// the value of this field will be (apr_size_t)(-1).
    pub length: apr_size_t,
    /// The start of the data in the bucket relative to the private base
    /// pointer.  The vast majority of bucket types allow a fixed block of
    /// data to be referenced by multiple buckets, each bucket pointing to
    /// a different segment of the data.  That segment starts at base+start
    /// and ends at base+start+length.
    /// If the length == (apr_size_t)(-1), then start == -1.
    pub start: apr_off_t,
    /// type-dependent data hangs off this pointer
    pub data: *mut ::libc::c_void,
    /// Pointer to function used to free the bucket. This function should
    /// always be defined and it should be consistent with the memory
    /// function used to allocate the bucket. For example, if malloc() is
    /// used to allocate the bucket, this pointer should point to free().
    /// @param e Pointer to the bucket being freed
    pub free: ::std::option::Option<unsafe extern "C" fn(e: *mut ::libc::c_void)>,
    /// The freelist from which this bucket was allocated
    pub list: *mut apr_bucket_alloc_t,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket__bindgen_ty_1 { pub next: *mut apr_bucket, pub prev: *mut apr_bucket }

#[test]
fn bindgen_test_layout_apr_bucket__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<apr_bucket__bindgen_ty_1>(), 16usize, concat!( "Size of: " , stringify ! ( apr_bucket__bindgen_ty_1 ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket__bindgen_ty_1>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket__bindgen_ty_1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket__bindgen_ty_1>())).next as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket__bindgen_ty_1 ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket__bindgen_ty_1>())).prev as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_bucket__bindgen_ty_1 ) , "::" , stringify ! ( prev ) ));
}

#[test]
fn bindgen_test_layout_apr_bucket() {
    assert_eq!(::std::mem::size_of::<apr_bucket>(), 64usize, concat!( "Size of: " , stringify ! ( apr_bucket ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket>())).link as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket ) , "::" , stringify ! ( link ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket>())).type_ as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_bucket ) , "::" , stringify ! ( type_ ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket>())).length as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_bucket ) , "::" , stringify ! ( length ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket>())).start as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( apr_bucket ) , "::" , stringify ! ( start ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket>())).data as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( apr_bucket ) , "::" , stringify ! ( data ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket>())).free as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( apr_bucket ) , "::" , stringify ! ( free ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket>())).list as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( apr_bucket ) , "::" , stringify ! ( list ) ));
}

/// A list of buckets
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_brigade {
    /// The pool to associate the brigade with.  The data is not allocated out
    /// of the pool, but a cleanup is registered with this pool.  If the
    /// brigade is destroyed by some mechanism other than pool destruction,
    /// the destroying function is responsible for killing the cleanup.
    pub p: *mut apr_pool_t,
    pub list: apr_bucket_brigade_apr_bucket_list,
    /// The freelist from which this bucket was allocated
    pub bucket_alloc: *mut apr_bucket_alloc_t,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_brigade_apr_bucket_list { pub next: *mut apr_bucket, pub prev: *mut apr_bucket }

#[test]
fn bindgen_test_layout_apr_bucket_brigade_apr_bucket_list() {
    assert_eq!(::std::mem::size_of::<apr_bucket_brigade_apr_bucket_list>(), 16usize, concat!( "Size of: " , stringify ! ( apr_bucket_brigade_apr_bucket_list ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_brigade_apr_bucket_list>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket_brigade_apr_bucket_list ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_brigade_apr_bucket_list>())).next as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_brigade_apr_bucket_list ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_brigade_apr_bucket_list>())).prev as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_brigade_apr_bucket_list ) , "::" , stringify ! ( prev ) ));
}

#[test]
fn bindgen_test_layout_apr_bucket_brigade() {
    assert_eq!(::std::mem::size_of::<apr_bucket_brigade>(), 32usize, concat!( "Size of: " , stringify ! ( apr_bucket_brigade ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_brigade>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket_brigade ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_brigade>())).p as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_brigade ) , "::" , stringify ! ( p ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_brigade>())).list as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_brigade ) , "::" , stringify ! ( list ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_brigade>())).bucket_alloc as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_brigade ) , "::" , stringify ! ( bucket_alloc ) ));
}

/// Function called when a brigade should be flushed
pub type apr_brigade_flush = ::std::option::Option<unsafe extern "C" fn(bb: *mut apr_bucket_brigade, ctx: *mut ::libc::c_void) -> apr_status_t>;

/// The structure used to manage the shared resource must start with an
/// apr_bucket_refcount which is updated by the general-purpose refcount
/// code. A pointer to the bucket-type-dependent private data structure
/// can be cast to a pointer to an apr_bucket_refcount and vice versa.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_refcount {
    /// The number of references to this bucket
    pub refcount: ::libc::c_int,
}

#[test]
fn bindgen_test_layout_apr_bucket_refcount() {
    assert_eq!(::std::mem::size_of::<apr_bucket_refcount>(), 4usize, concat!( "Size of: " , stringify ! ( apr_bucket_refcount ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_refcount>(), 4usize, concat!( "Alignment of " , stringify ! ( apr_bucket_refcount ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_refcount>())).refcount as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_refcount ) , "::" , stringify ! ( refcount ) ));
}

/// A bucket referring to data allocated off the heap.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_heap {
    /// Number of buckets using this memory
    pub refcount: apr_bucket_refcount,
    /// The start of the data actually allocated.  This should never be
    /// modified, it is only used to free the bucket.
    pub base: *mut ::libc::c_char,
    /// how much memory was allocated
    pub alloc_len: apr_size_t,
    /// function to use to delete the data
    pub free_func: ::std::option::Option<unsafe extern "C" fn(data: *mut ::libc::c_void)>,
}

#[test]
fn bindgen_test_layout_apr_bucket_heap() {
    assert_eq!(::std::mem::size_of::<apr_bucket_heap>(), 32usize, concat!( "Size of: " , stringify ! ( apr_bucket_heap ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_heap>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket_heap ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_heap>())).refcount as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_heap ) , "::" , stringify ! ( refcount ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_heap>())).base as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_heap ) , "::" , stringify ! ( base ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_heap>())).alloc_len as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_heap ) , "::" , stringify ! ( alloc_len ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_heap>())).free_func as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_heap ) , "::" , stringify ! ( free_func ) ));
}

/// A bucket referring to data allocated from a pool
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_pool {
    /// The pool bucket must be able to be easily morphed to a heap
    /// bucket if the pool gets cleaned up before all references are
    /// destroyed.  This apr_bucket_heap structure is populated automatically
    /// when the pool gets cleaned up, and subsequent calls to pool_read()
    /// will result in the apr_bucket in question being morphed into a
    /// regular heap bucket.  (To avoid having to do many extra refcount
    /// manipulations and b->data manipulations, the apr_bucket_pool
    /// struct actually *contains* the apr_bucket_heap struct that it
    /// will become as its first element; the two share their
    /// apr_bucket_refcount members.)
    pub heap: apr_bucket_heap,
    /// The block of data actually allocated from the pool.
    /// Segments of this block are referenced by adjusting
    /// the start and length of the apr_bucket accordingly.
    /// This will be NULL after the pool gets cleaned up.
    pub base: *const ::libc::c_char,
    /// The pool the data was allocated from.  When the pool
    /// is cleaned up, this gets set to NULL as an indicator
    /// to pool_read() that the data is now on the heap and
    /// so it should morph the bucket into a regular heap
    /// bucket before continuing.
    pub pool: *mut apr_pool_t,
    /// The freelist this structure was allocated from, which is
    /// needed in the cleanup phase in order to allocate space on the heap
    pub list: *mut apr_bucket_alloc_t,
}

#[test]
fn bindgen_test_layout_apr_bucket_pool() {
    assert_eq!(::std::mem::size_of::<apr_bucket_pool>(), 56usize, concat!( "Size of: " , stringify ! ( apr_bucket_pool ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_pool>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket_pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_pool>())).heap as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_pool ) , "::" , stringify ! ( heap ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_pool>())).base as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_pool ) , "::" , stringify ! ( base ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_pool>())).pool as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_pool ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_pool>())).list as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_pool ) , "::" , stringify ! ( list ) ));
}

/// A bucket referring to an mmap()ed file
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_mmap {
    /// Number of buckets using this memory
    pub refcount: apr_bucket_refcount,
    /// The mmap this sub_bucket refers to
    pub mmap: *mut apr_mmap_t,
}

#[test]
fn bindgen_test_layout_apr_bucket_mmap() {
    assert_eq!(::std::mem::size_of::<apr_bucket_mmap>(), 16usize, concat!( "Size of: " , stringify ! ( apr_bucket_mmap ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_mmap>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket_mmap ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_mmap>())).refcount as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_mmap ) , "::" , stringify ! ( refcount ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_mmap>())).mmap as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_mmap ) , "::" , stringify ! ( mmap ) ));
}

/// A bucket referring to an file
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_bucket_file {
    /// Number of buckets using this memory
    pub refcount: apr_bucket_refcount,
    /// The file this bucket refers to
    pub fd: *mut ffi::apr_file_t,
    /// The pool into which any needed structures should
    /// be created while reading from this file bucket
    pub readpool: *mut apr_pool_t,
    /// Whether this bucket should be memory-mapped if
    /// a caller tries to read from it
    pub can_mmap: ::libc::c_int,
}

#[test]
fn bindgen_test_layout_apr_bucket_file() {
    assert_eq!(::std::mem::size_of::<apr_bucket_file>(), 32usize, concat!( "Size of: " , stringify ! ( apr_bucket_file ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_file>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket_file ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_file>())).refcount as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_file ) , "::" , stringify ! ( refcount ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_file>())).fd as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_file ) , "::" , stringify ! ( fd ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_file>())).readpool as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_file ) , "::" , stringify ! ( readpool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_file>())).can_mmap as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_file ) , "::" , stringify ! ( can_mmap ) ));
}

/// A union of all bucket structures so we know what
/// the max size is.
#[repr(C)]
#[derive(Copy, Clone)]
pub union apr_bucket_structs {
    /// < Bucket
    pub b: apr_bucket,
    /// < Heap
    pub heap: apr_bucket_heap,
    /// < Pool
    pub pool: apr_bucket_pool,
    /// < MMap
    pub mmap: apr_bucket_mmap,
    /// < File
    pub file: apr_bucket_file,
    _bindgen_union_align: [u64; 8usize],
}

#[test]
fn bindgen_test_layout_apr_bucket_structs() {
    assert_eq!(::std::mem::size_of::<apr_bucket_structs>(), 64usize, concat!( "Size of: " , stringify ! ( apr_bucket_structs ) ));
    assert_eq!(::std::mem::align_of::<apr_bucket_structs>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_bucket_structs ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_structs>())).b as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_structs ) , "::" , stringify ! ( b ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_structs>())).heap as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_structs ) , "::" , stringify ! ( heap ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_structs>())).pool as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_structs ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_structs>())).mmap as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_structs ) , "::" , stringify ! ( mmap ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_bucket_structs>())).file as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_bucket_structs ) , "::" , stringify ! ( file ) ));
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_flush"]
    pub static mut apr_bucket_type_flush: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_eos"]
    pub static mut apr_bucket_type_eos: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_file"]
    pub static mut apr_bucket_type_file: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_heap"]
    pub static mut apr_bucket_type_heap: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_mmap"]
    pub static mut apr_bucket_type_mmap: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_pool"]
    pub static mut apr_bucket_type_pool: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_pipe"]
    pub static mut apr_bucket_type_pipe: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_immortal"]
    pub static mut apr_bucket_type_immortal: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_transient"]
    pub static mut apr_bucket_type_transient: apr_bucket_type_t;
}

extern "C" {
    #[link_name = "\u{1}apr_bucket_type_socket"]
    pub static mut apr_bucket_type_socket: apr_bucket_type_t;
}

/// < Platform default poll method
pub const apr_pollset_method_e_APR_POLLSET_DEFAULT: apr_pollset_method_e = 0;
/// < Poll uses select method
pub const apr_pollset_method_e_APR_POLLSET_SELECT: apr_pollset_method_e = 1;
/// < Poll uses kqueue method
pub const apr_pollset_method_e_APR_POLLSET_KQUEUE: apr_pollset_method_e = 2;
/// < Poll uses Solaris event port method
pub const apr_pollset_method_e_APR_POLLSET_PORT: apr_pollset_method_e = 3;
/// < Poll uses epoll method
pub const apr_pollset_method_e_APR_POLLSET_EPOLL: apr_pollset_method_e = 4;
/// < Poll uses poll method
pub const apr_pollset_method_e_APR_POLLSET_POLL: apr_pollset_method_e = 5;
/// < Poll uses z/OS asio method
pub const apr_pollset_method_e_APR_POLLSET_AIO_MSGQ: apr_pollset_method_e = 6;

/// Pollset Methods
pub type apr_pollset_method_e = u32;

/// < nothing here
pub const apr_datatype_e_APR_NO_DESC: apr_datatype_e = 0;
/// < descriptor refers to a socket
pub const apr_datatype_e_APR_POLL_SOCKET: apr_datatype_e = 1;
/// < descriptor refers to a file
pub const apr_datatype_e_APR_POLL_FILE: apr_datatype_e = 2;
/// < @deprecated descriptor is the last one in the list
pub const apr_datatype_e_APR_POLL_LASTDESC: apr_datatype_e = 3;

/// Used in apr_pollfd_t to determine what the apr_descriptor is
pub type apr_datatype_e = u32;

/// Union of either an APR file or socket.
#[repr(C)]
#[derive(Copy, Clone)]
pub union apr_descriptor {
    /// < file
    pub f: *mut ffi::apr_file_t,
    /// < socket
    pub s: *mut apr_socket_t,
    _bindgen_union_align: u64,
}

#[test]
fn bindgen_test_layout_apr_descriptor() {
    assert_eq!(::std::mem::size_of::<apr_descriptor>(), 8usize, concat!( "Size of: " , stringify ! ( apr_descriptor ) ));
    assert_eq!(::std::mem::align_of::<apr_descriptor>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_descriptor ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_descriptor>())).f as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_descriptor ) , "::" , stringify ! ( f ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_descriptor>())).s as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_descriptor ) , "::" , stringify ! ( s ) ));
}

/// Poll descriptor set.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct apr_pollfd_t {
    /// < associated pool
    pub p: *mut apr_pool_t,
    /// < descriptor type
    pub desc_type: apr_datatype_e,
    /// < requested events
    pub reqevents: apr_int16_t,
    /// < returned events
    pub rtnevents: apr_int16_t,
    /// < @see apr_descriptor
    pub desc: apr_descriptor,
    /// < allows app to associate context
    pub client_data: *mut ::libc::c_void,
}

#[test]
fn bindgen_test_layout_apr_pollfd_t() {
    assert_eq!(::std::mem::size_of::<apr_pollfd_t>(), 32usize, concat!( "Size of: " , stringify ! ( apr_pollfd_t ) ));
    assert_eq!(::std::mem::align_of::<apr_pollfd_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_pollfd_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_pollfd_t>())).p as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_pollfd_t ) , "::" , stringify ! ( p ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_pollfd_t>())).desc_type as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_pollfd_t ) , "::" , stringify ! ( desc_type ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_pollfd_t>())).reqevents as *const _ as usize }, 12usize, concat!( "Offset of field: " , stringify ! ( apr_pollfd_t ) , "::" , stringify ! ( reqevents ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_pollfd_t>())).rtnevents as *const _ as usize }, 14usize, concat!( "Offset of field: " , stringify ! ( apr_pollfd_t ) , "::" , stringify ! ( rtnevents ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_pollfd_t>())).desc as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_pollfd_t ) , "::" , stringify ! ( desc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_pollfd_t>())).client_data as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_pollfd_t ) , "::" , stringify ! ( client_data ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_pollset_t { _unused: [u8; 0] }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_pollcb_t { _unused: [u8; 0] }

/// Function prototype for pollcb handlers
/// @param baton Opaque baton passed into apr_pollcb_poll()
/// @param descriptor Contains the notification for an active descriptor,
/// the rtnevents member contains what events were triggered
/// for this descriptor.
pub type apr_pollcb_cb_t = ::std::option::Option<unsafe extern "C" fn(baton: *mut ::libc::c_void, descriptor: *mut apr_pollfd_t) -> apr_status_t>;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_thread_t { _unused: [u8; 0] }

pub const AP_REG_ASSERT: u32 = 1;
/// internal error ?
pub const AP_REG_ESPACE: u32 = 2;
/// failed to get memory
pub const AP_REG_INVARG: u32 = 3;
/// invalid argument
pub const AP_REG_NOMATCH: u32 = 4;


#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_regex_t { pub re_pcre: *mut ::libc::c_void, pub re_nsub: apr_size_t, pub re_erroffset: apr_size_t }

#[test]
fn bindgen_test_layout_ap_regex_t() {
    assert_eq!(::std::mem::size_of::<ap_regex_t>(), 24usize, concat!( "Size of: " , stringify ! ( ap_regex_t ) ));
    assert_eq!(::std::mem::align_of::<ap_regex_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_regex_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_regex_t>())).re_pcre as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_regex_t ) , "::" , stringify ! ( re_pcre ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_regex_t>())).re_nsub as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_regex_t ) , "::" , stringify ! ( re_nsub ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_regex_t>())).re_erroffset as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_regex_t ) , "::" , stringify ! ( re_erroffset ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_regmatch_t { pub rm_so: ::libc::c_int, pub rm_eo: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_regmatch_t() {
    assert_eq!(::std::mem::size_of::<ap_regmatch_t>(), 8usize, concat!( "Size of: " , stringify ! ( ap_regmatch_t ) ));
    assert_eq!(::std::mem::align_of::<ap_regmatch_t>(), 4usize, concat!( "Alignment of " , stringify ! ( ap_regmatch_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_regmatch_t>())).rm_so as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_regmatch_t ) , "::" , stringify ! ( rm_so ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_regmatch_t>())).rm_eo as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( ap_regmatch_t ) , "::" , stringify ! ( rm_eo ) ));
}


/// @brief The numeric version information is broken out into fields within this
/// structure.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_version_t {
    /// < major number
    pub major: ::libc::c_int,
    /// < minor number
    pub minor: ::libc::c_int,
    /// < patch number
    pub patch: ::libc::c_int,
    /// < additional string like "-dev"
    pub add_string: *const ::libc::c_char,
}

#[test]
fn bindgen_test_layout_ap_version_t() {
    assert_eq!(::std::mem::size_of::<ap_version_t>(), 24usize, concat!( "Size of: " , stringify ! ( ap_version_t ) ));
    assert_eq!(::std::mem::align_of::<ap_version_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_version_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_version_t>())).major as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_version_t ) , "::" , stringify ! ( major ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_version_t>())).minor as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( ap_version_t ) , "::" , stringify ! ( minor ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_version_t>())).patch as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_version_t ) , "::" , stringify ! ( patch ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_version_t>())).add_string as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_version_t ) , "::" , stringify ! ( add_string ) ));
}

/// @struct ap_method_list_t
/// @brief  Structure for handling HTTP methods.
///
/// Methods known to the server are accessed via a bitmask shortcut;
/// extension methods are handled by an array.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_method_list_t {
    /// The bitmask used for known methods
    pub method_mask: apr_int64_t,
    /// the array used for extension methods
    pub method_list: *mut apr_array_header_t,
}

#[test]
fn bindgen_test_layout_ap_method_list_t() {
    assert_eq!(::std::mem::size_of::<ap_method_list_t>(), 16usize, concat!( "Size of: " , stringify ! ( ap_method_list_t ) ));
    assert_eq!(::std::mem::align_of::<ap_method_list_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_method_list_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_method_list_t>())).method_mask as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_method_list_t ) , "::" , stringify ! ( method_mask ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_method_list_t>())).method_list as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_method_list_t ) , "::" , stringify ! ( method_list ) ));
}

/// @brief This represents the result of calling htaccess; these are cached for
/// each request.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct htaccess_result {
    /// the directory to which this applies
    pub dir: *const ::libc::c_char,
    /// the overrides allowed for the .htaccess file
    pub override_: ::libc::c_int,
    /// the override options allowed for the .htaccess file
    pub override_opts: ::libc::c_int,
    /// the configuration directives
    pub htaccess: *mut ap_conf_vector_t,
    /// the next one, or NULL if no more; N.B. never change this
    pub next: *const htaccess_result,
}

#[test]
fn bindgen_test_layout_htaccess_result() {
    assert_eq!(::std::mem::size_of::<htaccess_result>(), 32usize, concat!( "Size of: " , stringify ! ( htaccess_result ) ));
    assert_eq!(::std::mem::align_of::<htaccess_result>(), 8usize, concat!( "Alignment of " , stringify ! ( htaccess_result ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<htaccess_result>())).dir as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( htaccess_result ) , "::" , stringify ! ( dir ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<htaccess_result>())).override_ as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( htaccess_result ) , "::" , stringify ! ( override_ ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<htaccess_result>())).override_opts as *const _ as usize }, 12usize, concat!( "Offset of field: " , stringify ! ( htaccess_result ) , "::" , stringify ! ( override_opts ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<htaccess_result>())).htaccess as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( htaccess_result ) , "::" , stringify ! ( htaccess ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<htaccess_result>())).next as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( htaccess_result ) , "::" , stringify ! ( next ) ));
}

/// A structure to encompass all of the fields in a uri
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct apr_uri_t {
    /// scheme ("http"/"ftp"/...)
    pub scheme: *mut ::libc::c_char,
    /// combined [user[:password]\@]host[:port]
    pub hostinfo: *mut ::libc::c_char,
    /// user name, as in http://user:passwd\@host:port/
    pub user: *mut ::libc::c_char,
    /// password, as in http://user:passwd\@host:port/
    pub password: *mut ::libc::c_char,
    /// hostname from URI (or from Host: header)
    pub hostname: *mut ::libc::c_char,
    /// port string (integer representation is in "port")
    pub port_str: *mut ::libc::c_char,
    /// the request path (or NULL if only scheme://host was given)
    pub path: *mut ::libc::c_char,
    /// Everything after a '?' in the path, if present
    pub query: *mut ::libc::c_char,
    /// Trailing "#fragment" string, if present
    pub fragment: *mut ::libc::c_char,
    /// structure returned from gethostbyname()
    pub hostent: *mut hostent,
    /// The port number, numeric, valid only if port_str != NULL
    pub port: apr_port_t,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 5usize],
}

#[test]
fn bindgen_test_layout_apr_uri_t() {
    assert_eq!(::std::mem::size_of::<apr_uri_t>(), 88usize, concat!( "Size of: " , stringify ! ( apr_uri_t ) ));
    assert_eq!(::std::mem::align_of::<apr_uri_t>(), 8usize, concat!( "Alignment of " , stringify ! ( apr_uri_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).scheme as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( scheme ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).hostinfo as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( hostinfo ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).user as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( user ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).password as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( password ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).hostname as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( hostname ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).port_str as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( port_str ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).path as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( path ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).query as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( query ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).fragment as *const _ as usize }, 64usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( fragment ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).hostent as *const _ as usize }, 72usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( hostent ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<apr_uri_t>())).port as *const _ as usize }, 80usize, concat!( "Offset of field: " , stringify ! ( apr_uri_t ) , "::" , stringify ! ( port ) ));
}

impl apr_uri_t {
    #[inline]
    pub fn is_initialized(&self) -> ::libc::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) } }
    #[inline]
    pub fn set_is_initialized(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dns_looked_up(&self) -> ::libc::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) } }
    #[inline]
    pub fn set_dns_looked_up(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn dns_resolved(&self) -> ::libc::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) } }
    #[inline]
    pub fn set_dns_resolved(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(is_initialized: ::libc::c_uint, dns_looked_up: ::libc::c_uint, dns_resolved: ::libc::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_initialized: u32 = unsafe { ::std::mem::transmute(is_initialized) };
            is_initialized as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let dns_looked_up: u32 = unsafe { ::std::mem::transmute(dns_looked_up) };
            dns_looked_up as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let dns_resolved: u32 = unsafe { ::std::mem::transmute(dns_resolved) };
            dns_resolved as u64
        });
        __bindgen_bitfield_unit
    }
}

/// @brief A structure that represents one process
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct process_rec {
    /// Global pool. Cleared upon normal exit
    pub pool: *mut apr_pool_t,
    /// Configuration pool. Cleared upon restart
    pub pconf: *mut apr_pool_t,
    /// Number of command line arguments passed to the program
    pub argc: ::libc::c_int,
    /// The command line arguments
    pub argv: *const *const ::libc::c_char,
    /// The program name used to execute the program
    pub short_name: *const ::libc::c_char,
}

#[test]
fn bindgen_test_layout_process_rec() {
    assert_eq!(::std::mem::size_of::<process_rec>(), 40usize, concat!( "Size of: " , stringify ! ( process_rec ) ));
    assert_eq!(::std::mem::align_of::<process_rec>(), 8usize, concat!( "Alignment of " , stringify ! ( process_rec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<process_rec>())).pool as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( process_rec ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<process_rec>())).pconf as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( process_rec ) , "::" , stringify ! ( pconf ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<process_rec>())).argc as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( process_rec ) , "::" , stringify ! ( argc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<process_rec>())).argv as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( process_rec ) , "::" , stringify ! ( argv ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<process_rec>())).short_name as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( process_rec ) , "::" , stringify ! ( short_name ) ));
}

/// @brief A structure that represents the current request
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct request_rec {
    /// The pool associated with the request
    pub pool: *mut ffi::apr_pool_t,
    /// The connection to the client
    pub connection: *mut ffi::conn_rec,
    /// The virtual host for this request
    pub server: *mut ffi::server_rec,
    /// Pointer to the redirected request if this is an external redirect
    pub next: *mut ffi::request_rec,
    /// Pointer to the previous request if this is an internal redirect
    pub prev: *mut ffi::request_rec,
    /// Pointer to the main request if this is a sub-request
    /// (see http_request.h)
    pub main: *mut request_rec,
    /// First line of request
    pub the_request: *mut ::libc::c_char,
    /// HTTP/0.9, "simple" request (e.g. GET /foo\n w/no headers)
    pub assbackwards: ::libc::c_int,
    /// A proxy request (calculated during post_read_request/translate_name)
    /// possible values PROXYREQ_NONE, PROXYREQ_PROXY, PROXYREQ_REVERSE,
    /// PROXYREQ_RESPONSE
    pub proxyreq: ::libc::c_int,
    /// HEAD request, as opposed to GET
    pub header_only: ::libc::c_int,
    /// Protocol string, as given to us, or HTTP/0.9
    pub protocol: *mut ::libc::c_char,
    /// Protocol version number of protocol; 1.1 = 1001
    pub proto_num: ::libc::c_int,
    /// Host, as set by full URI or Host:
    pub hostname: *const ::libc::c_char,
    /// Time when the request started
    pub request_time: apr_time_t,
    /// Status line, if set by script
    pub status_line: *const ::libc::c_char,
    /// Status line
    pub status: ::libc::c_int,
    /// Request method (eg. GET, HEAD, POST, etc.)
    pub method: *const ::libc::c_char,
    /// M_GET, M_POST, etc.
    pub method_number: ::libc::c_int,
    /// 'allowed' is a bitvector of the allowed methods.
    ///
    /// A handler must ensure that the request method is one that
    /// it is capable of handling.  Generally modules should DECLINE
    /// any request methods they do not handle.  Prior to aborting the
    /// handler like this the handler should set r->allowed to the list
    /// of methods that it is willing to handle.  This bitvector is used
    /// to construct the "Allow:" header required for OPTIONS requests,
    /// and HTTP_METHOD_NOT_ALLOWED and HTTP_NOT_IMPLEMENTED status codes.
    ///
    /// Since the default_handler deals with OPTIONS, all modules can
    /// usually decline to deal with OPTIONS.  TRACE is always allowed,
    /// modules don't need to set it explicitly.
    ///
    /// Since the default_handler will always handle a GET, a
    /// module which does *not* implement GET should probably return
    /// HTTP_METHOD_NOT_ALLOWED.  Unfortunately this means that a Script GET
    /// handler can't be installed by mod_actions.
    pub allowed: apr_int64_t,
    /// Array of extension methods
    pub allowed_xmethods: *mut ffi::apr_array_header_t,
    /// List of allowed methods
    pub allowed_methods: *mut ap_method_list_t,
    /// byte count in stream is for body
    pub sent_bodyct: apr_off_t,
    /// body byte count, for easy access
    pub bytes_sent: apr_off_t,
    /// Last modified time of the requested resource
    pub mtime: apr_time_t,
    /// sending chunked transfer-coding
    pub chunked: ::libc::c_int,
    /// The Range: header
    pub range: *const ::libc::c_char,
    /// The "real" content length
    pub clength: apr_off_t,
    /// Remaining bytes left to read from the request body
    pub remaining: apr_off_t,
    /// Number of bytes that have been read  from the request body
    pub read_length: apr_off_t,
    /// Method for reading the request body
    /// (eg. REQUEST_CHUNKED_ERROR, REQUEST_NO_BODY,
    /// REQUEST_CHUNKED_DECHUNK, etc...)
    pub read_body: ::libc::c_int,
    /// reading chunked transfer-coding
    pub read_chunked: ::libc::c_int,
    /// is client waiting for a 100 response?
    pub expecting_100: ::libc::c_uint,
    /// MIME header environment from the request
    pub headers_in: *mut ffi::apr_table_t,
    /// MIME header environment for the response
    pub headers_out: *mut ffi::apr_table_t,
    /// MIME header environment for the response, printed even on errors and
    /// persist across internal redirects
    pub err_headers_out: *mut ffi::apr_table_t,
    /// Array of environment variables to be used for sub processes
    pub subprocess_env: *mut ffi::apr_table_t,
    /// Notes from one module to another
    pub notes: *mut ffi::apr_table_t,
    /// The content-type for the current request
    pub content_type: *const ::libc::c_char,
    /// The handler string that we use to call a handler function
    pub handler: *const ::libc::c_char,
    /// How to encode the data
    pub content_encoding: *const ::libc::c_char,
    /// Array of strings representing the content languages
    pub content_languages: *mut ffi::apr_array_header_t,
    /// variant list validator (if negotiated)
    pub vlist_validator: *mut ::libc::c_char,
    /// If an authentication check was made, this gets set to the user name.
    pub user: *mut ::libc::c_char,
    /// If an authentication check was made, this gets set to the auth type.
    pub ap_auth_type: *mut ::libc::c_char,
    /// This response can not be cached
    pub no_cache: ::libc::c_int,
    /// There is no local copy of this response
    pub no_local_copy: ::libc::c_int,
    /// The URI without any parsing performed
    pub unparsed_uri: *mut ::libc::c_char,
    /// The path portion of the URI, or "/" if no path provided
    pub uri: *mut ::libc::c_char,
    /// The filename on disk corresponding to this response
    pub filename: *mut ::libc::c_char,
    /// The true filename, we canonicalize r->filename if these don't match
    pub canonical_filename: *mut ::libc::c_char,
    /// The PATH_INFO extracted from this request
    pub path_info: *mut ::libc::c_char,
    /// The QUERY_ARGS extracted from this request
    pub args: *mut ::libc::c_char,
    /// finfo.protection (st_mode) set to zero if no such file
    pub finfo: apr_finfo_t,
    /// A struct containing the components of URI
    pub parsed_uri: apr_uri_t,
    /// Flag for the handler to accept or reject path_info on
    /// the current request.  All modules should respect the
    /// AP_REQ_ACCEPT_PATH_INFO and AP_REQ_REJECT_PATH_INFO
    /// values, while AP_REQ_DEFAULT_PATH_INFO indicates they
    /// may follow existing conventions.  This is set to the
    /// user's preference upon HOOK_VERY_FIRST of the fixups.
    pub used_path_info: ::libc::c_int,
    /// Options set in config files, etc.
    pub per_dir_config: *mut ffi::ap_conf_vector_t,
    /// Notes on *this* request
    pub request_config: *mut ap_conf_vector_t,
    /// A linked list of the .htaccess configuration directives
    /// accessed by this request.
    /// N.B. always add to the head of the list, _never_ to the end.
    /// that way, a sub request's list can (temporarily) point to a parent's list
    pub htaccess: *const htaccess_result,
    /// A list of output filters to be used for this request
    pub output_filters: *mut ap_filter_t,
    /// A list of input filters to be used for this request
    pub input_filters: *mut ffi::ap_filter_t,
    /// A list of protocol level output filters to be used for this
    /// request
    pub proto_output_filters: *mut ffi::ap_filter_t,
    /// A list of protocol level input filters to be used for this
    /// request
    pub proto_input_filters: *mut ap_filter_t,
    /// A flag to determine if the eos bucket has been sent yet
    pub eos_sent: ::libc::c_int,
    /// MIME trailer environment from the request
    pub trailers_in: *mut apr_table_t,
    /// MIME trailer environment from the response
    pub trailers_out: *mut apr_table_t,
}

#[test]
fn bindgen_test_layout_request_rec() {
    assert_eq!(::std::mem::size_of::<request_rec>(), 688usize, concat!( "Size of: " , stringify ! ( request_rec ) ));
    assert_eq!(::std::mem::align_of::<request_rec>(), 8usize, concat!( "Alignment of " , stringify ! ( request_rec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).pool as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).connection as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( connection ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).server as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( server ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).next as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).prev as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( prev ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).main as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( main ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).the_request as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( the_request ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).assbackwards as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( assbackwards ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).proxyreq as *const _ as usize }, 60usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( proxyreq ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).header_only as *const _ as usize }, 64usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( header_only ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).protocol as *const _ as usize }, 72usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( protocol ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).proto_num as *const _ as usize }, 80usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( proto_num ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).hostname as *const _ as usize }, 88usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( hostname ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).request_time as *const _ as usize }, 96usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( request_time ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).status_line as *const _ as usize }, 104usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( status_line ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).status as *const _ as usize }, 112usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( status ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).method as *const _ as usize }, 120usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( method ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).method_number as *const _ as usize }, 128usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( method_number ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).allowed as *const _ as usize }, 136usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( allowed ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).allowed_xmethods as *const _ as usize }, 144usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( allowed_xmethods ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).allowed_methods as *const _ as usize }, 152usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( allowed_methods ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).sent_bodyct as *const _ as usize }, 160usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( sent_bodyct ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).bytes_sent as *const _ as usize }, 168usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( bytes_sent ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).mtime as *const _ as usize }, 176usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( mtime ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).chunked as *const _ as usize }, 184usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( chunked ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).range as *const _ as usize }, 192usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( range ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).clength as *const _ as usize }, 200usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( clength ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).remaining as *const _ as usize }, 208usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( remaining ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).read_length as *const _ as usize }, 216usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( read_length ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).read_body as *const _ as usize }, 224usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( read_body ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).read_chunked as *const _ as usize }, 228usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( read_chunked ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).expecting_100 as *const _ as usize }, 232usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( expecting_100 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).headers_in as *const _ as usize }, 240usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( headers_in ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).headers_out as *const _ as usize }, 248usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( headers_out ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).err_headers_out as *const _ as usize }, 256usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( err_headers_out ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).subprocess_env as *const _ as usize }, 264usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( subprocess_env ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).notes as *const _ as usize }, 272usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( notes ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).content_type as *const _ as usize }, 280usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( content_type ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).handler as *const _ as usize }, 288usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( handler ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).content_encoding as *const _ as usize }, 296usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( content_encoding ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).content_languages as *const _ as usize }, 304usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( content_languages ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).vlist_validator as *const _ as usize }, 312usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( vlist_validator ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).user as *const _ as usize }, 320usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( user ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).ap_auth_type as *const _ as usize }, 328usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( ap_auth_type ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).no_cache as *const _ as usize }, 336usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( no_cache ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).no_local_copy as *const _ as usize }, 340usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( no_local_copy ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).unparsed_uri as *const _ as usize }, 344usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( unparsed_uri ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).uri as *const _ as usize }, 352usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( uri ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).filename as *const _ as usize }, 360usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( filename ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).canonical_filename as *const _ as usize }, 368usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( canonical_filename ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).path_info as *const _ as usize }, 376usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( path_info ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).args as *const _ as usize }, 384usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( args ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).finfo as *const _ as usize }, 392usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( finfo ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).parsed_uri as *const _ as usize }, 512usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( parsed_uri ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).used_path_info as *const _ as usize }, 600usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( used_path_info ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).per_dir_config as *const _ as usize }, 608usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( per_dir_config ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).request_config as *const _ as usize }, 616usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( request_config ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).htaccess as *const _ as usize }, 624usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( htaccess ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).output_filters as *const _ as usize }, 632usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( output_filters ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).input_filters as *const _ as usize }, 640usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( input_filters ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).proto_output_filters as *const _ as usize }, 648usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( proto_output_filters ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).proto_input_filters as *const _ as usize }, 656usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( proto_input_filters ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).eos_sent as *const _ as usize }, 664usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( eos_sent ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).trailers_in as *const _ as usize }, 672usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( trailers_in ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<request_rec>())).trailers_out as *const _ as usize }, 680usize, concat!( "Offset of field: " , stringify ! ( request_rec ) , "::" , stringify ! ( trailers_out ) ));
}

pub const ap_conn_keepalive_e_AP_CONN_UNKNOWN: ap_conn_keepalive_e = 0;
pub const ap_conn_keepalive_e_AP_CONN_CLOSE: ap_conn_keepalive_e = 1;
pub const ap_conn_keepalive_e_AP_CONN_KEEPALIVE: ap_conn_keepalive_e = 2;

/// @brief Enumeration of connection keepalive options
pub type ap_conn_keepalive_e = u32;

/// @brief Structure to store things which are per connection
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conn_rec {
    /// Pool associated with this connection
    pub pool: *mut ffi::apr_pool_t,
    /// Physical vhost this conn came in on
    pub base_server: *mut ffi::server_rec,
    /// used by http_vhost.c
    pub vhost_lookup_data: *mut ::libc::c_void,
    /// local address
    pub local_addr: *mut apr_sockaddr_t,
    /// remote address
    pub remote_addr: *mut apr_sockaddr_t,
    /// Client's IP address
    pub remote_ip: *mut ::libc::c_char,
    /// Client's DNS name, if known.  NULL if DNS hasn't been checked,
    /// "" if it has and no address was found.  N.B. Only access this though
    /// get_remote_host()
    pub remote_host: *mut ::libc::c_char,
    /// Only ever set if doing rfc1413 lookups.  N.B. Only access this through
    /// get_remote_logname()
    pub remote_logname: *mut ::libc::c_char,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    /// Are we going to keep the connection alive for another request?
    /// @see ap_conn_keepalive_e
    pub keepalive: ap_conn_keepalive_e,
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    /// How many times have we used it?
    pub keepalives: ::libc::c_int,
    /// server IP address
    pub local_ip: *mut ::libc::c_char,
    /// used for ap_get_server_name when UseCanonicalName is set to DNS
    /// (ignores setting of HostnameLookups)
    pub local_host: *mut ::libc::c_char,
    /// ID of this connection; unique at any point in time
    pub id: ::libc::c_long,
    /// Config vector containing pointers to connections per-server
    /// config structures.
    pub conn_config: *mut ffi::ap_conf_vector_t,
    /// Notes on *this* connection: send note from one module to
    /// another. must remain valid for all requests on this conn
    pub notes: *mut ffi::apr_table_t,
    /// A list of input filters to be used for this connection
    pub input_filters: *mut ffi::ap_filter_t,
    /// A list of output filters to be used for this connection
    pub output_filters: *mut ffi::ap_filter_t,
    /// handle to scoreboard information for this connection
    pub sbh: *mut ::libc::c_void,
    /// The bucket allocator to use for all bucket/brigade creations
    pub bucket_alloc: *mut ffi::apr_bucket_alloc_t,
    /// The current state of this connection; may be NULL if not used by MPM
    pub cs: *mut conn_state_t,
    /// Is there data pending in the input filters?
    pub data_in_input_filters: ::libc::c_int,
    /// Are there any filters that clogg/buffer the input stream, breaking
    /// the event mpm.
    pub clogging_input_filters: ::libc::c_int,
}

#[test]
fn bindgen_test_layout_conn_rec() {
    assert_eq!(::std::mem::size_of::<conn_rec>(), 168usize, concat!( "Size of: " , stringify ! ( conn_rec ) ));
    assert_eq!(::std::mem::align_of::<conn_rec>(), 8usize, concat!( "Alignment of " , stringify ! ( conn_rec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).pool as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).base_server as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( base_server ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).vhost_lookup_data as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( vhost_lookup_data ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).local_addr as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( local_addr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).remote_addr as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( remote_addr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).remote_ip as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( remote_ip ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).remote_host as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( remote_host ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).remote_logname as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( remote_logname ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).keepalive as *const _ as usize }, 68usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( keepalive ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).keepalives as *const _ as usize }, 76usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( keepalives ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).local_ip as *const _ as usize }, 80usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( local_ip ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).local_host as *const _ as usize }, 88usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( local_host ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).id as *const _ as usize }, 96usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( id ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).conn_config as *const _ as usize }, 104usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( conn_config ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).notes as *const _ as usize }, 112usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( notes ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).input_filters as *const _ as usize }, 120usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( input_filters ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).output_filters as *const _ as usize }, 128usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( output_filters ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).sbh as *const _ as usize }, 136usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( sbh ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).bucket_alloc as *const _ as usize }, 144usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( bucket_alloc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).cs as *const _ as usize }, 152usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( cs ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).data_in_input_filters as *const _ as usize }, 160usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( data_in_input_filters ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_rec>())).clogging_input_filters as *const _ as usize }, 164usize, concat!( "Offset of field: " , stringify ! ( conn_rec ) , "::" , stringify ! ( clogging_input_filters ) ));
}

impl conn_rec {
    #[inline]
    pub fn aborted(&self) -> ::libc::c_uint { unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) } }
    #[inline]
    pub fn set_aborted(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(aborted: ::libc::c_uint) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let aborted: u32 = unsafe { ::std::mem::transmute(aborted) };
            aborted as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn double_reverse(&self) -> ::libc::c_int { unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 2u8) as u32) } }
    #[inline]
    pub fn set_double_reverse(&mut self, val: ::libc::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(double_reverse: ::libc::c_int) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let double_reverse: u32 = unsafe { ::std::mem::transmute(double_reverse) };
            double_reverse as u64
        });
        __bindgen_bitfield_unit
    }
}

pub const conn_state_e_CONN_STATE_CHECK_REQUEST_LINE_READABLE: conn_state_e = 0;
pub const conn_state_e_CONN_STATE_READ_REQUEST_LINE: conn_state_e = 1;
pub const conn_state_e_CONN_STATE_LINGER: conn_state_e = 2;

/// Enumeration of connection states
pub type conn_state_e = u32;

/// @brief A structure to contain connection state information
#[repr(C)]
#[derive(Copy, Clone)]
pub struct conn_state_t {
    /// APR_RING of expiration timeouts
    pub timeout_list: conn_state_t__bindgen_ty_1,
    /// the expiration time of the next keepalive timeout
    pub expiration_time: apr_time_t,
    /// Current state of the connection
    pub state: conn_state_e,
    /// connection record this struct refers to
    pub c: *mut conn_rec,
    /// memory pool to allocate from
    pub p: *mut apr_pool_t,
    /// bucket allocator
    pub bucket_alloc: *mut apr_bucket_alloc_t,
    /// poll file decriptor information
    pub pfd: apr_pollfd_t,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct conn_state_t__bindgen_ty_1 { pub next: *mut conn_state_t, pub prev: *mut conn_state_t }

#[test]
fn bindgen_test_layout_conn_state_t__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<conn_state_t__bindgen_ty_1>(), 16usize, concat!( "Size of: " , stringify ! ( conn_state_t__bindgen_ty_1 ) ));
    assert_eq!(::std::mem::align_of::<conn_state_t__bindgen_ty_1>(), 8usize, concat!( "Alignment of " , stringify ! ( conn_state_t__bindgen_ty_1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_state_t__bindgen_ty_1>())).next as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( conn_state_t__bindgen_ty_1 ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_state_t__bindgen_ty_1>())).prev as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( conn_state_t__bindgen_ty_1 ) , "::" , stringify ! ( prev ) ));
}

#[test]
fn bindgen_test_layout_conn_state_t() {
    assert_eq!(::std::mem::size_of::<conn_state_t>(), 88usize, concat!( "Size of: " , stringify ! ( conn_state_t ) ));
    assert_eq!(::std::mem::align_of::<conn_state_t>(), 8usize, concat!( "Alignment of " , stringify ! ( conn_state_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_state_t>())).timeout_list as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( conn_state_t ) , "::" , stringify ! ( timeout_list ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_state_t>())).expiration_time as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( conn_state_t ) , "::" , stringify ! ( expiration_time ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_state_t>())).state as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( conn_state_t ) , "::" , stringify ! ( state ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_state_t>())).c as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( conn_state_t ) , "::" , stringify ! ( c ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_state_t>())).p as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( conn_state_t ) , "::" , stringify ! ( p ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_state_t>())).bucket_alloc as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( conn_state_t ) , "::" , stringify ! ( bucket_alloc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<conn_state_t>())).pfd as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( conn_state_t ) , "::" , stringify ! ( pfd ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct server_addr_rec {
    /// The next server in the list
    pub next: *mut server_addr_rec,
    /// The bound address, for this server
    pub host_addr: *mut apr_sockaddr_t,
    /// The bound port, for this server
    pub host_port: apr_port_t,
    /// The name given in "<VirtualHost>"
    pub virthost: *mut ::libc::c_char,
}

#[test]
fn bindgen_test_layout_server_addr_rec() {
    assert_eq!(::std::mem::size_of::<server_addr_rec>(), 32usize, concat!( "Size of: " , stringify ! ( server_addr_rec ) ));
    assert_eq!(::std::mem::align_of::<server_addr_rec>(), 8usize, concat!( "Alignment of " , stringify ! ( server_addr_rec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_addr_rec>())).next as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( server_addr_rec ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_addr_rec>())).host_addr as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( server_addr_rec ) , "::" , stringify ! ( host_addr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_addr_rec>())).host_port as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( server_addr_rec ) , "::" , stringify ! ( host_port ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_addr_rec>())).virthost as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( server_addr_rec ) , "::" , stringify ! ( virthost ) ));
}

/// @brief A structure to store information for each virtual server
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct server_rec {
    /// The process this server is running in
    pub process: *mut process_rec,
    /// The next server in the list
    pub next: *mut server_rec,
    /// The name of the server
    pub defn_name: *const ::libc::c_char,
    /// The line of the config file that the server was defined on
    pub defn_line_number: ::libc::c_uint,
    /// The admin's contact information
    pub server_admin: *mut ::libc::c_char,
    /// The server hostname
    pub server_hostname: *mut ::libc::c_char,
    /// for redirects, etc.
    pub port: apr_port_t,
    /// The name of the error log
    pub error_fname: *mut ::libc::c_char,
    /// A file descriptor that references the error log
    pub error_log: *mut ffi::apr_file_t,
    /// The log level for this server
    pub loglevel: ::libc::c_int,
    /// true if this is the virtual server
    pub is_virtual: ::libc::c_int,
    /// Config vector containing pointers to modules' per-server config
    /// structures.
    pub module_config: *mut ap_conf_vector_t,
    /// MIME type info, etc., before we start checking per-directory info
    pub lookup_defaults: *mut ap_conf_vector_t,
    /// I haven't got a clue
    pub addrs: *mut server_addr_rec,
    /// Timeout, as an apr interval, before we give up
    pub timeout: apr_interval_time_t,
    /// The apr interval we will wait for another request
    pub keep_alive_timeout: apr_interval_time_t,
    /// Maximum requests per connection
    pub keep_alive_max: ::libc::c_int,
    /// Use persistent connections?
    pub keep_alive: ::libc::c_int,
    /// Pathname for ServerPath
    pub path: *const ::libc::c_char,
    /// Length of path
    pub pathlen: ::libc::c_int,
    /// Normal names for ServerAlias servers
    pub names: *mut apr_array_header_t,
    /// Wildcarded names for ServerAlias servers
    pub wild_names: *mut apr_array_header_t,
    /// limit on size of the HTTP request line
    pub limit_req_line: ::libc::c_int,
    /// limit on size of any request header field
    pub limit_req_fieldsize: ::libc::c_int,
    /// limit on number of request header fields
    pub limit_req_fields: ::libc::c_int,
    /// The server request scheme for redirect responses
    pub server_scheme: *const ::libc::c_char,
}

#[test]
fn bindgen_test_layout_server_rec() {
    assert_eq!(::std::mem::size_of::<server_rec>(), 184usize, concat!( "Size of: " , stringify ! ( server_rec ) ));
    assert_eq!(::std::mem::align_of::<server_rec>(), 8usize, concat!( "Alignment of " , stringify ! ( server_rec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).process as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( process ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).next as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).defn_name as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( defn_name ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).defn_line_number as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( defn_line_number ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).server_admin as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( server_admin ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).server_hostname as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( server_hostname ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).port as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( port ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).error_fname as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( error_fname ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).error_log as *const _ as usize }, 64usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( error_log ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).loglevel as *const _ as usize }, 72usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( loglevel ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).is_virtual as *const _ as usize }, 76usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( is_virtual ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).module_config as *const _ as usize }, 80usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( module_config ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).lookup_defaults as *const _ as usize }, 88usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( lookup_defaults ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).addrs as *const _ as usize }, 96usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( addrs ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).timeout as *const _ as usize }, 104usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( timeout ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).keep_alive_timeout as *const _ as usize }, 112usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( keep_alive_timeout ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).keep_alive_max as *const _ as usize }, 120usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( keep_alive_max ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).keep_alive as *const _ as usize }, 124usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( keep_alive ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).path as *const _ as usize }, 128usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( path ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).pathlen as *const _ as usize }, 136usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( pathlen ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).names as *const _ as usize }, 144usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( names ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).wild_names as *const _ as usize }, 152usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( wild_names ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).limit_req_line as *const _ as usize }, 160usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( limit_req_line ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).limit_req_fieldsize as *const _ as usize }, 164usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( limit_req_fieldsize ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).limit_req_fields as *const _ as usize }, 168usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( limit_req_fields ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<server_rec>())).server_scheme as *const _ as usize }, 176usize, concat!( "Offset of field: " , stringify ! ( server_rec ) , "::" , stringify ! ( server_scheme ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct core_output_filter_ctx {
    pub b: *mut apr_bucket_brigade,
    /// subpool of c->pool used for resources
    /// which may outlive the request
    pub deferred_write_pool: *mut apr_pool_t,
}

#[test]
fn bindgen_test_layout_core_output_filter_ctx() {
    assert_eq!(::std::mem::size_of::<core_output_filter_ctx>(), 16usize, concat!( "Size of: " , stringify ! ( core_output_filter_ctx ) ));
    assert_eq!(::std::mem::align_of::<core_output_filter_ctx>(), 8usize, concat!( "Alignment of " , stringify ! ( core_output_filter_ctx ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<core_output_filter_ctx>())).b as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( core_output_filter_ctx ) , "::" , stringify ! ( b ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<core_output_filter_ctx>())).deferred_write_pool as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( core_output_filter_ctx ) , "::" , stringify ! ( deferred_write_pool ) ));
}

pub type core_output_filter_ctx_t = core_output_filter_ctx;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct core_filter_ctx { pub b: *mut apr_bucket_brigade, pub tmpbb: *mut apr_bucket_brigade }

#[test]
fn bindgen_test_layout_core_filter_ctx() {
    assert_eq!(::std::mem::size_of::<core_filter_ctx>(), 16usize, concat!( "Size of: " , stringify ! ( core_filter_ctx ) ));
    assert_eq!(::std::mem::align_of::<core_filter_ctx>(), 8usize, concat!( "Alignment of " , stringify ! ( core_filter_ctx ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<core_filter_ctx>())).b as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( core_filter_ctx ) , "::" , stringify ! ( b ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<core_filter_ctx>())).tmpbb as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( core_filter_ctx ) , "::" , stringify ! ( tmpbb ) ));
}

pub type core_ctx_t = core_filter_ctx;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct core_net_rec {
    /// Connection to the client
    pub client_socket: *mut apr_socket_t,
    /// connection record
    pub c: *mut conn_rec,
    pub out_ctx: *mut core_output_filter_ctx_t,
    pub in_ctx: *mut core_ctx_t,
}

#[test]
fn bindgen_test_layout_core_net_rec() {
    assert_eq!(::std::mem::size_of::<core_net_rec>(), 32usize, concat!( "Size of: " , stringify ! ( core_net_rec ) ));
    assert_eq!(::std::mem::align_of::<core_net_rec>(), 8usize, concat!( "Alignment of " , stringify ! ( core_net_rec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<core_net_rec>())).client_socket as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( core_net_rec ) , "::" , stringify ! ( client_socket ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<core_net_rec>())).c as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( core_net_rec ) , "::" , stringify ! ( c ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<core_net_rec>())).out_ctx as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( core_net_rec ) , "::" , stringify ! ( out_ctx ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<core_net_rec>())).in_ctx as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( core_net_rec ) , "::" , stringify ! ( in_ctx ) ));
}

extern "C" {
    /// Examine a field value (such as a media-/content-type) string and return
/// it sans any parameters; e.g., strip off any ';charset=foo' and the like.
/// @param p Pool to allocate memory from
/// @param intype The field to examine
/// @return A copy of the field minus any parameters
    pub fn ap_field_noparam(p: *mut apr_pool_t, intype: *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Convert a time from an integer into a string in a specified format
/// @param p The pool to allocate memory from
/// @param t The time to convert
/// @param fmt The format to use for the conversion
/// @param gmt Convert the time for GMT?
/// @return The string that represents the specified time
    pub fn ap_ht_time(p: *mut apr_pool_t, t: apr_time_t, fmt: *const ::libc::c_char, gmt: ::libc::c_int) -> *mut ::libc::c_char;
}

extern "C" {
    /// Get the characters until the first occurance of a specified character
/// @param p The pool to allocate memory from
/// @param line The string to get the characters from
/// @param stop The character to stop at
/// @return A copy of the characters up to the first stop character
    pub fn ap_getword(p: *mut apr_pool_t, line: *mut *const ::libc::c_char, stop: ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Get the characters until the first occurance of a specified character
/// @param p The pool to allocate memory from
/// @param line The string to get the characters from
/// @param stop The character to stop at
/// @return A copy of the characters up to the first stop character
/// @note This is the same as ap_getword(), except it doesn't use const char **.
    pub fn ap_getword_nc(p: *mut apr_pool_t, line: *mut *mut ::libc::c_char, stop: ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Get the first word from a given string.  A word is defined as all characters
/// up to the first whitespace.
/// @param p The pool to allocate memory from
/// @param line The string to traverse
/// @return The first word in the line
    pub fn ap_getword_white(p: *mut apr_pool_t, line: *mut *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Get the first word from a given string.  A word is defined as all characters
/// up to the first whitespace.
/// @param p The pool to allocate memory from
/// @param line The string to traverse
/// @return The first word in the line
/// @note The same as ap_getword_white(), except it doesn't use const char**
    pub fn ap_getword_white_nc(p: *mut apr_pool_t, line: *mut *mut ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Get all characters from the first occurance of @a stop to the first "\0"
/// @param p The pool to allocate memory from
/// @param line The line to traverse
/// @param stop The character to start at
/// @return A copy of all caracters after the first occurance of the specified
/// character
    pub fn ap_getword_nulls(p: *mut apr_pool_t, line: *mut *const ::libc::c_char, stop: ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Get all characters from the first occurance of @a stop to the first "\0"
/// @param p The pool to allocate memory from
/// @param line The line to traverse
/// @param stop The character to start at
/// @return A copy of all caracters after the first occurance of the specified
/// character
/// @note The same as ap_getword_nulls(), except it doesn't use const char **.
    pub fn ap_getword_nulls_nc(p: *mut apr_pool_t, line: *mut *mut ::libc::c_char, stop: ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Get the second word in the string paying attention to quoting
/// @param p The pool to allocate from
/// @param line The line to traverse
/// @return A copy of the string
    pub fn ap_getword_conf(p: *mut apr_pool_t, line: *mut *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Get the second word in the string paying attention to quoting
/// @param p The pool to allocate from
/// @param line The line to traverse
/// @return A copy of the string
/// @note The same as ap_getword_conf(), except it doesn't use const char **.
    pub fn ap_getword_conf_nc(p: *mut apr_pool_t, line: *mut *mut ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Check a string for any ${ENV} environment variable construct and replace
/// each them by the value of that environment variable, if it exists. If the
/// environment value does not exist, leave the ${ENV} construct alone; it
/// means something else.
/// @param p The pool to allocate from
/// @param word The string to check
/// @return The string with the replaced environment variables
    pub fn ap_resolve_env(p: *mut apr_pool_t, word: *const ::libc::c_char) -> *const ::libc::c_char;
}

extern "C" {
    /// Size an HTTP header field list item, as separated by a comma.
/// @param field The field to size
/// @param len The length of the field
/// @return The return value is a pointer to the beginning of the non-empty
/// list item within the original string (or NULL if there is none) and the
/// address of field is shifted to the next non-comma, non-whitespace
/// character.  len is the length of the item excluding any beginning whitespace.
    pub fn ap_size_list_item(field: *mut *const ::libc::c_char, len: *mut ::libc::c_int) -> *const ::libc::c_char;
}

extern "C" {
    /// Retrieve an HTTP header field list item, as separated by a comma,
/// while stripping insignificant whitespace and lowercasing anything not in
/// a quoted string or comment.
/// @param p The pool to allocate from
/// @param field The field to retrieve
/// @return The return value is a new string containing the converted list
/// item (or NULL if none) and the address pointed to by field is
/// shifted to the next non-comma, non-whitespace.
    pub fn ap_get_list_item(p: *mut apr_pool_t, field: *mut *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Find an item in canonical form (lowercase, no extra spaces) within
/// an HTTP field value list.
/// @param p The pool to allocate from
/// @param line The field value list to search
/// @param tok The token to search for
/// @return 1 if found, 0 if not found.
    pub fn ap_find_list_item(p: *mut apr_pool_t, line: *const ::libc::c_char, tok: *const ::libc::c_char) -> ::libc::c_int;
}

extern "C" { pub fn ap_scan_http_field_content(ptr: *const ::libc::c_char) -> *const ::libc::c_char; }

extern "C" { pub fn ap_scan_http_token(ptr: *const ::libc::c_char) -> *const ::libc::c_char; }

extern "C" { pub fn ap_scan_vchar_obstext(ptr: *const ::libc::c_char) -> *const ::libc::c_char; }

extern "C" {
    /// Retrieve a token, spacing over it and adjusting the pointer to
/// the first non-white byte afterwards.  Note that these tokens
/// are delimited by semis and commas and can also be delimited
/// by whitespace at the caller's option.
/// @param p The pool to allocate from
/// @param accept_line The line to retrieve the token from (adjusted afterwards)
/// @param accept_white Is it delimited by whitespace
/// @return the token
    pub fn ap_get_token(p: *mut apr_pool_t, accept_line: *mut *const ::libc::c_char, accept_white: ::libc::c_int) -> *mut ::libc::c_char;
}

extern "C" {
    /// Find http tokens, see the definition of token from RFC2068
/// @param p The pool to allocate from
/// @param line The line to find the token
/// @param tok The token to find
/// @return 1 if the token is found, 0 otherwise
    pub fn ap_find_token(p: *mut apr_pool_t, line: *const ::libc::c_char, tok: *const ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// find http tokens from the end of the line
/// @param p The pool to allocate from
/// @param line The line to find the token
/// @param tok The token to find
/// @return 1 if the token is found, 0 otherwise
    pub fn ap_find_last_token(p: *mut apr_pool_t, line: *const ::libc::c_char, tok: *const ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Check for an Absolute URI syntax
/// @param u The string to check
/// @return 1 if URI, 0 otherwise
    pub fn ap_is_url(u: *const ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Unescape a URL
/// @param url The url to unescape
/// @return 0 on success, non-zero otherwise
    pub fn ap_unescape_url(url: *mut ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Unescape a URL, including encoded slashes.
/// @param url The url to unescape
/// @return 0 on success, non-zero otherwise
    pub fn ap_unescape_url_keep2f(url: *mut ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Unescape a URL, including encoded slashes.
/// @param url The url to unescape
/// @param decode_slashes Whether or not slashes should be decoded or not
/// @return 0 on success, non-zero otherwise
    pub fn ap_unescape_url_keep2f_ex(url: *mut ::libc::c_char, decode_slashes: ::libc::c_int) -> ::libc::c_int;
}

extern "C" {
    /// Convert all double slashes to single slashes
/// @param name The string to convert
    pub fn ap_no2slash(name: *mut ::libc::c_char);
}

extern "C" {
    /// Remove all ./ and xx/../ substrings from a file name. Also remove
/// any leading ../ or /../ substrings.
/// @param name the file name to parse
    pub fn ap_getparents(name: *mut ::libc::c_char);
}

extern "C" {
    /// Escape a path segment, as defined in RFC 1808
/// @param p The pool to allocate from
/// @param s The path to convert
/// @return The converted URL
    pub fn ap_escape_path_segment(p: *mut apr_pool_t, s: *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// convert an OS path to a URL in an OS dependant way.
/// @param p The pool to allocate from
/// @param path The path to convert
/// @param partial if set, assume that the path will be appended to something
/// with a '/' in it (and thus does not prefix "./")
/// @return The converted URL
    pub fn ap_os_escape_path(p: *mut apr_pool_t, path: *const ::libc::c_char, partial: ::libc::c_int) -> *mut ::libc::c_char;
}

extern "C" {
    /// Escape an html string
/// @param p The pool to allocate from
/// @param s The html to escape
/// @return The escaped string
    pub fn ap_escape_html(p: *mut apr_pool_t, s: *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Escape an html string
/// @param p The pool to allocate from
/// @param s The html to escape
/// @param toasc Whether to escape all non-ASCII chars to &#nnn;
/// @return The escaped string
    pub fn ap_escape_html2(p: *mut apr_pool_t, s: *const ::libc::c_char, toasc: ::libc::c_int) -> *mut ::libc::c_char;
}

extern "C" {
    /// Escape a string for logging
/// @param p The pool to allocate from
/// @param str The string to escape
/// @return The escaped string
    pub fn ap_escape_logitem(p: *mut apr_pool_t, str: *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Escape a string for logging into the error log (without a pool)
/// @param dest The buffer to write to
/// @param source The string to escape
/// @param buflen The buffer size for the escaped string (including "\0")
/// @return The len of the escaped string (always < maxlen)
    pub fn ap_escape_errorlog_item(dest: *mut ::libc::c_char, source: *const ::libc::c_char, buflen: apr_size_t) -> apr_size_t;
}

extern "C" {
    /// Construct a full hostname
/// @param p The pool to allocate from
/// @param hostname The hostname of the server
/// @param port The port the server is running on
/// @param r The current request
/// @return The server's hostname
    pub fn ap_construct_server(p: *mut apr_pool_t, hostname: *const ::libc::c_char, port: apr_port_t, r: *const request_rec) -> *mut ::libc::c_char;
}

extern "C" {
    /// Escape a shell command
/// @param p The pool to allocate from
/// @param s The command to escape
/// @return The escaped shell command
    pub fn ap_escape_shell_cmd(p: *mut apr_pool_t, s: *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Count the number of directories in a path
/// @param path The path to count
/// @return The number of directories
    pub fn ap_count_dirs(path: *const ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Copy at most @a n leading directories of @a s into @a d. @a d
/// should be at least as large as @a s plus 1 extra byte
///
/// @param d The location to copy to
/// @param s The location to copy from
/// @param n The number of directories to copy
/// @return value is the ever useful pointer to the trailing "\0" of d
/// @note on platforms with drive letters, n = 0 returns the "/" root,
/// whereas n = 1 returns the "d:/" root.  On all other platforms, n = 0
/// returns the empty string.
    pub fn ap_make_dirstr_prefix(d: *mut ::libc::c_char, s: *const ::libc::c_char, n: ::libc::c_int) -> *mut ::libc::c_char;
}

extern "C" {
    /// Return the parent directory name (including trailing /) of the file
/// @a s
/// @param p The pool to allocate from
/// @param s The file to get the parent of
/// @return A copy of the file's parent directory
    pub fn ap_make_dirstr_parent(p: *mut apr_pool_t, s: *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Given a directory and filename, create a single path from them.  This
/// function is smart enough to ensure that there is a single '/' between the
/// directory and file names
/// @param a The pool to allocate from
/// @param dir The directory name
/// @param f The filename
/// @return A copy of the full path
/// @note Never consider using this function if you are dealing with filesystem
/// names that need to remain canonical, unless you are merging an apr_dir_read
/// path and returned filename.  Otherwise, the result is not canonical.
    pub fn ap_make_full_path(a: *mut apr_pool_t, dir: *const ::libc::c_char, f: *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Test if the given path has an an absolute path.
/// @param p The pool to allocate from
/// @param dir The directory name
/// @note The converse is not necessarily true, some OS's (Win32/OS2/Netware) have
/// multiple forms of absolute paths.  This only reports if the path is absolute
/// in a canonical sense.
    pub fn ap_os_is_path_absolute(p: *mut apr_pool_t, dir: *const ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Does the provided string contain wildcard characters?  This is useful
/// for determining if the string should be passed to strcmp_match or to strcmp.
/// The only wildcard characters recognized are '?' and '*'
/// @param str The string to check
/// @return 1 if the string has wildcards, 0 otherwise
    pub fn ap_is_matchexp(str: *const ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Determine if a string matches a pattern containing the wildcards '?' or '*'
/// @param str The string to check
/// @param expected The pattern to match against
/// @return 1 if the two strings match, 0 otherwise
    pub fn ap_strcmp_match(str: *const ::libc::c_char, expected: *const ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Determine if a string matches a pattern containing the wildcards '?' or '*',
/// ignoring case
/// @param str The string to check
/// @param expected The pattern to match against
/// @return 1 if the two strings match, 0 otherwise
    pub fn ap_strcasecmp_match(str: *const ::libc::c_char, expected: *const ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Find the first occurrence of the substring s2 in s1, regardless of case
/// @param s1 The string to search
/// @param s2 The substring to search for
/// @return A pointer to the beginning of the substring
/// @remark See apr_strmatch() for a faster alternative
    pub fn ap_strcasestr(s1: *const ::libc::c_char, s2: *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Return a pointer to the location inside of bigstring immediately after prefix
/// @param bigstring The input string
/// @param prefix The prefix to strip away
/// @return A pointer relative to bigstring after prefix
    pub fn ap_stripprefix(bigstring: *const ::libc::c_char, prefix: *const ::libc::c_char) -> *const ::libc::c_char;
}

extern "C" {
    /// Decode a base64 encoded string into memory allocated from a pool
/// @param p The pool to allocate from
/// @param bufcoded The encoded string
/// @return The decoded string
    pub fn ap_pbase64decode(p: *mut apr_pool_t, bufcoded: *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Encode a string into memory allocated from a pool in base 64 format
/// @param p The pool to allocate from
/// @param string The plaintext string
/// @return The encoded string
    pub fn ap_pbase64encode(p: *mut apr_pool_t, string: *mut ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Compile a regular expression to be used later
/// @param p The pool to allocate from
/// @param pattern the regular expression to compile
/// @param cflags The bitwise or of one or more of the following:
/// @li REG_EXTENDED - Use POSIX extended Regular Expressions
/// @li REG_ICASE    - Ignore case
/// @li REG_NOSUB    - Support for substring addressing of matches
/// not required
/// @li REG_NEWLINE  - Match-any-character operators don't match new-line
/// @return The compiled regular expression
    pub fn ap_pregcomp(p: *mut apr_pool_t, pattern: *const ::libc::c_char, cflags: ::libc::c_int) -> *mut ap_regex_t;
}

extern "C" {
    /// Free the memory associated with a compiled regular expression
/// @param p The pool the regex was allocated from
/// @param reg The regular expression to free
    pub fn ap_pregfree(p: *mut apr_pool_t, reg: *mut ap_regex_t);
}

extern "C" {
    /// After performing a successful regex match, you may use this function to
/// perform a series of string substitutions based on subexpressions that were
/// matched during the call to ap_regexec
/// @param p The pool to allocate from
/// @param input An arbitrary string containing $1 through $9.  These are
/// replaced with the corresponding matched sub-expressions
/// @param source The string that was originally matched to the regex
/// @param nmatch the nmatch returned from ap_pregex
/// @param pmatch the pmatch array returned from ap_pregex
    pub fn ap_pregsub(p: *mut apr_pool_t, input: *const ::libc::c_char, source: *const ::libc::c_char, nmatch: usize, pmatch: *mut ap_regmatch_t) -> *mut ::libc::c_char;
}

extern "C" {
    /// After performing a successful regex match, you may use this function to
/// perform a series of string substitutions based on subexpressions that were
/// matched during the call to ap_regexec
/// @param p The pool to allocate from
/// @param result where to store the result, will be set to NULL on error
/// @param input An arbitrary string containing $1 through $9.  These are
/// replaced with the corresponding matched sub-expressions
/// @param source The string that was originally matched to the regex
/// @param nmatch the nmatch returned from ap_pregex
/// @param pmatch the pmatch array returned from ap_pregex
/// @param maxlen the maximum string length to return, 0 for unlimited
/// @return APR_SUCCESS if successful, APR_ENOMEM or other error code otherwise.
    pub fn ap_pregsub_ex(p: *mut apr_pool_t, result: *mut *mut ::libc::c_char, input: *const ::libc::c_char, source: *const ::libc::c_char, nmatch: apr_size_t, pmatch: *mut ap_regmatch_t, maxlen: apr_size_t) -> apr_status_t;
}

extern "C" {
    /// We want to downcase the type/subtype for comparison purposes
/// but nothing else because ;parameter=foo values are case sensitive.
/// @param s The content-type to convert to lowercase
    pub fn ap_content_type_tolower(s: *mut ::libc::c_char);
}

extern "C" {
    /// convert a string to all lowercase
/// @param s The string to convert to lowercase
    pub fn ap_str_tolower(s: *mut ::libc::c_char);
}

extern "C" {
    /// Search a string from left to right for the first occurrence of a
/// specific character
/// @param str The string to search
/// @param c The character to search for
/// @return The index of the first occurrence of c in str
    pub fn ap_ind(str: *const ::libc::c_char, c: ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Search a string from right to left for the first occurrence of a
/// specific character
/// @param str The string to search
/// @param c The character to search for
/// @return The index of the first occurrence of c in str
    pub fn ap_rind(str: *const ::libc::c_char, c: ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Given a string, replace any bare " with \" .
/// @param p The pool to allocate memory from
/// @param instring The string to search for "
/// @return A copy of the string with escaped quotes
    pub fn ap_escape_quotes(p: *mut apr_pool_t, instring: *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Given a string, append the PID deliminated by delim.
/// Usually used to create a pid-appended filepath name
/// (eg: /a/b/foo -> /a/b/foo.6726). A function, and not
/// a macro, to avoid unistd.h dependency
/// @param p The pool to allocate memory from
/// @param string The string to append the PID to
/// @param delim The string to use to deliminate the string from the PID
/// @return A copy of the string with the PID appended
    pub fn ap_append_pid(p: *mut apr_pool_t, string: *const ::libc::c_char, delim: *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Parse a given timeout parameter string into an apr_interval_time_t value.
/// The unit of the time interval is given as postfix string to the numeric
/// string. Currently the following units are understood:
///
/// ms    : milliseconds
/// s     : seconds
/// mi[n] : minutes
/// h     : hours
///
/// If no unit is contained in the given timeout parameter the default_time_unit
/// will be used instead.
/// @param timeout_parameter The string containing the timeout parameter.
/// @param timeout The timeout value to be returned.
/// @param default_time_unit The default time unit to use if none is specified
/// in timeout_parameter.
/// @return Status value indicating whether the parsing was successful or not.
    pub fn ap_timeout_parameter_parse(timeout_parameter: *const ::libc::c_char, timeout: *mut apr_interval_time_t, default_time_unit: *const ::libc::c_char) -> apr_status_t;
}

extern "C" {
    /// Given the name of an object in the file system determine if it is a directory
/// @param p The pool to allocate from
/// @param name The name of the object to check
/// @return 1 if it is a directory, 0 otherwise
    pub fn ap_is_rdirectory(p: *mut apr_pool_t, name: *const ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Given the name of an object in the file system determine if it is a directory - this version is symlink aware
/// @param p The pool to allocate from
/// @param name The name of the object to check
/// @return 1 if it is a directory, 0 otherwise
    pub fn ap_is_directory(p: *mut apr_pool_t, name: *const ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Determine the local host name for the current machine
/// @param p The pool to allocate from
/// @return A copy of the local host name
    pub fn ap_get_local_host(p: *mut apr_pool_t) -> *mut ::libc::c_char;
}

extern "C" {
    /// Log an assertion to the error log
/// @param szExp The assertion that failed
/// @param szFile The file the assertion is in
/// @param nLine The line the assertion is defined on
    pub fn ap_log_assert(szExp: *const ::libc::c_char, szFile: *const ::libc::c_char, nLine: ::libc::c_int);
}

extern "C" {
    /// @} */
/// /**
/// Get HTML describing the address and (optionally) admin of the server.
/// @param prefix Text which is prepended to the return value
/// @param r The request_rec
/// @return HTML describing the server, allocated in @a r's pool.
    pub fn ap_psignature(prefix: *const ::libc::c_char, r: *mut request_rec) -> *const ::libc::c_char;
}

extern "C" {
    /// Short function to execute a command and return the first line of
/// output minus \r \n. Useful for "obscuring" passwords via exec calls
/// @param p the pool to allocate from
/// @param cmd the command to execute
/// @param argv the arguments to pass to the cmd
/// @return ptr to characters or NULL on any error
    pub fn ap_get_exec_line(p: *mut apr_pool_t, cmd: *const ::libc::c_char, argv: *const *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" { pub fn ap_strchr(s: *mut ::libc::c_char, c: ::libc::c_int) -> *mut ::libc::c_char; }

extern "C" { pub fn ap_strchr_c(s: *const ::libc::c_char, c: ::libc::c_int) -> *const ::libc::c_char; }

extern "C" { pub fn ap_strrchr(s: *mut ::libc::c_char, c: ::libc::c_int) -> *mut ::libc::c_char; }

extern "C" { pub fn ap_strrchr_c(s: *const ::libc::c_char, c: ::libc::c_int) -> *const ::libc::c_char; }

extern "C" { pub fn ap_strstr(s: *mut ::libc::c_char, c: *const ::libc::c_char) -> *mut ::libc::c_char; }

extern "C" { pub fn ap_strstr_c(s: *const ::libc::c_char, c: *const ::libc::c_char) -> *const ::libc::c_char; }

/// @brief Structure used to build the config tree.
///
/// The config tree only stores
/// the directives that will be active in the running server.  Directives
/// that contain other directions, such as <Directory ...> cause a sub-level
/// to be created, where the included directives are stored.  The closing
/// directive (</Directory>) is not stored in the tree.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_directive_t {
    /// The current directive
    pub directive: *const ::libc::c_char,
    /// The arguments for the current directive, stored as a space
    /// separated list
    pub args: *const ::libc::c_char,
    /// The next directive node in the tree
    /// @defvar ap_directive_t *next
    pub next: *mut ap_directive_t,
    /// The first child node of this directive
    /// @defvar ap_directive_t *first_child
    pub first_child: *mut ap_directive_t,
    /// The parent node of this directive
    /// @defvar ap_directive_t *parent
    pub parent: *mut ap_directive_t,
    /// directive's module can store add'l data here
    pub data: *mut ::libc::c_void,
    /// The name of the file this directive was found in
    pub filename: *const ::libc::c_char,
    /// The line number the directive was on
    pub line_num: ::libc::c_int,
}

#[test]
fn bindgen_test_layout_ap_directive_t() {
    assert_eq!(::std::mem::size_of::<ap_directive_t>(), 64usize, concat!( "Size of: " , stringify ! ( ap_directive_t ) ));
    assert_eq!(::std::mem::align_of::<ap_directive_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_directive_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_directive_t>())).directive as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_directive_t ) , "::" , stringify ! ( directive ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_directive_t>())).args as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_directive_t ) , "::" , stringify ! ( args ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_directive_t>())).next as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_directive_t ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_directive_t>())).first_child as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_directive_t ) , "::" , stringify ! ( first_child ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_directive_t>())).parent as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_directive_t ) , "::" , stringify ! ( parent ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_directive_t>())).data as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( ap_directive_t ) , "::" , stringify ! ( data ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_directive_t>())).filename as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( ap_directive_t ) , "::" , stringify ! ( filename ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_directive_t>())).line_num as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( ap_directive_t ) , "::" , stringify ! ( line_num ) ));
}

extern "C" {
    #[link_name = "\u{1}ap_conftree"]
    pub static mut ap_conftree: *mut ap_directive_t;
}

extern "C" {
    /// Add a node to the configuration tree.
/// @param parent The current parent node.  If the added node is a first_child,
/// then this is changed to the current node
/// @param current The current node
/// @param toadd The node to add to the tree
/// @param child Is the node to add a child node
/// @return the added node
    pub fn ap_add_node(parent: *mut *mut ap_directive_t, current: *mut ap_directive_t, toadd: *mut ap_directive_t, child: ::libc::c_int) -> *mut ap_directive_t;
}

/// < cmd_func parses command line itself
pub const cmd_how_RAW_ARGS: cmd_how = 0;
/// < one argument only
pub const cmd_how_TAKE1: cmd_how = 1;
/// < two arguments only
pub const cmd_how_TAKE2: cmd_how = 2;
/// < one argument, occuring multiple times
/// (e.g., IndexIgnore)
pub const cmd_how_ITERATE: cmd_how = 3;
/// < two arguments, 2nd occurs multiple times
/// (e.g., AddIcon)
pub const cmd_how_ITERATE2: cmd_how = 4;
/// < One of 'On' or 'Off'
pub const cmd_how_FLAG: cmd_how = 5;
/// < No args at all, e.g. </Directory>
pub const cmd_how_NO_ARGS: cmd_how = 6;
/// < one or two arguments
pub const cmd_how_TAKE12: cmd_how = 7;
/// < three arguments only
pub const cmd_how_TAKE3: cmd_how = 8;
/// < two or three arguments
pub const cmd_how_TAKE23: cmd_how = 9;
/// < one, two or three arguments
pub const cmd_how_TAKE123: cmd_how = 10;
/// < one or three arguments
pub const cmd_how_TAKE13: cmd_how = 11;
/// < an argc and argv are passed
pub const cmd_how_TAKE_ARGV: cmd_how = 12;

/// How the directives arguments should be parsed.
/// @remark Note that for all of these except RAW_ARGS, the config routine is
/// passed a freshly allocated string which can be modified or stored
/// or whatever...
pub type cmd_how = u32;
/// This structure is passed to a command which is being invoked,
/// to carry a large variety of miscellaneous data which is all of
/// use to *somebody*...
pub type cmd_parms = cmd_parms_struct;

/// All the types of functions that can be used in directives
/// @internal
#[repr(C)]
#[derive(Copy, Clone)]
pub union cmd_func {
    /// function to call for a no-args
    pub no_args: ::std::option::Option<unsafe extern "C" fn(parms: *mut cmd_parms, mconfig: *mut ::libc::c_void) -> *const ::libc::c_char>,
    /// function to call for a raw-args
    pub raw_args: ::std::option::Option<unsafe extern "C" fn(parms: *mut cmd_parms, mconfig: *mut ::libc::c_void, args: *const ::libc::c_char) -> *const ::libc::c_char>,
    /// function to call for a argv/argc
    pub take_argv: ::std::option::Option<unsafe extern "C" fn(parms: *mut cmd_parms, mconfig: *mut ::libc::c_void, argc: ::libc::c_int, argv: *const *const ::libc::c_char) -> *const ::libc::c_char>,
    /// function to call for a take1
    pub take1: ::std::option::Option<unsafe extern "C" fn(parms: *mut cmd_parms, mconfig: *mut ::libc::c_void, w: *const ::libc::c_char) -> *const ::libc::c_char>,
    /// function to call for a take2
    pub take2: ::std::option::Option<unsafe extern "C" fn(parms: *mut cmd_parms, mconfig: *mut ::libc::c_void, w: *const ::libc::c_char, w2: *const ::libc::c_char) -> *const ::libc::c_char>,
    /// function to call for a take3
    pub take3: ::std::option::Option<unsafe extern "C" fn(parms: *mut cmd_parms, mconfig: *mut ::libc::c_void, w: *const ::libc::c_char, w2: *const ::libc::c_char, w3: *const ::libc::c_char) -> *const ::libc::c_char>,
    /// function to call for a flag
    pub flag: ::std::option::Option<unsafe extern "C" fn(parms: *mut cmd_parms, mconfig: *mut ::libc::c_void, on: ::libc::c_int) -> *const ::libc::c_char>,
    _bindgen_union_align: u64,
}

#[test]
fn bindgen_test_layout_cmd_func() {
    assert_eq!(::std::mem::size_of::<cmd_func>(), 8usize, concat!( "Size of: " , stringify ! ( cmd_func ) ));
    assert_eq!(::std::mem::align_of::<cmd_func>(), 8usize, concat!( "Alignment of " , stringify ! ( cmd_func ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_func>())).no_args as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( cmd_func ) , "::" , stringify ! ( no_args ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_func>())).raw_args as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( cmd_func ) , "::" , stringify ! ( raw_args ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_func>())).take_argv as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( cmd_func ) , "::" , stringify ! ( take_argv ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_func>())).take1 as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( cmd_func ) , "::" , stringify ! ( take1 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_func>())).take2 as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( cmd_func ) , "::" , stringify ! ( take2 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_func>())).take3 as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( cmd_func ) , "::" , stringify ! ( take3 ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_func>())).flag as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( cmd_func ) , "::" , stringify ! ( flag ) ));
}

/// The command record structure.  Each modules can define a table of these
/// to define the directives it will implement.
pub type command_rec = command_struct;

#[repr(C)]
#[derive(Copy, Clone)]
pub struct command_struct {
    /// Name of this command
    pub name: *const ::libc::c_char,
    /// The function to be called when this directive is parsed
    pub func: cmd_func,
    /// Extra data, for functions which implement multiple commands...
    pub cmd_data: *mut ::libc::c_void,
    /// What overrides need to be allowed to enable this command.
    pub req_override: ::libc::c_int,
    /// What the command expects as arguments
    /// @defvar cmd_how args_how
    pub args_how: cmd_how,
    /// 'usage' message, in case of syntax errors
    pub errmsg: *const ::libc::c_char,
}

#[test]
fn bindgen_test_layout_command_struct() {
    assert_eq!(::std::mem::size_of::<command_struct>(), 40usize, concat!( "Size of: " , stringify ! ( command_struct ) ));
    assert_eq!(::std::mem::align_of::<command_struct>(), 8usize, concat!( "Alignment of " , stringify ! ( command_struct ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<command_struct>())).name as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( command_struct ) , "::" , stringify ! ( name ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<command_struct>())).func as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( command_struct ) , "::" , stringify ! ( func ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<command_struct>())).cmd_data as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( command_struct ) , "::" , stringify ! ( cmd_data ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<command_struct>())).req_override as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( command_struct ) , "::" , stringify ! ( req_override ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<command_struct>())).args_how as *const _ as usize }, 28usize, concat!( "Offset of field: " , stringify ! ( command_struct ) , "::" , stringify ! ( args_how ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<command_struct>())).errmsg as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( command_struct ) , "::" , stringify ! ( errmsg ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_configfile_t {
    /// < a getc()-like function
    pub getch: ::std::option::Option<unsafe extern "C" fn(param: *mut ::libc::c_void) -> ::libc::c_int>,
    pub getstr: ::std::option::Option<unsafe extern "C" fn(buf: *mut ::libc::c_void, bufsiz: usize, param: *mut ::libc::c_void) -> *mut ::libc::c_void>,
    /// < a close handler function
    pub close: ::std::option::Option<unsafe extern "C" fn(param: *mut ::libc::c_void) -> ::libc::c_int>,
    /// < the argument passed to getch/getstr/close
    pub param: *mut ::libc::c_void,
    /// < the filename / description
    pub name: *const ::libc::c_char,
    /// < current line number, starting at 1
    pub line_number: ::libc::c_uint,
}

#[test]
fn bindgen_test_layout_ap_configfile_t() {
    assert_eq!(::std::mem::size_of::<ap_configfile_t>(), 48usize, concat!( "Size of: " , stringify ! ( ap_configfile_t ) ));
    assert_eq!(::std::mem::align_of::<ap_configfile_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_configfile_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_configfile_t>())).getch as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_configfile_t ) , "::" , stringify ! ( getch ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_configfile_t>())).getstr as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_configfile_t ) , "::" , stringify ! ( getstr ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_configfile_t>())).close as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_configfile_t ) , "::" , stringify ! ( close ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_configfile_t>())).param as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_configfile_t ) , "::" , stringify ! ( param ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_configfile_t>())).name as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_configfile_t ) , "::" , stringify ! ( name ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_configfile_t>())).line_number as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( ap_configfile_t ) , "::" , stringify ! ( line_number ) ));
}

/// This structure is passed to a command which is being invoked,
/// to carry a large variety of miscellaneous data which is all of
/// use to *somebody*...
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_parms_struct {
    /// Argument to command from cmd_table
    pub info: *mut ::libc::c_void,
    /// Which allow-override bits are set
    pub override_: ::libc::c_int,
    /// Which methods are <Limit>ed
    pub limited: apr_int64_t,
    /// methods which are limited
    pub limited_xmethods: *mut apr_array_header_t,
    /// methods which are xlimited
    pub xlimited: *mut ap_method_list_t,
    /// Config file structure.
    pub config_file: *mut ap_configfile_t,
    /// the directive specifying this command
    pub directive: *mut ap_directive_t,
    /// Pool to allocate new storage in
    pub pool: *mut apr_pool_t,
    /// Pool for scratch memory; persists during configuration, but
    /// wiped before the first request is served...
    pub temp_pool: *mut apr_pool_t,
    /// Server_rec being configured for
    pub server: *mut server_rec,
    /// If configuring for a directory, pathname of that directory.
    /// NOPE!  That's what it meant previous to the existance of <Files>,
    /// <Location> and regex matching.  Now the only usefulness that can be
    /// derived from this field is whether a command is being called in a
    /// server context (path == NULL) or being called in a dir context
    /// (path != NULL).
    pub path: *mut ::libc::c_char,
    /// configuration command
    pub cmd: *const command_rec,
    /// per_dir_config vector passed to handle_command
    pub context: *mut ap_conf_vector_t,
    /// directive with syntax error
    pub err_directive: *const ap_directive_t,
    /// Which allow-override-opts bits are set
    pub override_opts: ::libc::c_int,
}

#[test]
fn bindgen_test_layout_cmd_parms_struct() {
    assert_eq!(::std::mem::size_of::<cmd_parms_struct>(), 120usize, concat!( "Size of: " , stringify ! ( cmd_parms_struct ) ));
    assert_eq!(::std::mem::align_of::<cmd_parms_struct>(), 8usize, concat!( "Alignment of " , stringify ! ( cmd_parms_struct ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).info as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( info ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).override_ as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( override_ ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).limited as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( limited ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).limited_xmethods as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( limited_xmethods ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).xlimited as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( xlimited ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).config_file as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( config_file ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).directive as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( directive ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).pool as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).temp_pool as *const _ as usize }, 64usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( temp_pool ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).server as *const _ as usize }, 72usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( server ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).path as *const _ as usize }, 80usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( path ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).cmd as *const _ as usize }, 88usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( cmd ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).context as *const _ as usize }, 96usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( context ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).err_directive as *const _ as usize }, 104usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( err_directive ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<cmd_parms_struct>())).override_opts as *const _ as usize }, 112usize, concat!( "Offset of field: " , stringify ! ( cmd_parms_struct ) , "::" , stringify ! ( override_opts ) ));
}

/// Module structures.  Just about everything is dispatched through
/// these, directly or indirectly (through the command and handler
/// tables).
pub type module = module_struct;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module_struct {
    /// API version, *not* module version; check that module is
    /// compatible with this version of the server.
    pub version: ::libc::c_int,
    /// API minor version. Provides API feature milestones. Not checked
    /// during module init
    pub minor_version: ::libc::c_int,
    /// Index to this modules structures in config vectors.
    pub module_index: ::libc::c_int,
    /// The name of the module's C file
    pub name: *const ::libc::c_char,
    /// The handle for the DSO.  Internal use only
    pub dynamic_load_handle: *mut ::libc::c_void,
    /// A pointer to the next module in the list
    /// @defvar module_struct *next
    pub next: *mut module_struct,
    /// Magic Cookie to identify a module structure;  It's mainly
    /// important for the DSO facility (see also mod_so).
    pub magic: ::libc::c_ulong,
    /// Function to allow MPMs to re-write command line arguments.  This
    /// hook is only available to MPMs.
    /// @param The process that the server is running in.
    pub rewrite_args: ::std::option::Option<unsafe extern "C" fn(process: *mut process_rec)>,
    /// Function to allow all modules to create per directory configuration
    /// structures.
    /// @param p The pool to use for all allocations.
    /// @param dir The directory currently being processed.
    /// @return The per-directory structure created
    pub create_dir_config: ::std::option::Option<unsafe extern "C" fn(p: *mut apr_pool_t, dir: *mut ::libc::c_char) -> *mut ::libc::c_void>,
    /// Function to allow all modules to merge the per directory configuration
    /// structures for two directories.
    /// @param p The pool to use for all allocations.
    /// @param base_conf The directory structure created for the parent directory.
    /// @param new_conf The directory structure currently being processed.
    /// @return The new per-directory structure created
    pub merge_dir_config: ::std::option::Option<unsafe extern "C" fn(p: *mut apr_pool_t, base_conf: *mut ::libc::c_void, new_conf: *mut ::libc::c_void) -> *mut ::libc::c_void>,
    /// Function to allow all modules to create per server configuration
    /// structures.
    /// @param p The pool to use for all allocations.
    /// @param s The server currently being processed.
    /// @return The per-server structure created
    pub create_server_config: ::std::option::Option<unsafe extern "C" fn(p: *mut apr_pool_t, s: *mut server_rec) -> *mut ::libc::c_void>,
    /// Function to allow all modules to merge the per server configuration
    /// structures for two servers.
    /// @param p The pool to use for all allocations.
    /// @param base_conf The directory structure created for the parent directory.
    /// @param new_conf The directory structure currently being processed.
    /// @return The new per-directory structure created
    pub merge_server_config: ::std::option::Option<unsafe extern "C" fn(p: *mut apr_pool_t, base_conf: *mut ::libc::c_void, new_conf: *mut ::libc::c_void) -> *mut ::libc::c_void>,
    /// A command_rec table that describes all of the directives this module
    /// defines.
    pub cmds: *const command_rec,
    /// A hook to allow modules to hook other points in the request processing.
    /// In this function, modules should call the ap_hook_*() functions to
    /// register an interest in a specific step in processing the current
    /// request.
    /// @param p the pool to use for all allocations
    pub register_hooks: ::std::option::Option<unsafe extern "C" fn(p: *mut apr_pool_t)>,
}

#[test]
fn bindgen_test_layout_module_struct() {
    assert_eq!(::std::mem::size_of::<module_struct>(), 104usize, concat!( "Size of: " , stringify ! ( module_struct ) ));
    assert_eq!(::std::mem::align_of::<module_struct>(), 8usize, concat!( "Alignment of " , stringify ! ( module_struct ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).version as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( version ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).minor_version as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( minor_version ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).module_index as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( module_index ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).name as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( name ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).dynamic_load_handle as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( dynamic_load_handle ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).next as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).magic as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( magic ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).rewrite_args as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( rewrite_args ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).create_dir_config as *const _ as usize }, 56usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( create_dir_config ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).merge_dir_config as *const _ as usize }, 64usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( merge_dir_config ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).create_server_config as *const _ as usize }, 72usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( create_server_config ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).merge_server_config as *const _ as usize }, 80usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( merge_server_config ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).cmds as *const _ as usize }, 88usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( cmds ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<module_struct>())).register_hooks as *const _ as usize }, 96usize, concat!( "Offset of field: " , stringify ! ( module_struct ) , "::" , stringify ! ( register_hooks ) ));
}

extern "C" {
    /// Generic accessors for other modules to get at their own module-specific
/// data
/// @param conf_vector The vector in which the modules configuration is stored.
/// usually r->per_dir_config or s->module_config
/// @param m The module to get the data for.
/// @return The module-specific data
    pub fn ap_get_module_config(cv: *const ap_conf_vector_t, m: *const module) -> *mut ::libc::c_void;
}

extern "C" {
    /// Generic accessors for other modules to set at their own module-specific
/// data
/// @param conf_vector The vector in which the modules configuration is stored.
/// usually r->per_dir_config or s->module_config
/// @param m The module to set the data for.
/// @param val The module-specific data to set
    pub fn ap_set_module_config(cv: *mut ap_conf_vector_t, m: *const module, val: *mut ::libc::c_void);
}

extern "C" {
    /// Generic command handling function for strings
/// @param cmd The command parameters for this directive
/// @param struct_ptr pointer into a given type
/// @param arg The argument to the directive
/// @return An error string or NULL on success
    pub fn ap_set_string_slot(cmd: *mut cmd_parms, struct_ptr: *mut ::libc::c_void, arg: *const ::libc::c_char) -> *const ::libc::c_char;
}

extern "C" {
    /// Generic command handling function for integers
/// @param cmd The command parameters for this directive
/// @param struct_ptr pointer into a given type
/// @param arg The argument to the directive
/// @return An error string or NULL on success
    pub fn ap_set_int_slot(cmd: *mut cmd_parms, struct_ptr: *mut ::libc::c_void, arg: *const ::libc::c_char) -> *const ::libc::c_char;
}

extern "C" {
    /// Return true if the specified method is limited by being listed in
/// a <Limit> container, or by *not* being listed in a <LimiteExcept>
/// container.
///
/// @param   method  Pointer to a string specifying the method to check.
/// @param   cmd     Pointer to the cmd_parms structure passed to the
/// directive handler.
/// @return  0 if the method is not limited in the current scope
    pub fn ap_method_is_limited(cmd: *mut cmd_parms, method: *const ::libc::c_char) -> ::libc::c_int;
}

extern "C" {
    /// Generic command handling function for strings, always sets the value
/// to a lowercase string
/// @param cmd The command parameters for this directive
/// @param struct_ptr pointer into a given type
/// @param arg The argument to the directive
/// @return An error string or NULL on success
    pub fn ap_set_string_slot_lower(cmd: *mut cmd_parms, struct_ptr: *mut ::libc::c_void, arg: *const ::libc::c_char) -> *const ::libc::c_char;
}

extern "C" {
    /// Generic command handling function for flags
/// @param cmd The command parameters for this directive
/// @param struct_ptr pointer into a given type
/// @param arg The argument to the directive (either 1 or 0)
/// @return An error string or NULL on success
    pub fn ap_set_flag_slot(cmd: *mut cmd_parms, struct_ptr: *mut ::libc::c_void, arg: ::libc::c_int) -> *const ::libc::c_char;
}

extern "C" {
    /// Generic command handling function for files
/// @param cmd The command parameters for this directive
/// @param struct_ptr pointer into a given type
/// @param arg The argument to the directive
/// @return An error string or NULL on success
    pub fn ap_set_file_slot(cmd: *mut cmd_parms, struct_ptr: *mut ::libc::c_void, arg: *const ::libc::c_char) -> *const ::libc::c_char;
}

extern "C" {
    /// Generic command handling function to respond with cmd->help as an error
/// @param cmd The command parameters for this directive
/// @param struct_ptr pointer into a given type
/// @param arg The argument to the directive
/// @return The cmd->help value as the error string
/// @tip This allows simple declarations such as;
/// <pre>
/// AP_INIT_RAW_ARGS("Foo", ap_set_deprecated, NULL, OR_ALL,
/// "The Foo directive is no longer supported, use Bar"),
/// </pre>
    pub fn ap_set_deprecated(cmd: *mut cmd_parms, struct_ptr: *mut ::libc::c_void, arg: *const ::libc::c_char) -> *const ::libc::c_char;
}

extern "C" {
    /// For modules which need to read config files, open logs, etc. this returns
/// the canonical form of fname made absolute to ap_server_root.
/// @param p pool to allocate data from
/// @param fname The file name
    pub fn ap_server_root_relative(p: *mut apr_pool_t, fname: *const ::libc::c_char) -> *mut ::libc::c_char;
}

extern "C" {
    /// Add a module to the server
/// @param m The module structure of the module to add
/// @param p The pool of the same lifetime as the module
    pub fn ap_add_module(m: *mut module, p: *mut apr_pool_t) -> *const ::libc::c_char;
}

extern "C" {
    /// Remove a module from the server.  There are some caveats:
/// when the module is removed, its slot is lost so all the current
/// per-dir and per-server configurations are invalid. So we should
/// only ever call this function when you are invalidating almost
/// all our current data. I.e. when doing a restart.
/// @param m the module structure of the module to remove
    pub fn ap_remove_module(m: *mut module);
}

extern "C" {
    /// Add a module to the chained modules list and the list of loaded modules
/// @param m The module structure of the module to add
/// @param p The pool with the same lifetime as the module
    pub fn ap_add_loaded_module(mod_: *mut module, p: *mut apr_pool_t) -> *const ::libc::c_char;
}

extern "C" {
    /// Remove a module fromthe chained modules list and the list of loaded modules
/// @param m the module structure of the module to remove
    pub fn ap_remove_loaded_module(mod_: *mut module);
}

extern "C" {
    /// Find the name of the specified module
/// @param m The module to get the name for
/// @return the name of the module
    pub fn ap_find_module_name(m: *mut module) -> *const ::libc::c_char;
}

extern "C" {
    /// Find a module based on the name of the module
/// @param name the name of the module
/// @return the module structure if found, NULL otherwise
    pub fn ap_find_linked_module(name: *const ::libc::c_char) -> *mut module;
}

extern "C" {
    /// Open a ap_configfile_t as apr_file_t
/// @param ret_cfg open ap_configfile_t struct pointer
/// @param p The pool to allocate the structure from
/// @param name the name of the file to open
    pub fn ap_pcfg_openfile(ret_cfg: *mut *mut ap_configfile_t, p: *mut apr_pool_t, name: *const ::libc::c_char) -> apr_status_t;
}

extern "C" {
    /// Allocate a ap_configfile_t handle with user defined functions and params
/// @param p The pool to allocate from
/// @param descr The name of the file
/// @param param The argument passed to getch/getstr/close
/// @param getc_func The getch function
/// @param gets_func The getstr function
/// @param close_func The close function
    pub fn ap_pcfg_open_custom(p: *mut apr_pool_t, descr: *const ::libc::c_char, param_: *mut ::libc::c_void, getc_func: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void) -> ::libc::c_int>, gets_func: ::std::option::Option<unsafe extern "C" fn(buf: *mut ::libc::c_void, bufsiz: usize, param: *mut ::libc::c_void) -> *mut ::libc::c_void>, close_func: ::std::option::Option<unsafe extern "C" fn(param: *mut ::libc::c_void) -> ::libc::c_int>) -> *mut ap_configfile_t;
}

extern "C" {
    /// Read one line from open ap_configfile_t, strip LF, increase line number
/// @param buf place to store the line read
/// @param bufsize size of the buffer
/// @param cfp File to read from
/// @return 1 on success, 0 on failure
    pub fn ap_cfg_getline(buf: *mut ::libc::c_char, bufsize: usize, cfp: *mut ap_configfile_t) -> ::libc::c_int;
}

extern "C" {
    /// Read one char from open configfile_t, increase line number upon LF
/// @param cfp The file to read from
/// @return the character read
    pub fn ap_cfg_getc(cfp: *mut ap_configfile_t) -> ::libc::c_int;
}

extern "C" {
    /// Detach from open ap_configfile_t, calling the close handler
/// @param cfp The file to close
/// @return 1 on sucess, 0 on failure
    pub fn ap_cfg_closefile(cfp: *mut ap_configfile_t) -> ::libc::c_int;
}

extern "C" {
    /// Read all data between the current <foo> and the matching </foo>.  All
/// of this data is forgotten immediately.
/// @param cmd The cmd_parms to pass to the directives inside the container
/// @param directive The directive name to read until
/// @return Error string on failure, NULL on success
    pub fn ap_soak_end_container(cmd: *mut cmd_parms, directive: *mut ::libc::c_char) -> *const ::libc::c_char;
}

extern "C" {
    /// Read all data between the current <foo> and the matching </foo> and build
/// a config tree from it
/// @param p pool to allocate from
/// @param temp_pool Temporary pool to allocate from
/// @param parms The cmd_parms to pass to all directives read
/// @param current The current node in the tree
/// @param curr_parent The current parent node
/// @param orig_directive The directive to read until hit.
/// @return Error string on failure, NULL on success
    pub fn ap_build_cont_config(p: *mut apr_pool_t, temp_pool: *mut apr_pool_t, parms: *mut cmd_parms, current: *mut *mut ap_directive_t, curr_parent: *mut *mut ap_directive_t, orig_directive: *mut ::libc::c_char) -> *const ::libc::c_char;
}

extern "C" {
    /// Build a config tree from a config file
/// @param parms The cmd_parms to pass to all of the directives in the file
/// @param conf_pool The pconf pool
/// @param temp_pool The temporary pool
/// @param conftree Place to store the root node of the config tree
/// @return Error string on erro, NULL otherwise
    pub fn ap_build_config(parms: *mut cmd_parms, conf_pool: *mut apr_pool_t, temp_pool: *mut apr_pool_t, conftree: *mut *mut ap_directive_t) -> *const ::libc::c_char;
}

extern "C" {
    /// Walk a config tree and setup the server's internal structures
/// @param conftree The config tree to walk
/// @param parms The cmd_parms to pass to all functions
/// @param section_vector The per-section config vector.
/// @return Error string on error, NULL otherwise
    pub fn ap_walk_config(conftree: *mut ap_directive_t, parms: *mut cmd_parms, section_vector: *mut ap_conf_vector_t) -> *const ::libc::c_char;
}

extern "C" {
    /// @defgroup ap_check_cmd_context Check command context
/// @{
/// /
/// /**
/// Check the context a command is used in.
/// @param cmd The command to check
/// @param forbidden Where the command is forbidden.
/// @return Error string on error, NULL on success
    pub fn ap_check_cmd_context(cmd: *mut cmd_parms, forbidden: ::libc::c_uint) -> *const ::libc::c_char;
}

pub type ap_HOOK_header_parser_t = ::std::option::Option<unsafe extern "C" fn(r: *mut request_rec) -> ::libc::c_int>;

extern "C" { pub fn ap_hook_header_parser(pf: ap_HOOK_header_parser_t, aszPre: *const *const ::libc::c_char, aszSucc: *const *const ::libc::c_char, nOrder: ::libc::c_int); }

extern "C" { pub fn ap_run_header_parser(r: *mut request_rec) -> ::libc::c_int; }

extern "C" { pub fn ap_hook_get_header_parser() -> *mut apr_array_header_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_header_parser_t { pub pFunc: ap_HOOK_header_parser_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_header_parser_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_header_parser_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_header_parser_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_header_parser_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_header_parser_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_header_parser_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_header_parser_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_header_parser_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_header_parser_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_header_parser_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_header_parser_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_header_parser_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_header_parser_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_header_parser_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_header_parser_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_pre_config_t = ::std::option::Option<unsafe extern "C" fn(pconf: *mut apr_pool_t, plog: *mut apr_pool_t, ptemp: *mut apr_pool_t) -> ::libc::c_int>;

extern "C" { pub fn ap_hook_pre_config(pf: ap_HOOK_pre_config_t, aszPre: *const *const ::libc::c_char, aszSucc: *const *const ::libc::c_char, nOrder: ::libc::c_int); }

extern "C" { pub fn ap_run_pre_config(pconf: *mut apr_pool_t, plog: *mut apr_pool_t, ptemp: *mut apr_pool_t) -> ::libc::c_int; }

extern "C" { pub fn ap_hook_get_pre_config() -> *mut apr_array_header_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_pre_config_t { pub pFunc: ap_HOOK_pre_config_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_pre_config_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_pre_config_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_pre_config_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_pre_config_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_pre_config_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_pre_config_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_pre_config_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_pre_config_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_pre_config_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_pre_config_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_pre_config_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_pre_config_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_pre_config_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_pre_config_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_pre_config_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_test_config_t = ::std::option::Option<unsafe extern "C" fn(pconf: *mut apr_pool_t, s: *mut server_rec)>;

extern "C" { pub fn ap_hook_test_config(pf: ap_HOOK_test_config_t, aszPre: *const *const ::libc::c_char, aszSucc: *const *const ::libc::c_char, nOrder: ::libc::c_int); }

extern "C" { pub fn ap_run_test_config(pconf: *mut apr_pool_t, s: *mut server_rec); }

extern "C" { pub fn ap_hook_get_test_config() -> *mut apr_array_header_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_test_config_t { pub pFunc: ap_HOOK_test_config_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_test_config_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_test_config_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_test_config_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_test_config_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_test_config_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_test_config_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_test_config_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_test_config_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_test_config_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_test_config_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_test_config_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_test_config_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_test_config_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_test_config_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_test_config_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_post_config_t = ::std::option::Option<unsafe extern "C" fn(pconf: *mut apr_pool_t, plog: *mut apr_pool_t, ptemp: *mut apr_pool_t, s: *mut server_rec) -> ::libc::c_int>;

extern "C" { pub fn ap_hook_post_config(pf: ap_HOOK_post_config_t, aszPre: *const *const ::libc::c_char, aszSucc: *const *const ::libc::c_char, nOrder: ::libc::c_int); }

extern "C" { pub fn ap_run_post_config(pconf: *mut apr_pool_t, plog: *mut apr_pool_t, ptemp: *mut apr_pool_t, s: *mut server_rec) -> ::libc::c_int; }

extern "C" { pub fn ap_hook_get_post_config() -> *mut apr_array_header_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_post_config_t { pub pFunc: ap_HOOK_post_config_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_post_config_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_post_config_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_post_config_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_post_config_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_post_config_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_post_config_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_post_config_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_post_config_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_post_config_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_post_config_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_post_config_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_post_config_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_post_config_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_post_config_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_post_config_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_open_logs_t = ::std::option::Option<unsafe extern "C" fn(pconf: *mut apr_pool_t, plog: *mut apr_pool_t, ptemp: *mut apr_pool_t, s: *mut server_rec) -> ::libc::c_int>;

extern "C" { pub fn ap_hook_open_logs(pf: ap_HOOK_open_logs_t, aszPre: *const *const ::libc::c_char, aszSucc: *const *const ::libc::c_char, nOrder: ::libc::c_int); }

extern "C" { pub fn ap_run_open_logs(pconf: *mut apr_pool_t, plog: *mut apr_pool_t, ptemp: *mut apr_pool_t, s: *mut server_rec) -> ::libc::c_int; }

extern "C" { pub fn ap_hook_get_open_logs() -> *mut apr_array_header_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_open_logs_t { pub pFunc: ap_HOOK_open_logs_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_open_logs_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_open_logs_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_open_logs_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_open_logs_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_open_logs_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_open_logs_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_open_logs_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_open_logs_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_open_logs_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_open_logs_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_open_logs_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_open_logs_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_open_logs_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_open_logs_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_open_logs_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_child_init_t = ::std::option::Option<unsafe extern "C" fn(pchild: *mut apr_pool_t, s: *mut server_rec)>;

extern "C" { pub fn ap_hook_child_init(pf: ap_HOOK_child_init_t, aszPre: *const *const ::libc::c_char, aszSucc: *const *const ::libc::c_char, nOrder: ::libc::c_int); }

extern "C" { pub fn ap_run_child_init(pchild: *mut apr_pool_t, s: *mut server_rec); }

extern "C" { pub fn ap_hook_get_child_init() -> *mut apr_array_header_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_child_init_t { pub pFunc: ap_HOOK_child_init_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_child_init_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_child_init_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_child_init_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_child_init_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_child_init_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_child_init_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_child_init_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_child_init_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_child_init_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_child_init_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_child_init_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_child_init_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_child_init_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_child_init_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_child_init_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_handler_t = ::std::option::Option<unsafe extern "C" fn(r: *mut request_rec) -> ::libc::c_int>;

extern "C" { pub fn ap_hook_handler(pf: ap_HOOK_handler_t, aszPre: *const *const ::libc::c_char, aszSucc: *const *const ::libc::c_char, nOrder: ::libc::c_int); }

extern "C" { pub fn ap_run_handler(r: *mut request_rec) -> ::libc::c_int; }

extern "C" { pub fn ap_hook_get_handler() -> *mut apr_array_header_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_handler_t { pub pFunc: ap_HOOK_handler_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_handler_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_handler_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_handler_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_handler_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_handler_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_handler_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_handler_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_handler_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_handler_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_handler_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_handler_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_handler_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_handler_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_handler_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_handler_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_quick_handler_t = ::std::option::Option<unsafe extern "C" fn(r: *mut request_rec, lookup_uri: ::libc::c_int) -> ::libc::c_int>;

extern "C" { pub fn ap_hook_quick_handler(pf: ap_HOOK_quick_handler_t, aszPre: *const *const ::libc::c_char, aszSucc: *const *const ::libc::c_char, nOrder: ::libc::c_int); }

extern "C" { pub fn ap_run_quick_handler(r: *mut request_rec, lookup_uri: ::libc::c_int) -> ::libc::c_int; }

extern "C" { pub fn ap_hook_get_quick_handler() -> *mut apr_array_header_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_quick_handler_t { pub pFunc: ap_HOOK_quick_handler_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_quick_handler_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_quick_handler_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_quick_handler_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_quick_handler_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_quick_handler_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_quick_handler_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_quick_handler_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_quick_handler_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_quick_handler_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_quick_handler_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_quick_handler_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_quick_handler_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_quick_handler_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_quick_handler_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_quick_handler_t ) , "::" , stringify ! ( nOrder ) ));
}

pub type ap_HOOK_optional_fn_retrieve_t = ::std::option::Option<unsafe extern "C" fn()>;

extern "C" { pub fn ap_hook_optional_fn_retrieve(pf: ap_HOOK_optional_fn_retrieve_t, aszPre: *const *const ::libc::c_char, aszSucc: *const *const ::libc::c_char, nOrder: ::libc::c_int); }

extern "C" { pub fn ap_run_optional_fn_retrieve(); }

extern "C" { pub fn ap_hook_get_optional_fn_retrieve() -> *mut apr_array_header_t; }

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_LINK_optional_fn_retrieve_t { pub pFunc: ap_HOOK_optional_fn_retrieve_t, pub szName: *const ::libc::c_char, pub aszPredecessors: *const *const ::libc::c_char, pub aszSuccessors: *const *const ::libc::c_char, pub nOrder: ::libc::c_int }

#[test]
fn bindgen_test_layout_ap_LINK_optional_fn_retrieve_t() {
    assert_eq!(::std::mem::size_of::<ap_LINK_optional_fn_retrieve_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_LINK_optional_fn_retrieve_t ) ));
    assert_eq!(::std::mem::align_of::<ap_LINK_optional_fn_retrieve_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_LINK_optional_fn_retrieve_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_optional_fn_retrieve_t>())).pFunc as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_optional_fn_retrieve_t ) , "::" , stringify ! ( pFunc ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_optional_fn_retrieve_t>())).szName as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_optional_fn_retrieve_t ) , "::" , stringify ! ( szName ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_optional_fn_retrieve_t>())).aszPredecessors as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_optional_fn_retrieve_t ) , "::" , stringify ! ( aszPredecessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_optional_fn_retrieve_t>())).aszSuccessors as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_optional_fn_retrieve_t ) , "::" , stringify ! ( aszSuccessors ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_LINK_optional_fn_retrieve_t>())).nOrder as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_LINK_optional_fn_retrieve_t ) , "::" , stringify ! ( nOrder ) ));
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data { pub _address: u8 }

pub type __builtin_va_list = [__va_list_tag; 1usize];

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag { pub gp_offset: ::libc::c_uint, pub fp_offset: ::libc::c_uint, pub overflow_arg_area: *mut ::libc::c_void, pub reg_save_area: *mut ::libc::c_void }

#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::std::mem::size_of::<__va_list_tag>(), 24usize, concat!( "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq!(::std::mem::align_of::<__va_list_tag>(), 8usize, concat!( "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( gp_offset ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize }, 4usize, concat!( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( fp_offset ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( overflow_arg_area ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( __va_list_tag ) , "::" , stringify ! ( reg_save_area ) ));
}

/// the configuration directives
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_conf_vector_t { pub _address: u8 }

/// structure returned from gethostbyname()
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hostent { pub _address: u8 }


/////////////////////////////
/// The filter should return at most readbytes data.
pub const ap_input_mode_t_AP_MODE_READBYTES: ap_input_mode_t = 0;
/// The filter should return at most one line of CRLF data.
/// (If a potential line is too long or no CRLF is found, the
/// filter may return partial data).
pub const ap_input_mode_t_AP_MODE_GETLINE: ap_input_mode_t = 1;
/// The filter should implicitly eat any CRLF pairs that it sees.
pub const ap_input_mode_t_AP_MODE_EATCRLF: ap_input_mode_t = 2;
/// The filter read should be treated as speculative and any returned
/// data should be stored for later retrieval in another mode.
pub const ap_input_mode_t_AP_MODE_SPECULATIVE: ap_input_mode_t = 3;
/// The filter read should be exhaustive and read until it can not
/// read any more.
/// Use this mode with extreme caution.
pub const ap_input_mode_t_AP_MODE_EXHAUSTIVE: ap_input_mode_t = 4;
/// The filter should initialize the connection if needed,
/// NNTP or FTP over SSL for example.
pub const ap_input_mode_t_AP_MODE_INIT: ap_input_mode_t = 5;

/// @brief input filtering modes
pub type ap_input_mode_t = u32;
/// @name Filter callbacks
///
/// This function type is used for filter callbacks. It will be passed a
/// pointer to "this" filter, and a "bucket" containing the content to be
/// filtered.
///
/// In filter->ctx, the callback will find its context. This context is
/// provided here, so that a filter may be installed multiple times, each
/// receiving its own per-install context pointer.
///
/// Callbacks are associated with a filter definition, which is specified
/// by name. See ap_register_input_filter() and ap_register_output_filter()
/// for setting the association between a name for a filter and its
/// associated callback (and other information).
///
/// If the initialization function argument passed to the registration
/// functions is non-NULL, it will be called iff the filter is in the input
/// or output filter chains and before any data is generated to allow the
/// filter to prepare for processing.
///
/// The *bucket structure (and all those referenced by ->next and ->prev)
/// should be considered "const". The filter is allowed to modify the
/// next/prev to insert/remove/replace elements in the bucket list, but
/// the types and values of the individual buckets should not be altered.
///
/// For the input and output filters, the return value of a filter should be
/// an APR status value.  For the init function, the return value should
/// be an HTTP error code or OK if it was successful.
///
/// @ingroup filter
/// @{
pub type ap_out_filter_func = ::std::option::Option<unsafe extern "C" fn(f: *mut ap_filter_t, b: *mut apr_bucket_brigade) -> apr_status_t>;
pub type ap_in_filter_func = ::std::option::Option<unsafe extern "C" fn(f: *mut ap_filter_t, b: *mut apr_bucket_brigade, mode: ap_input_mode_t, block: apr_read_type_e, readbytes: apr_off_t) -> apr_status_t>;
pub type ap_init_filter_func = ::std::option::Option<unsafe extern "C" fn(f: *mut ap_filter_t) -> ::libc::c_int>;

#[repr(C)]
#[derive(Copy, Clone)]
pub union ap_filter_func { pub out_func: ap_out_filter_func, pub in_func: ap_in_filter_func, _bindgen_union_align: u64 }

#[test]
fn bindgen_test_layout_ap_filter_func() {
    assert_eq!(::std::mem::size_of::<ap_filter_func>(), 8usize, concat!( "Size of: " , stringify ! ( ap_filter_func ) ));
    assert_eq!(::std::mem::align_of::<ap_filter_func>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_filter_func ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_func>())).out_func as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_filter_func ) , "::" , stringify ! ( out_func ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_func>())).in_func as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_filter_func ) , "::" , stringify ! ( in_func ) ));
}

/// These filters are used to alter the content that is passed through
/// them. Examples are SSI or PHP.
pub const ap_filter_type_AP_FTYPE_RESOURCE: ap_filter_type = 10;
/// These filters are used to alter the content as a whole, but after all
/// AP_FTYPE_RESOURCE filters are executed.  These filters should not
/// change the content-type.  An example is deflate.
pub const ap_filter_type_AP_FTYPE_CONTENT_SET: ap_filter_type = 20;
/// These filters are used to handle the protocol between server and
/// client.  Examples are HTTP and POP.
pub const ap_filter_type_AP_FTYPE_PROTOCOL: ap_filter_type = 30;
/// These filters implement transport encodings (e.g., chunking).
pub const ap_filter_type_AP_FTYPE_TRANSCODE: ap_filter_type = 40;
/// These filters will alter the content, but in ways that are
/// more strongly associated with the connection.  Examples are
/// splitting an HTTP connection into multiple requests and
/// buffering HTTP responses across multiple requests.
///
/// It is important to note that these types of filters are not
/// allowed in a sub-request. A sub-request's output can certainly
/// be filtered by ::AP_FTYPE_RESOURCE filters, but all of the "final
/// processing" is determined by the main request.
pub const ap_filter_type_AP_FTYPE_CONNECTION: ap_filter_type = 50;
/// These filters don't alter the content.  They are responsible for
/// sending/receiving data to/from the client.
pub const ap_filter_type_AP_FTYPE_NETWORK: ap_filter_type = 60;

/// Filters have different types/classifications. These are used to group
/// and sort the filters to properly sequence their operation.
///
/// The types have a particular sort order, which allows us to insert them
/// into the filter chain in a determistic order. Within a particular grouping,
/// the ordering is equivalent to the order of calls to ap_add_*_filter().
pub type ap_filter_type = u32;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_filter_provider_t { _unused: [u8; 0] }

/// @brief This structure is used for recording information about the
/// registered filters. It associates a name with the filter's callback
/// and filter type.
///
/// At the moment, these are simply linked in a chain, so a ->next pointer
/// is available.
///
/// It is used for any filter that can be inserted in the filter chain.
/// This may be either a httpd-2.0 filter or a mod_filter harness.
/// In the latter case it contains dispatch, provider and protocol information.
/// In the former case, the new fields (from dispatch) are ignored.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ap_filter_rec_t {
    /// The registered name for this filter
    pub name: *const ::libc::c_char,
    /// The function to call when this filter is invoked.
    pub filter_func: ap_filter_func,
    /// The function to call directly before the handlers are invoked
    /// for a request.  The init function is called once directly
    /// before running the handlers for a request or subrequest.  The
    /// init function is never called for a connection filter (with
    /// ftype >= AP_FTYPE_CONNECTION).  Any use of this function for
    /// filters for protocols other than HTTP is specified by the
    /// module supported that protocol.
    pub filter_init_func: ap_init_filter_func,
    /// The type of filter, either AP_FTYPE_CONTENT or AP_FTYPE_CONNECTION.
    /// An AP_FTYPE_CONTENT filter modifies the data based on information
    /// found in the content.  An AP_FTYPE_CONNECTION filter modifies the
    /// data based on the type of connection.
    pub ftype: ap_filter_type,
    /// The next filter_rec in the list
    pub next: *mut ap_filter_rec_t,
    /// Providers for this filter
    pub providers: *mut ap_filter_provider_t,
    /// Trace level for this filter
    pub debug: ::libc::c_int,
    /// Protocol flags for this filter
    pub proto_flags: ::libc::c_uint,
}

#[test]
fn bindgen_test_layout_ap_filter_rec_t() {
    assert_eq!(::std::mem::size_of::<ap_filter_rec_t>(), 56usize, concat!( "Size of: " , stringify ! ( ap_filter_rec_t ) ));
    assert_eq!(::std::mem::align_of::<ap_filter_rec_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_filter_rec_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_rec_t>())).name as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_filter_rec_t ) , "::" , stringify ! ( name ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_rec_t>())).filter_func as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_filter_rec_t ) , "::" , stringify ! ( filter_func ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_rec_t>())).filter_init_func as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_filter_rec_t ) , "::" , stringify ! ( filter_init_func ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_rec_t>())).ftype as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_filter_rec_t ) , "::" , stringify ! ( ftype ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_rec_t>())).next as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_filter_rec_t ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_rec_t>())).providers as *const _ as usize }, 40usize, concat!( "Offset of field: " , stringify ! ( ap_filter_rec_t ) , "::" , stringify ! ( providers ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_rec_t>())).debug as *const _ as usize }, 48usize, concat!( "Offset of field: " , stringify ! ( ap_filter_rec_t ) , "::" , stringify ! ( debug ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_rec_t>())).proto_flags as *const _ as usize }, 52usize, concat!( "Offset of field: " , stringify ! ( ap_filter_rec_t ) , "::" , stringify ! ( proto_flags ) ));
}

/// @brief The representation of a filter chain.
///
/// Each request has a list
/// of these structures which are called in turn to filter the data.  Sub
/// requests get an exact copy of the main requests filter chain.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ap_filter_t {
    /// The internal representation of this filter.  This includes
    /// the filter's name, type, and the actual function pointer.
    pub frec: *mut ffi::ap_filter_rec_t,
    /// A place to store any data associated with the current filter
    pub ctx: *mut ::libc::c_void,
    /// The next filter in the chain
    pub next: *mut ::ffi::ap_filter_t,
    /// The request_rec associated with the current filter.  If a sub-request
    /// adds filters, then the sub-request is the request associated with the
    /// filter.
    pub r: *mut ffi::request_rec,
    /// The conn_rec associated with the current filter.  This is analogous
    /// to the request_rec, except that it is used for input filtering.
    pub c: *mut ffi::conn_rec,
}

#[test]
fn bindgen_test_layout_ap_filter_t() {
    assert_eq!(::std::mem::size_of::<ap_filter_t>(), 40usize, concat!( "Size of: " , stringify ! ( ap_filter_t ) ));
    assert_eq!(::std::mem::align_of::<ap_filter_t>(), 8usize, concat!( "Alignment of " , stringify ! ( ap_filter_t ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_t>())).frec as *const _ as usize }, 0usize, concat!( "Offset of field: " , stringify ! ( ap_filter_t ) , "::" , stringify ! ( frec ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_t>())).ctx as *const _ as usize }, 8usize, concat!( "Offset of field: " , stringify ! ( ap_filter_t ) , "::" , stringify ! ( ctx ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_t>())).next as *const _ as usize }, 16usize, concat!( "Offset of field: " , stringify ! ( ap_filter_t ) , "::" , stringify ! ( next ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_t>())).r as *const _ as usize }, 24usize, concat!( "Offset of field: " , stringify ! ( ap_filter_t ) , "::" , stringify ! ( r ) ));
    assert_eq!(unsafe { &(*(::std::ptr::null::<ap_filter_t>())).c as *const _ as usize }, 32usize, concat!( "Offset of field: " , stringify ! ( ap_filter_t ) , "::" , stringify ! ( c ) ));
}


#[cfg(test)]
mod tests {
    use super::*;


}
